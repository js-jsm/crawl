{
  "source": "doc/api/all.markdown",
  "miscs": [
    {
      "textRaw": "About this Documentation",
      "name": "About this Documentation",
      "type": "misc",
      "desc": "<!--\nThe goal of this documentation is to comprehensively explain the Node.js\nAPI, both from a reference as well as a conceptual point of view.  Each\nsection describes a built-in module or high-level concept.\n\nWhere appropriate, property types, method arguments, and the arguments\nprovided to event handlers are detailed in a list underneath the topic\nheading.\n\nEvery `.html` document has a corresponding `.json` document presenting\nthe same information in a structured manner.  This feature is\nexperimental, and added for the benefit of IDEs and other utilities that\nwish to do programmatic things with the documentation.\n\nEvery `.html` and `.json` file is generated based on the corresponding\n`.markdown` file in the `doc/api/` folder in node's source tree.  The\ndocumentation is generated using the `tools/doc/generate.js` program.\nThe HTML template is located at `doc/template.html`.\n-->\n\n<p>このドキュメントのゴールは、Node.js の API についてリファレンスとしても，\n概念的な視点としても，包括的な説明をすることです。\nそれぞれのセクションは組込のモジュールまたは高水準の概念について記述します。\n\n</p>\n<p>必要に応じて、プロパティの型やメソッドの引数、そしてイベントハンドラに\n与えられる引数などの詳細は見出し直後のリストで与えられます。\n\n</p>\n<p>すべての <code>.html</code> ドキュメントは、対応する <code>.json</code> ドキュメントを持ちます。\nそれは同じ情報を同様の構造で表現します。\nこれは実験的で、ドキュメントをプログラム的に扱いたい IDE や他の\nユーティリティのために加えられました。\n\n</p>\n<p>すべての <code>.html</code> と <code>.json</code> ファイルは、node ソースツリーの <code>doc/api/</code>\nフォルダにある、対応する <code>.markdown</code> ファイルを基に生成されます。\nドキュメントの生成には <code>tools/doc/generate.js</code> が使われます。\nHTML のテンプレートは <code>doc/template.html</code> にあります。\n\n</p>\n",
      "miscs": [
        {
          "textRaw": "Stability Index",
          "name": "Stability Index",
          "type": "misc",
          "desc": "<!--\nThroughout the documentation, you will see indications of a section's\nstability.  The Node.js API is still somewhat changing, and as it\nmatures, certain parts are more reliable than others.  Some are so\nproven, and so relied upon, that they are unlikely to ever change at\nall.  Others are brand new and experimental, or known to be hazardous\nand in the process of being redesigned.\n-->\n\n<p>ドキュメント全体を通して、セクションの安定度に関する目安を見ることが\nできるでしょう。\nNode.js の API はまだ少し変更されます。\nそれが成熟することにより、ある部分は他よりも信頼できるようになります。\nいくつかはそのように証明され、したがって信頼され、それらはおそらく\n変更されそうもありません。\nその他は新しくて実験的か、危険が知られていたり、再実装が始まっていたりします。\n\n</p>\n<!--\nThe stability indices are as follows:\n-->\n\n<p>Stability (安定度) を以下のように示します:\n\n</p>\n<!--\n```\nStability: 0 - Deprecated\nThis feature is known to be problematic, and changes are\nplanned.  Do not rely on it.  Use of the feature may cause warnings.  Backwards\ncompatibility should not be expected.\n```\n-->\n\n<pre><code>Stability: 0 - 廃止予定\nこの機能には問題があることが知られていて、変更が計画されています。\nこれに依存しないでください。この機能を使用すると警告が出されるでしょう。\n後方互換性を期待すべきではありません。</code></pre>\n<!--\n```\nStability: 1 - Experimental\nThis feature was introduced recently, and may change\nor be removed in future versions.  Please try it out and provide feedback.\nIf it addresses a use-case that is important to you, tell the node core team.\n```\n-->\n\n<pre><code>Stability: 1 - 実験的\nこの機能は最近導入され、将来のバージョンで変更されるか削除されるかもしれません。\nそれを試してフィードバックをしてください。\n重要なユースケースで使われるなら、node コアチームに教えてください。</code></pre>\n<!--\n```\nStability: 2 - Unstable\nThe API is in the process of settling, but has not yet had\nsufficient real-world testing to be considered stable. Backwards-compatibility\nwill be maintained if reasonable.\n```\n-->\n\n<pre><code>Stability: 2 - 不安定\nAPI は安定化の途中ですが、まだ安定していると考えられるほどには\n現実世界でテストされていません。\nもし合理的なら後方互換性が維持されるでしょう。</code></pre>\n<!--\n```\nStability: 3 - Stable\nThe API has proven satisfactory, but cleanup in the underlying\ncode may cause minor changes.  Backwards-compatibility is guaranteed.\n```\n-->\n\n<pre><code>Stability: 3 - 安定\nAPI は要求を満たすことがわかりましたが、実装コードをクリーンナップするために\n小さな変更が行われるかもしれません。\n後方互換性は保証されます。</code></pre>\n<!--\n```\nStability: 4 - API Frozen\nThis API has been tested extensively in production and is\nunlikely to ever have to change.\n```\n-->\n\n<pre><code>Stability: 4 - API 凍結\nAPI は実運用で広範囲にテストされており、おそらく変更されることはありません。</code></pre>\n<!--\n```\nStability: 5 - Locked\nUnless serious bugs are found, this code will not ever\nchange.  Please do not suggest changes in this area; they will be refused.\n-->\n\n<pre><code>Stability: 5 - 固定\n深刻なバグが見つからない限り、コードは変更されません。\nこのエリアの変更を提案しないでください; そえは拒否されます。</code></pre>\n"
        },
        {
          "textRaw": "JSON Output",
          "name": "json_output",
          "desc": "<!--\n    Stability: 1 - Experimental\n-->\n\n<pre><code>Stability: 1 - 実験的</code></pre>\n<!--\nEvery HTML file in the markdown has a corresponding JSON file with the\nsame data.\n-->\n\n<p>markdown から作られる全ての HTML ファイルは、対応する JSON ファイルを持ちます。\n\n</p>\n<!--\nThis feature is new as of node v0.6.12.  It is experimental.\n-->\n\n<p>これは v0.6.12 からの新機能で、実験的です。\n\n</p>\n",
          "type": "misc",
          "displayName": "JSON Output"
        }
      ]
    },
    {
      "textRaw": "Synopsis",
      "name": "Synopsis",
      "type": "misc",
      "desc": "<!--\nAn example of a [web server](http.html) written with Node which responds with 'Hello\nWorld':\n-->\n\n<p>'Hello World' と返答する Node で書かれたWebサーバの例:\n\n</p>\n<pre><code>var http = require('http');\n\nhttp.createServer(function (request, response) {\n  response.writeHead(200, {'Content-Type': 'text/plain'});\n  response.end('Hello World\\n');\n}).listen(8124);\n\nconsole.log('Server running at http://127.0.0.1:8124/');</code></pre>\n<!--\nTo run the server, put the code into a file called `example.js` and execute\nit with the node program\n-->\n\n<p>このサーバを実行するには、コードを <code>example.js</code> というファイルに保存し、\nnode コマンドで実行してください。\n\n</p>\n<pre><code>> node example.js\nServer running at http://127.0.0.1:8124/</code></pre>\n<!--\nAll of the examples in the documentation can be run similarly.\n-->\n\n<p>このドキュメントの全てのサンプルは同じように実行することができます。\n\n</p>\n"
    },
    {
      "textRaw": "Global Objects",
      "name": "Global Objects",
      "type": "misc",
      "desc": "<!--\nThese objects are available in all modules. Some of these objects aren't\nactually in the global scope but in the module scope - this will be noted.\n-->\n\n<p>これらのオブジェクトは全てのモジュールで有効です。\nこれらのオブジェクトのいくつかは実際はグローバルスコープではなくモジュールスコープです - 注意してください。\n\n</p>\n",
      "globals": [
        {
          "textRaw": "global",
          "name": "global",
          "type": "global",
          "desc": "<!--\n* {Object} The global namespace object.\n-->\n\n<ul>\n<li>{Object} グローバルなネームスペースのオブジェクト</li>\n</ul>\n<!--\nIn browsers, the top-level scope is the global scope. That means that in\nbrowsers if you're in the global scope `var something` will define a global\nvariable. In Node this is different. The top-level scope is not the global\nscope; `var something` inside a Node module will be local to that module.\n-->\n\n<p>ブラウザでは、トップレベルのスコープはグローバルスコープです。\nこれは、ブラウザではグローバルスコープで <code>var something</code> と定義するとグローバル変数になることを意味します。\nNode では異なります。\nトップレベルのスコープはグローバルスコープではありません;\nNode のモジュール内での <code>var something</code> はそのモジュールでローカルになります。\n\n</p>\n"
        },
        {
          "textRaw": "process",
          "name": "process",
          "type": "global",
          "desc": "<!--\nThe process object. See the [process object][] section.\n-->\n\n<p>プロセスオブジェクトです。[process オブジェクト][] の節を参照してください。\n\n</p>\n"
        },
        {
          "textRaw": "console",
          "name": "console",
          "type": "global",
          "desc": "<!--\nUsed to print to stdout and stderr. See the [console][] section.\n-->\n\n<p>標準出力および標準エラー出力へのプリントに使われます。\n[コンソール][] を参照してください。\n\n</p>\n"
        },
        {
          "textRaw": "Class: Buffer",
          "type": "global",
          "name": "Buffer",
          "desc": "<!--\nUsed to handle binary data. See the [buffer section][]\n-->\n\n<p>バイナリデータを扱うために使われます。\n[バッファセクション][] を参照してください。\n\n</p>\n"
        },
        {
          "textRaw": "clearInterval(t)",
          "type": "global",
          "name": "clearInterval",
          "desc": "<!--\nStop a timer that was previously created with `setInterval()`. The callback\nwill not execute.\n-->\n\n<p><code>setInterval()</code> によって以前に作成されたタイマを終了します。\nコールバックは実行されなくなります。\n\n</p>\n<!--\nThe timer functions are global variables. See the [timers][] section.\n-->\n\n<p>タイマー関数はグローバル変数です。[タイマー][] を参照してください。\n\n</p>\n<!--\n[buffer section]: buffer.html\n[module section]: modules.html\n[module system documentation]: modules.html\n[Modules]: modules.html#modules_modules\n[process object]: process.html#process_process\n[console]: console.html\n[timers]: timers.html\n-->\n\n"
        },
        {
          "textRaw": "console",
          "name": "console",
          "stability": 4,
          "stabilityText": "API Frozen",
          "type": "global",
          "desc": "<!--\nFor printing to stdout and stderr.  Similar to the console object functions\nprovided by most web browsers, here the output is sent to stdout or stderr.\n-->\n\n<p>標準出力と標準エラーに出力するためのものです。\nほとんどのブラウザで提供されているコンソールオブジェクトと同様ですが、\n出力は標準出力か標準エラー出力に送られます。\n\n</p>\n<!--\nThe console functions are synchronous when the destination is a terminal or\na file (to avoid lost messages in case of premature exit) and asynchronous\nwhen it's a pipe (to avoid blocking for long periods of time).\n-->\n\n<p>コンソール関数は出力先がターミナルまたはファイルの場合は同期\n(早すぎる終了によりメッセージが失われるケースを防ぐため)、\nパイプの場合は非同期 (長時間ブロックすることを防ぐため) です。\n\n</p>\n<!--\nThat is, in the following example, stdout is non-blocking while stderr\nis blocking:\n-->\n\n<p>つまり、以下の例では標準出力はノンブロッキングですが、\n標準エラー出力はブロッキングです:\n\n</p>\n<pre><code>$ node script.js 2> error.log | tee info.log</code></pre>\n<!--\nIn daily use, the blocking/non-blocking dichotomy is not something you\nshould worry about unless you log huge amounts of data.\n-->\n\n<p>通常の使用では、膨大な量のデータを記録するのではない限り、\nブロッキング／ノンブロッキングのどちらなのかを心配する必要はありません。\n\n\n</p>\n",
          "methods": [
            {
              "textRaw": "console.log([data], [...])",
              "type": "method",
              "name": "log",
              "desc": "<!--\nPrints to stdout with newline. This function can take multiple arguments in a\n`printf()`-like way. Example:\n-->\n\n<p>改行を伴って標準出力へプリントします。\nこの関数は <code>printf()</code> のように複数の引数を受け付けます。\n\n</p>\n<pre><code>console.log('count: %d', count);</code></pre>\n<!--\nIf formatting elements are not found in the first string then `util.inspect`\nis used on each argument.  See [util.format()][] for more information.\n-->\n\n<p>最初の引数文字列からフォーマット要素が見つからなかった場合は、\n<code>util.inspect</code> が各引数に使われます。\nより詳細は [util.format()][] を参照してください。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "...",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.info([data], [...])",
              "type": "method",
              "name": "info",
              "desc": "<!--\nSame as `console.log`.\n-->\n\n<p><code>console.log</code> と同じです。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "...",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.error([data], [...])",
              "type": "method",
              "name": "error",
              "desc": "<!--\nSame as `console.log` but prints to stderr.\n-->\n\n<p><code>console.log</code> と同様ですが、標準エラー出力にプリントします。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "...",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.warn([data], [...])",
              "type": "method",
              "name": "warn",
              "desc": "<!--\nSame as `console.error`.\n-->\n\n<p><code>console.error()</code> と同じです。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "...",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.dir(obj)",
              "type": "method",
              "name": "dir",
              "desc": "<!--\nUses `util.inspect` on `obj` and prints resulting string to stdout.\n-->\n\n<p><code>util.inspect</code> を使って <code>obj</code> を文字列化した結果を標準出力にプリントします。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "obj"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.time(label)",
              "type": "method",
              "name": "time",
              "desc": "<!--\nMark a time.\n-->\n\n<p>タイマを作成します。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "label"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.timeEnd(label)",
              "type": "method",
              "name": "timeEnd",
              "desc": "<!--\nFinish timer, record output. Example:\n-->\n\n<p>タイマを終了し、結果を出力します。例:\n\n</p>\n<pre><code>console.time('100-elements');\nfor (var i = 0; i < 100; i++) {\n  ;\n}\nconsole.timeEnd('100-elements');</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "label"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.trace(label)",
              "type": "method",
              "name": "trace",
              "desc": "<!--\nPrint a stack trace to stderr of the current position.\n-->\n\n<p>現在のスタックトレースを標準エラー出力にプリントします。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "label"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "console.assert(expression, [message])",
              "type": "method",
              "name": "assert",
              "desc": "<!--\nSame as [assert.ok()][] where if the `expression` evaluates as `false` throw an\nAssertionError with `message`.\n-->\n\n<p>[assert.ok()][] と同様に、もし <code>expression</code> が <code>false</code> に評価されると、\n<code>message</code> を持つ AssertionError がスローされます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "expression"
                    },
                    {
                      "name": "message",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process",
          "name": "process",
          "type": "global",
          "desc": "<!--\nThe `process` object is a global object and can be accessed from anywhere.\nIt is an instance of [EventEmitter][].\n-->\n\n<p><code>process</code> はグローバルオブジェクトで、どこからでもアクセスすることができます。\nそれは [EventEmitter][] のインスタンスです。\n\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'exit'",
              "type": "event",
              "name": "exit",
              "desc": "<!--\nEmitted when the process is about to exit. There is no way to prevent the\nexiting of the event loop at this point, and once all `exit` listeners have\nfinished running the process will exit. Therefore you **must** only perform\n**synchronous** operations in this handler. This is a good hook to perform\nchecks on the module's state (like for unit tests). The callback takes one\nargument, the code the process is exiting with.\n-->\n\n<p>プロセスが終了しようとしている時に生成されます。\nこの位置からイベントループを抜けることを防ぐ方法はなく、全ての <code>'exit'</code>\nリスナーの実行が完了すると、プロセスは終了します。\n従って、このハンドラでできることは <strong>同期</strong> 操作 <strong>だけ</strong> です。\nこれは (ユニットテストのように) モジュールの状態をチェックするのに適した\nフックとなります。\nコールバックはプロセスの終了コードを唯一の引数として呼び出されます。\n\n</p>\n<!--\nExample of listening for `exit`:\n-->\n\n<p><code>exit</code> を監視する例:\n\n</p>\n<pre><code>process.on('exit', function(code) {\n  // do *NOT* do this\n  setTimeout(function() {\n    console.log('This will not run');\n  }, 0);\n  console.log('About to exit with code:', code);\n});</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'uncaughtException'",
              "type": "event",
              "name": "uncaughtException",
              "desc": "<!--\nEmitted when an exception bubbles all the way back to the event loop. If a\nlistener is added for this exception, the default action (which is to print\na stack trace and exit) will not occur.\n-->\n\n<p>発生した例外がイベントループまでたどり着いた場合に生成されます。\nもしこの例外に対するリスナーが加えられていれば、\nデフォルトの動作 (それはスタックトレースをプリントして終了します) は起こりません。\n\n</p>\n<!--\nExample of listening for `uncaughtException`:\n-->\n\n<p><code>uncaughtException</code> を監視する例:\n\n</p>\n<pre><code>process.on('uncaughtException', function(err) {\n  console.log('Caught exception: ' + err);\n});\n\nsetTimeout(function() {\n  console.log('This will still run.');\n}, 500);\n\n// Intentionally cause an exception, but don't catch it.\nnonexistentFunc();\nconsole.log('This will not run.');</code></pre>\n<!--\nNote that `uncaughtException` is a very crude mechanism for exception\nhandling and may be removed in the future.\n-->\n\n<p><code>uncaughtException</code> は例外を扱うとても荒削りなメカニズムであり、\n将来削除されるかもしれないことに注意してください。\n\n</p>\n<!--\nDon't use it, use [domains](domain.html) instead. If you do use it, restart\nyour application after every unhandled exception!\n-->\n\n<p>これを使う代わりに、<a href="\"domain.html\"">ドメイン</a> を使ってください。\nそれを使えば、捕まえられない例外が発生した後でもアプリケーションを\n再開することができます！\n\n</p>\n<!--\nDo *not* use it as the node.js equivalent of `On Error Resume Next`. An\nunhandled exception means your application - and by extension node.js itself -\nis in an undefined state. Blindly resuming means *anything* could happen.\n-->\n\n<p>これを Node.js における <code>On Error Resume Next</code> として <em>使わないで</em> ください。\n捕まえられなかった例外は、アプリケーション\n- および Node.js 自身の拡張 - が未定義の状態となることを意味します。\nやみくもな再開は <em>どんなことでも</em> 起こることを意味します。\n\n</p>\n<!--\nThink of resuming as pulling the power cord when you are upgrading your system.\nNine out of ten times nothing happens - but the 10th time, your system is bust.\n-->\n\n<p>電源を引き抜きながらアプリケーションをアップグレードすることを\n想像してください。\n10 回中 9 回は何も起こりません\n- しかし 10 回目にはそのシステムは使えなくなるかもしれません。\n\n</p>\n<!--\nYou have been warned.\n-->\n\n<p>これは警告です。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Signal Events",
              "name": "SIGINT, SIGHUP, etc.",
              "type": "event",
              "desc": "<!--\nEmitted when the processes receives a signal. See sigaction(2) for a list of\nstandard POSIX signal names such as SIGINT, SIGHUP, etc.\n-->\n\n<p>プロセスがシグナルを受信した場合に生成されます。\nSIGINT、SIGHUP、その他の POSIX 標準シグナル名の一覧について は sigaction(2) を参照してください。\n\n</p>\n<!--\nExample of listening for `SIGINT`:\n-->\n\n<p><code>SIGINT</code>を監視する例:\n\n</p>\n<pre><code>// Start reading from stdin so we don't exit.\nprocess.stdin.resume();\n\nprocess.on('SIGINT', function() {\n  console.log('Got SIGINT.  Press Control-D to exit.');\n});</code></pre>\n<!--\nAn easy way to send the `SIGINT` signal is with `Control-C` in most terminal\nprograms.\n-->\n\n<p>多くの端末プログラムで簡単に <code>SIGINT</code> を送る方法は <code>Control-C</code> を押すことです。\n\n</p>\n<!--\nNote:\n-->\n\n<p>注意:\n\n</p>\n<!--\n- `SIGUSR1` is reserved by node.js to start the debugger.  It's possible to\n  install a listener but that won't stop the debugger from starting.\n- `SIGTERM` and `SIGINT` have default handlers on non-Windows platforms that resets\n  the terminal mode before exiting with code `128 + signal number`. If one of\n  these signals has a listener installed, its default behaviour will be removed\n  (node will no longer exit).\n- `SIGPIPE` is ignored by default, it can have a listener installed.\n- `SIGHUP` is generated on Windows when the console window is closed, and on other\n  platforms under various similar conditions, see signal(7). It can have a\n  listener installed, however node will be unconditionally terminated by Windows\n  about 10 seconds later. On non-Windows platforms, the default behaviour of\n  `SIGHUP` is to terminate node, but once a listener has been installed its\n  default behaviour will be removed.\n- `SIGTERM` is not supported on Windows, it can be listened on.\n- `SIGINT` from the terminal is supported on all platforms, and can usually be\n  generated with `CTRL+C` (though this may be configurable). It is not generated\n  when terminal raw mode is enabled.\n- `SIGBREAK` is delivered on Windows when `CTRL+BREAK` is pressed, on non-Windows\n  platforms it can be listened on, but there is no way to send or generate it.\n- `SIGWINCH` is delivered when the console has been resized. On Windows, this will\n  only happen on write to the console when the cursor is being moved, or when a\n  readable tty is used in raw mode.\n- `SIGKILL` cannot have a listener installed, it will unconditionally terminate\n  node on all platforms.\n- `SIGSTOP` cannot have a listener installed.\n-->\n\n<ul>\n<li><code>SIGUSR1</code> は Node.js がデバッガを起動するために予約されています。\nリスナを登録することは出来ますが、デバッガの起動を止めることは出来ません。</li>\n<li><code>SIGTERM</code> および <code>SIGINT</code> は、Windows 以外のプラットフォームでは\n<code>128</code> + シグナル番号で終了する前にターミナルのモードをリセットする\nデフォルトのハンドラを持ちます。\nこれらのシグナルのどちらかにリスナが登録されると、デフォルトの振る舞いは\n削除されます (node は終了しなくなります)。</li>\n<li><code>SIGPIPE</code> はデフォルトでは無視され、リスナを登録することが出来ます。</li>\n<li><code>SIGHUP</code> は Windows ではコンソールウィンドウが閉じられると発生します。\n他のプラットフォームでも同様の条件で発生します。詳細は signal(7)\nを参照してください。\nリスナを登録することは出来ますが、Windows では約 10 秒後に node は無条件に\nWindows によって終了されます。\nWindows 以外のプラットフォームでは、<code>SIGHUP</code> のデフォルトの振る舞いは\nnodeを終了することですが、リスナを登録するとデフォルトの振る舞いは\n削除されます。</li>\n<li><code>SIGTERM</code> は Windows ではサポートされません。\nしかし、リスナを登録することは可能です。</li>\n<li>端末からの <code>SIGINT</code> は全てのプラットフォームでサポートされ、通常 <code>CTRL+C</code>\n(おそらく設定可能でしょう) によって生成されます。\nターミナルが raw モードの場合は生成されません。</li>\n<li><code>SIGBREAK</code> は Windows において <code>CTRL+BREAK</code> が推された時に送られます。\nWindows 以外のプラットフォームでもリスナを登録することは出来ますが、\nそれを生成したり送信する方法はありません。</li>\n<li><code>SIGWINCH</code> はコンソールのサイズが変更された場合に送られます。\nWindows では、カーソルが移動するか、tty が raw モードの場合に、\nコンソールへ書き込むと発生します。</li>\n<li><code>SIGKILL</code> のリスナを組み込むことは出来ません。\nそれは全てのプラットフォームで node を無条件に終了します。</li>\n<li><code>SIGSTOP</code> のリスナを組み込むことは出来ません。</li>\n</ul>\n<!--\nNote that Windows does not support sending Signals, but node offers some\nemulation with `process.kill()`, and `child_process.kill()`:\n- Sending signal `0` can be used to search for the existence of a process\n- Sending `SIGINT`, `SIGTERM`, and `SIGKILL` cause the unconditional exit of the\n  target process.\n-->\n\n<p>Windows はシグナルの送信をサポートしていませんが、nodeは<code>process.kill()</code> や\n<code>child_process.kill()</code> をエミュレートする方法を提供します:\n\n</p>\n<ul>\n<li>シグナル <code>0</code> は既存のプロセスを検索するためのものです。</li>\n<li><code>SIGINT</code>、<code>SIGTERM</code>、そして <code>SIGKILL</code> は、ターゲットのプロセスが無条件に\n終了する原因となります。</li>\n</ul>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "process.stdout",
              "name": "stdout",
              "desc": "<!--\nA `Writable Stream` to `stdout`.\n-->\n\n<p><code>stdout</code> に対する <code>Writable Stream</code> です。\n\n</p>\n<!--\nExample: the definition of `console.log`\n-->\n\n<p>例: <code>console.log</code> の定義\n\n</p>\n<pre><code>console.log = function(d) {\n  process.stdout.write(d + '\\n');\n};</code></pre>\n<!--\n`process.stderr` and `process.stdout` are unlike other streams in Node in\nthat writes to them are usually blocking.\n-->\n\n<p><code>process.stderr</code> と <code>process.stdout</code> は Node の他のストリームと異なり、\nそれらへの書き込みは通常ブロックします。\n\n</p>\n<!--\n- They are blocking in the case that they refer to regular files or TTY file\n  descriptors.\n- In the case they refer to pipes:\n  - They are blocking in Linux/Unix.\n  - They are non-blocking like other streams in Windows.\n-->\n\n<ul>\n<li>ファイル記述子が通常ファイルや TTY を参照しているケースでは、\nそれらはブロックします。</li>\n<li>パイプを参照しているケースでは:<ul>\n<li>Linux/Unix ではそれらはブロックします。</li>\n<li>Windows では他のストリームと同様にブロックしません。</li>\n</ul>\n</li>\n</ul>\n<!--\nTo check if Node is being run in a TTY context, read the `isTTY` property\non `process.stderr`, `process.stdout`, or `process.stdin`:\n-->\n\n<p>Node が TTY のコンテキストで実行されているかチェックするには、\n<code>process.stderr</code>, <code>process.stdout</code>, または <code>process.stdin</code> の\n<code>isTTY</code> プロパティを参照します。\n\n</p>\n<pre><code>$ node -p "Boolean(process.stdin.isTTY)"\ntrue\n$ echo "foo" | node -p "Boolean(process.stdin.isTTY)"\nfalse\n\n$ node -p "Boolean(process.stdout.isTTY)"\ntrue\n$ node -p "Boolean(process.stdout.isTTY)" | cat\nfalse</code></pre>\n<!--\nSee [the tty docs](tty.html#tty_tty) for more information.\n-->\n\n<p>より詳細は <a href="\"tty.html#tty_tty\"">the tty docs</a> を参照してください。\n\n</p>\n"
            },
            {
              "textRaw": "process.stderr",
              "name": "stderr",
              "desc": "<!--\nA writable stream to stderr.\n\n`process.stderr` and `process.stdout` are unlike other streams in Node in\nthat writes to them are usually blocking.\n-->\n\n<p><code>stderr</code> に対する <code>Writable Stream</code> です。\n\n</p>\n<p><code>process.stderr</code> と <code>process.stdout</code> は Node の他のストリームと異なり、\nそれらへの書き込みは通常ブロックします。\n\n</p>\n<!--\n- They are blocking in the case that they refer to regular files or TTY file\n  descriptors.\n- In the case they refer to pipes:\n  - They are blocking in Linux/Unix.\n  - They are non-blocking like other streams in Windows.\n-->\n\n<ul>\n<li>ファイル記述子が通常ファイルや TTY を参照しているケースでは、\nそれらはブロックします。</li>\n<li>パイプを参照しているケースでは:<ul>\n<li>Linux/Unix ではそれらはブロックします。</li>\n<li>Windows では他のストリームと同様にブロックしません。</li>\n</ul>\n</li>\n</ul>\n"
            },
            {
              "textRaw": "process.stdin",
              "name": "stdin",
              "desc": "<!--\nA `Readable Stream` for stdin. \n-->\n\n<p>標準入力に対する <code>Readable Stream</code> です。\n\n</p>\n<!--\nExample of opening standard input and listening for both events:\n-->\n\n<p>標準入力をオープンして二つのイベントを監視する例:\n\n</p>\n<pre><code>process.stdin.setEncoding('utf8');\n\nprocess.stdin.on('readable', function(chunk) {\n  var chunk = process.stdin.read();\n  if (chunk !== null) {\n    process.stdout.write('data: ' + chunk);\n  }\n});\n\nprocess.stdin.on('end', function() {\n  process.stdout.write('end');\n});</code></pre>\n<!--\nAs a Stream, `process.stdin` can also be used in \"old\" mode that is compatible\nwith scripts written for node prior v0.10.\nFor more information see\n[Stream compatibility](stream.html#stream_compatibility_with_older_node_versions).\n-->\n\n<p>ストリームであるため、<code>process.stdin</code> は v0.10 以前の node 向けに書かれた\nスクリプトと互換性のある "old" モードで使うことが出来ます。より詳細な情報は\n<a href="\"stream.html#stream_compatibility_with_older_node_versions\"">Stream compatibility</a>\nを参照してください。\n\n</p>\n<!--\nIn \"old\" Streams mode the stdin stream is paused by default, so one\nmust call `process.stdin.resume()` to read from it. Note also that calling\n`process.stdin.resume()` itself would switch stream to \"old\" mode.\n-->\n\n<p>"old" モードでは標準入力ストリームはデフォルトで中断状態のため、\n読み込みには <code>process.stdin.resume()</code> の呼び出しが必須です。\n<code>process.stdin.resume()</code> を呼び出すことにより、それ自体がストリームを\n"old" モードに切り替えることに注意してください。\n\n</p>\n<!--\nIf you are starting a new project you should prefer a more recent \"new\" Streams\nmode over \"old\" one.\n-->\n\n<p>もし新しいプロジェクトを始めるなら、"old" よりも\n"new" ストリームを好むべきです。\n\n</p>\n"
            },
            {
              "textRaw": "process.argv",
              "name": "argv",
              "desc": "<!--\nAn array containing the command line arguments.  The first element will be\n'node', the second element will be the name of the JavaScript file.  The\nnext elements will be any additional command line arguments.\n-->\n\n<p>コマンドライン引数を含む配列です。\n最初の要素は 'node'、2 番目の要素は JavaScript ファイルの名前になります。\nその後の要素はコマンドラインの追加の引数になります。\n\n</p>\n<pre><code>// print process.argv\nprocess.argv.forEach(function(val, index, array) {\n  console.log(index + ': ' + val);\n});</code></pre>\n<!--\nThis will generate:\n-->\n\n<p>このように出力されます:\n\n</p>\n<pre><code>$ node process-2.js one two=three four\n0: node\n1: /Users/mjr/work/node/process-2.js\n2: one\n3: two=three\n4: four</code></pre>\n"
            },
            {
              "textRaw": "process.execPath",
              "name": "execPath",
              "desc": "<!--\nThis is the absolute pathname of the executable that started the process.\n-->\n\n<p>プロセスによって開始された実行可能ファイルの絶対パスです。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>/usr/local/bin/node</code></pre>\n"
            },
            {
              "textRaw": "process.execArgv",
              "name": "execArgv",
              "desc": "<!--\nThis is the set of node-specific command line options from the\nexecutable that started the process.  These options do not show up in\n`process.argv`, and do not include the node executable, the name of\nthe script, or any options following the script name. These options\nare useful in order to spawn child processes with the same execution\nenvironment as the parent.\n-->\n\n<p>これはプロセス起動時に実行可能ファイルに与えられた node 固有の\nコマンドライン・オプション群です。\nそれらのオプションは <code>process.argv</code> には現れず、node の実行可能ファイルや\nスクリプト名、スクリプト名に続くどんなオプションも含まれません。\nこれらのオプションは親プロセスと同じ実行環境を持つ子プロセスを起動するために\n役に立ちます。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>$ node --harmony script.js --version</code></pre>\n<!--\nresults in process.execArgv:\n-->\n\n<p><code>process.execArgv</code> の結果:\n\n</p>\n<pre><code>['--harmony']</code></pre>\n<!--\nand process.argv:\n-->\n\n<p>そして <code>process.argv</code> の結果:\n\n</p>\n<pre><code>['/usr/local/bin/node', 'script.js', '--version']</code></pre>\n"
            },
            {
              "textRaw": "process.env",
              "name": "env",
              "desc": "<!--\nAn object containing the user environment. See environ(7).\n-->\n\n<p>ユーザの環境を含むオブジェクトです。environ(7) を参照してください。\n\n\n</p>\n"
            },
            {
              "textRaw": "process.version",
              "name": "version",
              "desc": "<!--\nA compiled-in property that exposes `NODE_VERSION`.\n-->\n\n<p><code>NODE_VERSION</code> を提示するコンパイル済みプロパティです。\n\n</p>\n<pre><code>console.log('Version: ' + process.version);</code></pre>\n"
            },
            {
              "textRaw": "process.versions",
              "name": "versions",
              "desc": "<!--\nA property exposing version strings of node and its dependencies.\n-->\n\n<p>node と依存ライブラリのバージョン文字列を提示します。\n\n</p>\n<pre><code>console.log(process.versions);</code></pre>\n<!--\nWill print something like:\n-->\n\n<p>は以下のように出力します。\n\n</p>\n<pre><code>{ http_parser: '1.0',\n  node: '0.10.4',\n  v8: '3.14.5.8',\n  ares: '1.9.0-DEV',\n  uv: '0.10.3',\n  zlib: '1.2.3',\n  modules: '11',\n  openssl: '1.0.1e' }</code></pre>\n"
            },
            {
              "textRaw": "process.config",
              "name": "config",
              "desc": "<!--\nAn Object containing the JavaScript representation of the configure options\nthat were used to compile the current node executable. This is the same as\nthe \"config.gypi\" file that was produced when running the `./configure` script.\n\nAn example of the possible output looks like:\n-->\n\n<p>現在のnode実行ファイルをコンパイルした際に使われた configure のオプションを\nJavaScript で表現したオブジェクトを保持します。\nこれは <code>./configure</code> スクリプトを実行した際に生成された "cofnig.gypi"\nファイルと同じです。\n\n</p>\n<p>実際の出力の例です:\n\n</p>\n<pre><code>{ target_defaults:\n   { cflags: [],\n     default_configuration: 'Release',\n     defines: [],\n     include_dirs: [],\n     libraries: [] },\n  variables:\n   { host_arch: 'x64',\n     node_install_npm: 'true',\n     node_prefix: '',\n     node_shared_cares: 'false',\n     node_shared_http_parser: 'false',\n     node_shared_libuv: 'false',\n     node_shared_v8: 'false',\n     node_shared_zlib: 'false',\n     node_use_dtrace: 'false',\n     node_use_openssl: 'true',\n     node_shared_openssl: 'false',\n     strict_aliasing: 'true',\n     target_arch: 'x64',\n     v8_use_snapshot: 'true' } }</code></pre>\n"
            },
            {
              "textRaw": "process.pid",
              "name": "pid",
              "desc": "<!--\nThe PID of the process.\n-->\n\n<p>このプロセスの PID です。\n\n</p>\n<pre><code>console.log('This process is pid ' + process.pid);</code></pre>\n"
            },
            {
              "textRaw": "process.title",
              "name": "title",
              "desc": "<!--\nGetter/setter to set what is displayed in 'ps'.\n-->\n\n<p>'ps' でどのよう表示されるかを設定するための getter/setter です。\n\n</p>\n<!--\nWhen used as a setter, the maximum length is platform-specific and probably\nshort.\n-->\n\n<p>setter が使われる場合、その最大長はプラットフォーム依存で、おそらく短いです。\n\n</p>\n<!--\nOn Linux and OS X, it's limited to the size of the binary name plus the\nlength of the command line arguments because it overwrites the argv memory.\n-->\n\n<p>Linux と OS X では、それは argv のメモリを上書きするため、\nバイナリ名にコマンドライン引数を加えたものに制限されます。\n\n</p>\n<!--\nv0.8 allowed for longer process title strings by also overwriting the environ\nmemory but that was potentially insecure/confusing in some (rather obscure)\ncases.\n-->\n\n<p>v0.8 はより長いプロセスタイトル文字列で環境を上書きしていましたが、\nそれはいくつかの (はっきりしない) ケースにおいて、\n潜在的に危険で混乱していました。\n\n\n</p>\n"
            },
            {
              "textRaw": "process.arch",
              "name": "arch",
              "desc": "<!--\nWhat processor architecture you're running on: `'arm'`, `'ia32'`, or `'x64'`.\n-->\n\n<p>実行しているプロセッサのアーキテクチャ: <code>'arm'</code>、<code>'ia32'</code>、または\n<code>'x64'</code>。\n\n</p>\n<pre><code>console.log('This processor architecture is ' + process.arch);</code></pre>\n"
            },
            {
              "textRaw": "process.platform",
              "name": "platform",
              "desc": "<!--\nWhat platform you're running on:\n`'darwin'`, `'freebsd'`, `'linux'`, `'sunos'` or `'win32'`\n-->\n\n<p>どのプラットフォームで動いているかを示します:\n<code>'darwin'</code>、<code>'freebsd'</code>、<code>'linux'</code>、<code>'sunos'</code>、または <code>'win32'</code>\n\n</p>\n<pre><code>console.log('This platform is ' + process.platform);</code></pre>\n"
            },
            {
              "textRaw": "`maxTickDepth` {Number} Default = 1000 ",
              "name": "maxTickDepth",
              "desc": "<!--\nCallbacks passed to `process.nextTick` will *usually* be called at the\nend of the current flow of execution, and are thus approximately as fast\nas calling a function synchronously.  Left unchecked, this would starve\nthe event loop, preventing any I/O from occurring.\n-->\n\n<p><code>process.nextTick()</code> に渡されたコールバックは、<em>通常</em> 現在の実行フローの\n後で呼び出され、それは関数を同期的に呼び出すのと同じくらい高速です。\nこれを放置するとあらゆる I/O が阻まれ、イベントループは飢餓状態となるでしょう。\n\n</p>\n<!--\nConsider this code:\n-->\n\n<p>以下のコードを考えてみてください。\n\n</p>\n<pre><code>process.nextTick(function foo() {\n  process.nextTick(foo);\n});</code></pre>\n<!--\nIn order to avoid the situation where Node is blocked by an infinite\nloop of recursive series of nextTick calls, it defers to allow some I/O\nto be done every so often.\n-->\n\n<p>nextTick の再帰が連鎖する無限ループによって Node がブロックする状況を\n避けるには、それを先送りして時々 I/O を可能にします。\n\n</p>\n<!--\nThe `process.maxTickDepth` value is the maximum depth of\nnextTick-calling nextTick-callbacks that will be evaluated before\nallowing other forms of I/O to occur.\n-->\n\n<p><code>process.maxTickDepth</code> の値は、nextTick が nextTick のコールバックを呼び出す\n最大の深さで、他の I/O を可能にする前に評価されます。\n\n</p>\n",
              "shortDesc": "Default = 1000"
            }
          ],
          "methods": [
            {
              "textRaw": "process.abort()",
              "type": "method",
              "name": "abort",
              "desc": "<!--\nThis causes node to emit an abort. This will cause node to exit and\ngenerate a core file.\n-->\n\n<p>これは node をアボートさせます。\nこれは node が終了してコアファイルを生成する原因となります。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.chdir(directory)",
              "type": "method",
              "name": "chdir",
              "desc": "<!--\nChanges the current working directory of the process or throws an exception if that fails.\n-->\n\n<p>プロセスのカレントワーキングディレクトリを変更します。\nもし失敗した場合は例外をスローします。\n\n</p>\n<pre><code>console.log('Starting directory: ' + process.cwd());\ntry {\n  process.chdir('/tmp');\n  console.log('New directory: ' + process.cwd());\n}\ncatch (err) {\n  console.log('chdir: ' + err);\n}</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "directory"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.cwd()",
              "type": "method",
              "name": "cwd",
              "desc": "<!--\nReturns the current working directory of the process.\n-->\n\n<p>プロセスのカレントワーキングディレクトリを返します。\n\n</p>\n<pre><code>console.log('Current directory: ' + process.cwd());</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.exit([code])",
              "type": "method",
              "name": "exit",
              "desc": "<!--\nEnds the process with the specified `code`.  If omitted, exit uses the\n'success' code `0`.\n-->\n\n<p>指定の <code>code</code> でプロセスを終了します。\nもし省略されると、「成功」を示すコード <code>0</code> を使って終了します。\n\n</p>\n<!--\nTo exit with a 'failure' code:\n-->\n\n<p>「失敗」を示すコードで終了する例:\n\n</p>\n<pre><code>process.exit(1);</code></pre>\n<!--\nThe shell that executed node should see the exit code as 1.\n-->\n\n<p>node を実行したシェルで終了コードが 1 であることを見ることができるでしょう。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "code",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.getgid()",
              "type": "method",
              "name": "getgid",
              "desc": "<!--\nNote: this function is only available on POSIX platforms (i.e. not Windows)\n-->\n\n<p>注意: この関数は POSIX プラットフォーム (すなわち、非 Windows)\nでのみ利用可能です。\n\n</p>\n<!--\nGets the group identity of the process. (See getgid(2).)\nThis is the numerical group id, not the group name.\n-->\n\n<p>プロセスのグループ識別子を取得します (getgid(2) 参照)。\nこれは数値によるグループ ID で、グループ名ではありません。\n\n</p>\n<pre><code>if (process.getgid) {\n  console.log('Current gid: ' + process.getgid());\n}</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.setgid(id)",
              "type": "method",
              "name": "setgid",
              "desc": "<!--\nNote: this function is only available on POSIX platforms (i.e. not Windows)\n-->\n\n<p>注意: この関数は POSIX プラットフォーム (すなわち、非 Windows)\nでのみ利用可能です。\n\n</p>\n<!--\nSets the group identity of the process. (See setgid(2).)  This accepts either\na numerical ID or a groupname string. If a groupname is specified, this method\nblocks while resolving it to a numerical ID.\n-->\n\n<p>プロセスのグループ識別子を設定します (setgid(2) 参照)。\nこれは数値による ID もグループ名の文字列のどちらも受け入れます。\nもしグループ名が指定されると、数値による ID が解決できるまでこのメソッドはブロックします。\n\n</p>\n<pre><code>if (process.getgid && process.setgid) {\n  console.log('Current gid: ' + process.getgid());\n  try {\n    process.setgid(501);\n    console.log('New gid: ' + process.getgid());\n  }\n  catch (err) {\n    console.log('Failed to set gid: ' + err);\n  }\n}</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "id"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.getuid()",
              "type": "method",
              "name": "getuid",
              "desc": "<!--\nNote: this function is only available on POSIX platforms (i.e. not Windows)\n-->\n\n<p>注意: この関数は POSIX プラットフォーム (すなわち、非 Windows)\nでのみ利用可能です。\n\n</p>\n<!--\nGets the user identity of the process. (See getuid(2).)\nThis is the numerical userid, not the username.\n-->\n\n<p>プロセスのユーザ識別子を取得します (getuid(2) 参照)。\nこれは数値によるユーザ ID で、ユーザ名ではありません。\n\n</p>\n<pre><code>if (process.getuid) {\n  console.log('Current uid: ' + process.getuid());\n}</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.setuid(id)",
              "type": "method",
              "name": "setuid",
              "desc": "<!--\nNote: this function is only available on POSIX platforms (i.e. not Windows)\n-->\n\n<p>注意: この関数は POSIX プラットフォーム (すなわち、非 Windows)\nでのみ利用可能です。\n\n</p>\n<!--\nSets the user identity of the process. (See setuid(2).)  This accepts either\na numerical ID or a username string.  If a username is specified, this method\nblocks while resolving it to a numerical ID.\n-->\n\n<p>プロセスのユーザ識別子を設定します (setuid(2) 参照)。\nこれは数値による ID もユーザ名の文字列のどちらも受け入れます。\nもしユーザ名が指定されると、数値による ID が解決できるまでこのメソッドはブロックします。\n\n</p>\n<pre><code>if (process.getuid && process.setuid) {\n  console.log('Current uid: ' + process.getuid());\n  try {\n    process.setuid(501);\n    console.log('New uid: ' + process.getuid());\n  }\n  catch (err) {\n    console.log('Failed to set uid: ' + err);\n  }\n}</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "id"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.getgroups()",
              "type": "method",
              "name": "getgroups",
              "desc": "<!--\nNote: this function is only available on POSIX platforms (i.e. not Windows)\n-->\n\n<p>注意: この関数は POSIC プラットフォーム (つまり Windows 以外)\nでのみ利用可能です。\n\n</p>\n<!--\nReturns an array with the supplementary group IDs. POSIX leaves it unspecified\nif the effective group ID is included but node.js ensures it always is.\n-->\n\n<p>補助グループ ID の配列を返します。\nPOSIX は実効グループ ID が含まれることを明示していませんが、\nNode.js では常にそれが含まれることを保証します。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.setgroups(groups)",
              "type": "method",
              "name": "setgroups",
              "desc": "<!--\nNote: this function is only available on POSIX platforms (i.e. not Windows)\n-->\n\n<p>注意: この関数は POSIC プラットフォーム (つまり Windows 以外)\nでのみ利用可能です。\n\n</p>\n<!--\nSets the supplementary group IDs. This is a privileged operation, meaning you\nneed to be root or have the CAP_SETGID capability.\n-->\n\n<p>補助グループ ID を設定します。\nこれは特権オペレーションであり、ルートであるか、または CAP_SETGID ケーパビリティを持つ必要があります。\n\n</p>\n<!--\nThe list can contain group IDs, group names or both.\n-->\n\n<p>リストはグループ ID、グループ名、または両方を含むことができます。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "groups"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.initgroups(user, extra_group)",
              "type": "method",
              "name": "initgroups",
              "desc": "<!--\nNote: this function is only available on POSIX platforms (i.e. not Windows)\n-->\n\n<p>注意: この関数は POSIC プラットフォーム (つまり Windows 以外)\nでのみ利用可能です。\n\n</p>\n<!--\nReads /etc/group and initializes the group access list, using all groups of\nwhich the user is a member. This is a privileged operation, meaning you need\nto be root or have the CAP_SETGID capability.\n-->\n\n<p><code>/etc/group</code> を読み込んでグループアクセスリストを初期化し、\nuser がメンバーである全てのグループを使用します。\nこれは特権オペレーションであり、ルートであるか、または CAP_SETGID ケーパビリティを持つ必要があります。\n\n</p>\n<!--\n`user` is a user name or user ID. `extra_group` is a group name or group ID.\n-->\n\n<p><code>user</code> はユーザ名またはユーザ ID、\n<code>extra_group</code> はグループ名またはグループ ID です。\n\n</p>\n<!--\nSome care needs to be taken when dropping privileges. Example:\n-->\n\n<p>特権を落とす際は、いくつか注意すべき事があります。例:\n\n</p>\n<pre><code>console.log(process.getgroups());         // [ 0 ]\nprocess.initgroups('bnoordhuis', 1000);   // switch user\nconsole.log(process.getgroups());         // [ 27, 30, 46, 1000, 0 ]\nprocess.setgid(1000);                     // drop root gid\nconsole.log(process.getgroups());         // [ 27, 30, 46, 1000 ]</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "user"
                    },
                    {
                      "name": "extra_group"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.kill(pid, [signal])",
              "type": "method",
              "name": "kill",
              "desc": "<!--\nSend a signal to a process. `pid` is the process id and `signal` is the\nstring describing the signal to send.  Signal names are strings like\n'SIGINT' or 'SIGHUP'.  If omitted, the signal will be 'SIGTERM'.\nSee [Signal Events](#process_signal_events) and kill(2) for more information.\n-->\n\n<p>プロセスにシグナルを送ります。\n<code>pid</code> はプロセス ID で <code>signal</code> は送信されるシグナルを文字列で記述したものです。\nシグナルの名前は 'SIGINT' や 'SIGHUP' のような文字列です。\n省略すると、シグナルは 'SIGTERM' となります。\n詳細は <a href="\"#process_signal_events\"">Signal Events</a> または kill(2)\nを参照してください。\n\n</p>\n<!--\nWill throw an error if target does not exist, and as a special case, a signal of\n`0` can be used to test for the existence of a process.\n-->\n\n<p>対象が存在しなければエラーがスローされます。\n特別なケースとして、プロセスが存在するかどうかテストするためにシグナル\n<code>0</code> を使うことが出来ます。\n\n</p>\n<!--\nNote that just because the name of this function is `process.kill`, it is\nreally just a signal sender, like the `kill` system call.  The signal sent\nmay do something other than kill the target process.\n-->\n\n<p>この関数の名前が <code>process.kill</code> であるとおり、これは <code>kill</code>\nシステムコールのように単にシグナルを送信することに注意してください。\n対象のプロセスを殺すためだけでなく、他のシグナルも送信できます。\n\n</p>\n<!--\nExample of sending a signal to yourself:\n-->\n\n<p>自身にシグナルを送信する例:\n\n</p>\n<pre><code>process.on('SIGHUP', function() {\n  console.log('Got SIGHUP signal.');\n});\n\nsetTimeout(function() {\n  console.log('Exiting.');\n  process.exit(0);\n}, 100);\n\nprocess.kill(process.pid, 'SIGHUP');</code></pre>\n<!--\nNote: When SIGUSR1 is received by Node.js it starts the debugger, see\n[Signal Events](#process_signal_events).\n-->\n\n<p>注意: SIGUSR1はnode.jsによって受信され、デバッガを起動します。\n詳細は <a href="\"#process_signal_events\"">Signal Events</a> を参照してください。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "pid"
                    },
                    {
                      "name": "signal",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.memoryUsage()",
              "type": "method",
              "name": "memoryUsage",
              "desc": "<!--\nReturns an object describing the memory usage of the Node process\nmeasured in bytes.\n-->\n\n<p>Node プロセスのメモリ使用状況をバイト単位で記述したオブジェクトを返します。\n\n</p>\n<pre><code>var util = require('util');\n\nconsole.log(util.inspect(process.memoryUsage()));</code></pre>\n<!--\nThis will generate:\n-->\n\n<p>このように生成されます:\n\n</p>\n<pre><code>{ rss: 4935680,\n  heapTotal: 1826816,\n  heapUsed: 650472 }</code></pre>\n<!--\n`heapTotal` and `heapUsed` refer to V8's memory usage.\n-->\n\n<p><code>heapTotal</code> と <code>heapUsed</code> は V8 のメモリ使用状況を参照します。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.nextTick(callback)",
              "type": "method",
              "name": "nextTick",
              "desc": "<!--\nOn the next loop around the event loop call this callback.\nThis is *not* a simple alias to `setTimeout(fn, 0)`, it's much more\nefficient.  It typically runs before any other I/O events fire, but there\nare some exceptions.  See `process.maxTickDepth` below.\n-->\n\n<p>イベントループの次以降のループでコールバックを呼び出します。\nこれは <code>setTimeout(fn, 0)</code> の単純なエイリアス<em>ではなく</em>、\nはるかに効率的です。\nこれは通常他の I/O イベントが発生するよりも前に実行されますが、\nいくつかの例外があります。\n後述の <code>process.maxTickDepth</code> を参照してください。\n\n</p>\n<pre><code>process.nextTick(function() {\n  console.log('nextTick callback');\n});</code></pre>\n<!--\nThis is important in developing APIs where you want to give the user the\nchance to assign event handlers after an object has been constructed,\nbut before any I/O has occurred.\n-->\n\n<p>これは API の開発において、オブジェクトが構築された後で\nどんな I/O イベントが発生するよりも前に、\nイベントハンドラを割り当てるチャンスをユーザに与えたい場合に重要になります。\n\n</p>\n<pre><code>function MyThing(options) {\n  this.setupOptions(options);\n\n  process.nextTick(function() {\n    this.startDoingStuff();\n  }.bind(this));\n}\n\nvar thing = new MyThing();\nthing.getReadyForStuff();\n\n// thing.startDoingStuff() gets called now, not before.</code></pre>\n<!--\nIt is very important for APIs to be either 100% synchronous or 100%\nasynchronous.  Consider this example:\n-->\n\n<p>API は 100% 同期的か、100% 非同期的かのどちらかであることがとても重要です。\nこの例を考えてみてください:\n\n</p>\n<pre><code>// WARNING!  DO NOT USE!  BAD UNSAFE HAZARD!\nfunction maybeSync(arg, cb) {\n  if (arg) {\n    cb();\n    return;\n  }\n\n  fs.stat('file', cb);\n}</code></pre>\n<!--\nThis API is hazardous.  If you do this:\n-->\n\n<p>この API は危険です。こうすると:\n\n</p>\n<pre><code>maybeSync(true, function() {\n  foo();\n});\nbar();</code></pre>\n<!--\nthen it's not clear whether `foo()` or `bar()` will be called first.\n-->\n\n<p><code>foo()</code> と <code>bar()</code> のどちらが先に呼び出されるか不明瞭になります。\n\n</p>\n<!--\nThis approach is much better:\n-->\n\n<p>以下のアプローチはずっと優れています:\n\n</p>\n<pre><code>function definitelyAsync(arg, cb) {\n  if (arg) {\n    process.nextTick(cb);\n    return;\n  }\n\n  fs.stat('file', cb);\n}</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.umask([mask])",
              "type": "method",
              "name": "umask",
              "desc": "<!--\nSets or reads the process's file mode creation mask. Child processes inherit\nthe mask from the parent process. Returns the old mask if `mask` argument is\ngiven, otherwise returns the current mask.\n-->\n\n<p>プロセスのファイルモード作成マスクを設定または読み込みます。\n子プロセスは親プロセスからマスクを継承します。\n<code>mask</code> 引数が与えられると元のマスクが返され、そうでなければ現在のマスクが返されます。\n\n</p>\n<pre><code>var oldmask, newmask = 0644;\n\noldmask = process.umask(newmask);\nconsole.log('Changed umask from: ' + oldmask.toString(8) +\n            ' to ' + newmask.toString(8));</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "mask",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "process.uptime()",
              "type": "method",
              "name": "uptime",
              "desc": "<!--\nNumber of seconds Node has been running.\n-->\n\n<p>Node が実行されてからの秒数です。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "process.hrtime()",
              "type": "method",
              "name": "hrtime",
              "desc": "<!--\nReturns the current high-resolution real time in a `[seconds, nanoseconds]`\ntuple Array. It is relative to an arbitrary time in the past. It is not\nrelated to the time of day and therefore not subject to clock drift. The\nprimary use is for measuring performance between intervals.\n\nYou may pass in the result of a previous call to `process.hrtime()` to get\na diff reading, useful for benchmarks and measuring intervals:\n-->\n\n<p>高分解能な現在時刻を <code>[seconds, nanoseconds]</code> の配列で返します。\n過去の任意の時間との比較することができます。\nそれは一日における時刻には関連が無いため、クロックドリフトに影響されません。\n主な用途はベンチマークやインターバルの測定です。\n\n</p>\n<p>以前に <code>process.hrtime()</code> を呼び出した結果を渡すことにより、\n差分を得ることができます。これはベンチマークやインターバルの測定に便利です。\n\n</p>\n<pre><code>var time = process.hrtime();\n// [ 1800216, 25 ]\n\nsetTimeout(function() {\n  var diff = process.hrtime(time);\n  // [ 1, 552 ]\n\n  console.log('benchmark took %d nanoseconds', diff[0] * 1e9 + diff[1]);\n  // benchmark took 1000000527 nanoseconds\n}, 1000);</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        }
      ],
      "vars": [
        {
          "textRaw": "require()",
          "type": "var",
          "name": "require",
          "desc": "<!--\nTo require modules. See the [Modules][] section.  `require` isn't actually a\nglobal but rather local to each module.\n-->\n\n<p>require モジュールを指します。[モジュール][] の節を参照してください。\n<code>require</code> は実際はグローバルではなく、各モジュール毎のローカルです。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "require.resolve()",
              "type": "method",
              "name": "resolve",
              "desc": "<!--\nUse the internal `require()` machinery to look up the location of a module,\nbut rather than loading the module, just return the resolved filename.\n-->\n\n<p><code>require()</code> の内部でモジュールの位置を検索するために使われます。\nモジュールのロードは行わず、ファイル名を解決して返すだけです。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "`cache` {Object} ",
              "name": "cache",
              "desc": "<!--\nModules are cached in this object when they are required. By deleting a key\nvalue from this object, the next `require` will reload the module.\n-->\n\n<p>モジュールが要求されると、このオブジェクトの中にキャッシュされます。\nこのオブジェクトからキーと値を削除すると、次にそのモジュールが\n<code>require</code> されたときにリロードされます。\n\n</p>\n"
            },
            {
              "textRaw": "`extensions` {Object} ",
              "name": "extensions",
              "stability": 0,
              "stabilityText": "Deprecated",
              "desc": "<!--\nInstruct `require` on how to handle certain file extensions.\n\nProcess files with the extension `.sjs` as `.js`:\n-->\n\n<p><code>require</code> にファイル拡張子を扱う方法を教えます。\n\n</p>\n<p>拡張子が <code>.sjs</code> であるファイルの処理を <code>.js</code> と同じにするには:\n\n</p>\n<pre><code>require.extensions['.sjs'] = require.extensions['.js'];</code></pre>\n<!--\n**Deprecated**  In the past, this list has been used to load\nnon-JavaScript modules into Node by compiling them on-demand.\nHowever, in practice, there are much better ways to do this, such as\nloading modules via some other Node program, or compiling them to\nJavaScript ahead of time.\n-->\n\n<p><strong>廃止予定</strong> かつて、このリストは非 JavaScript モジュールを必要に応じて\nコンパイルし、Node にロードするために使われていました。\nしかし実際には、他の Node プログラムを通じてロードしたり、\n事前に JavaScript にコンパイルするなど、よりよい方法があります。\n\n</p>\n<!--\nSince the Module system is locked, this feature will probably never go\naway.  However, it may have subtle bugs and complexities that are best\nleft untouched.\n-->\n\n<p>モジュールシステムはロックされているので、この機能はおそらく\n無くならないでしょう。\nしかしながら、それは微妙なバグや複雑さがあってもそのまま放置されるでしょう。\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "__filename",
          "name": "__filename",
          "type": "var",
          "desc": "<!--\nThe filename of the code being executed.  This is the resolved absolute path\nof this code file.  For a main program this is not necessarily the same\nfilename used in the command line.  The value inside a module is the path\nto that module file.\n-->\n\n<p>実行されているコードのファイル名です。これは解決された絶対パスです。\nメインプログラムでは、必ずしもコマンドライン引数で使われたファイル名と\n同じではありません。\nモジュールの中では、この値はそのモジュールファイルのパスとなります。\n\n</p>\n<!--\nExample: running `node example.js` from `/Users/mjr`\n-->\n\n<p>例: <code>node example.js</code> を <code>/Users/mjr</code> で実行する\n\n</p>\n<pre><code>console.log(__filename);\n// /Users/mjr/example.js</code></pre>\n<!--\n`__filename` isn't actually a global but rather local to each module.\n-->\n\n<p><code>__filename</code> は実際はグローバルではなく、各モジュール毎のローカルです。\n\n</p>\n"
        },
        {
          "textRaw": "__dirname",
          "name": "__dirname",
          "type": "var",
          "desc": "<!--\nThe name of the directory that the currently executing script resides in.\n-->\n\n<p>現在実行されているスクリプトが存在するディレクトリの名前です。\n\n</p>\n<!--\nExample: running `node example.js` from `/Users/mjr`\n-->\n\n<p>例: <code>node example.js</code> を <code>/Users/mjr</code> で実行する\n\n</p>\n<pre><code>console.log(__dirname);\n// /Users/mjr</code></pre>\n<!--\n`__dirname` isn't actually a global but rather local to each module.\n-->\n\n<p><code>__dirname</code> は実際はグローバルではなく、各モジュール毎のローカルです。\n\n\n</p>\n"
        },
        {
          "textRaw": "module",
          "name": "module",
          "type": "var",
          "desc": "<!--\nA reference to the current module. In particular\n`module.exports` is used for defining what a module exports and makes\navailable through `require()`.\n-->\n\n<p>現在のモジュールへの参照です。\n<code>module.exports</code> は、モジュールが公開して <code>require()</code> を通じて利用可能になる\nものを定めるために使われます。\n\n</p>\n<!--\n`module` isn't actually a global but rather local to each module.\n-->\n\n<p><code>module</code> は実際はグローバルではなく、各モジュール毎のローカルです。\n\n</p>\n<!--\nSee the [module system documentation][] for more information.\n-->\n\n<p>より詳しくは [モジュールシステムのドキュメント][] を参照してください。\n\n</p>\n"
        },
        {
          "textRaw": "exports",
          "name": "exports",
          "type": "var",
          "desc": "<!--\nA reference to the `module.exports` that is shorter to type.\nSee [module system documentation][] for details on when to use `exports` and\nwhen to use `module.exports`.\n-->\n\n<p><code>module.exports</code> への参照です。\nいつ <code>exports</code> を使い、いつ <code>module.exports</code> を使うかの詳細は\n[モジュールシステムのドキュメント][] を参照してください。\n\n</p>\n<!--\n`exports` isn't actually a global but rather local to each module.\n-->\n\n<p><code>exports</code> は実際はグローバルではなく、各モジュール毎のローカルです。\n\n</p>\n<!--\nSee the [module system documentation][] for more information.\n\nSee the [module section][] for more information.\n-->\n\n<p>より詳しくは [モジュール][] を参照してください。\n\n</p>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "setTimeout(cb, ms)",
          "type": "method",
          "name": "setTimeout",
          "desc": "<!--\nRun callback `cb` after *at least* `ms` milliseconds. The actual delay depends\non external factors like OS timer granularity and system load.\n-->\n\n<p><em>少なくとも</em> <code>ms</code> ミリ秒が経過した後、コールバック <code>cb</code> を実行します。\n実際の遅延は OS のタイマ分解能やシステムの負荷など外部要因に依存します。\n\n</p>\n<!--\nThe timeout must be in the range of 1-2,147,483,647 inclusive. If the value is\noutside that range, it's changed to 1 millisecond. Broadly speaking, a timer\ncannot span more than 24.8 days.\n-->\n\n<p>タイムアウト値は 1～2,147,483,647 の範囲内でなければなりません。\nもし値がこの範囲外だった場合は 1 ミリ秒となります。\n大雑把に言って、タイマは 24.8 日を越えることはできません。\n\n</p>\n<!--\nReturns an opaque value that represents the timer.\n-->\n\n<p>タイマを表現する不透明な値を返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "cb"
                },
                {
                  "name": "ms"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "clearTimeout(t)",
          "type": "method",
          "name": "clearTimeout",
          "desc": "<!--\nStop a timer that was previously created with `setTimeout()`. The callback will\nnot execute.\n-->\n\n<p><code>setTimeout()</code> によって以前に作成されたタイマを終了します。\nコールバックは実行されなくなります。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "t"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "setInterval(cb, ms)",
          "type": "method",
          "name": "setInterval",
          "desc": "<!--\nRun callback `cb` repeatedly every `ms` milliseconds. Note that the actual\ninterval may vary, depending on external factors like OS timer granularity and\nsystem load. It's never less than `ms` but it may be longer.\n-->\n\n<p><code>ms</code> ミリ秒ごとにコールバック <code>cb</code> を繰り返し実行します。\nOS のタイマ分解能やシステムの負荷など外部要因によって、\n実際のインターバルが異なるかもしれないことに注意してください。\nそれは決して <code>ms</code> より短いことはありませんが、より長いことがあります。\n\n</p>\n<!--\nThe interval must be in the range of 1-2,147,483,647 inclusive. If the value is\noutside that range, it's changed to 1 millisecond. Broadly speaking, a timer\ncannot span more than 24.8 days.\n-->\n\n<p>インターバル値は 1～2,147,483,647 の範囲内でなければなりません。\nもし値がこの範囲外だった場合は 1 ミリ秒となります。\n大雑把に言って、タイマは 24.8 日を越えることはできません。\n\n</p>\n<!--\nReturns an opaque value that represents the timer.\n-->\n\n<p>タイマを表現する不透明な値を返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "cb"
                },
                {
                  "name": "ms"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "textRaw": "Debugger",
      "name": "Debugger",
      "stability": 3,
      "stabilityText": "Stable",
      "type": "misc",
      "desc": "<!--\nV8 comes with an extensive debugger which is accessible out-of-process via a\nsimple [TCP protocol](http://code.google.com/p/v8/wiki/DebuggerProtocol).\nNode has a built-in client for this debugger. To use this, start Node with the\n`debug` argument; a prompt will appear:\n-->\n\n<p>V8は外部プロセスから <a href="\"http://code.google.com/p/v8/wiki/DebuggerProtocol\"">TCP プロトコル</a>経由で接続可能なデバッガを備えています。\nNode にはこのデバッガへのクライアントが組み込まれています。\nこれを使うには、 <code>debug</code> 引数を指定して Node を起動します。\n次のようになります:\n\n</p>\n<pre><code>% node debug myscript.js\n< debugger listening on port 5858\nconnecting... ok\nbreak in /home/indutny/Code/git/indutny/myscript.js:1\n  1 x = 5;\n  2 setTimeout(function () {\n  3   debugger;\ndebug></code></pre>\n<!--\nNode's debugger client doesn't support the full range of commands, but\nsimple step and inspection is possible. By putting the statement `debugger;`\ninto the source code of your script, you will enable a breakpoint.\n-->\n\n<p>Node のデバッガクライアントはあらゆるコマンドを完全にサポートしているわけではありませんが、\n単純なステップ実行やインスペクションが可能です。\nスクリプトのソースコードに <code>debugger;</code> 文を挿入すると、\nブレークポイントが有効になります。\n\n</p>\n<!--\nFor example, suppose `myscript.js` looked like this:\n-->\n\n<p>例えば、<code>myscript.js</code> が次のようだとします:\n\n</p>\n<pre><code>// myscript.js\nx = 5;\nsetTimeout(function () {\n  debugger;\n  console.log("world");\n}, 1000);\nconsole.log("hello");</code></pre>\n<!--\nThen once the debugger is run, it will break on line 4.\n-->\n\n<p>ひとたびデバッガを実行すると、4行目で中断します。\n\n</p>\n<pre><code>% node debug myscript.js\n< debugger listening on port 5858\nconnecting... ok\nbreak in /home/indutny/Code/git/indutny/myscript.js:1\n  1 x = 5;\n  2 setTimeout(function () {\n  3   debugger;\ndebug> cont\n< hello\nbreak in /home/indutny/Code/git/indutny/myscript.js:3\n  1 x = 5;\n  2 setTimeout(function () {\n  3   debugger;\n  4   console.log("world");\n  5 }, 1000);\ndebug> next\nbreak in /home/indutny/Code/git/indutny/myscript.js:4\n  2 setTimeout(function () {\n  3   debugger;\n  4   console.log("world");\n  5 }, 1000);\n  6 console.log("hello");\ndebug> repl\nPress Ctrl + C to leave debug repl\n> x\n5\n> 2+2\n4\ndebug> next\n< world\nbreak in /home/indutny/Code/git/indutny/myscript.js:5\n  3   debugger;\n  4   console.log("world");\n  5 }, 1000);\n  6 console.log("hello");\n  7\ndebug> quit\n%</code></pre>\n<!--\nThe `repl` command allows you to evaluate code remotely. The `next` command\nsteps over to the next line. There are a few other commands available and more\nto come. Type `help` to see others.\n-->\n\n<p><code>repl</code> コマンドはコードをリモートで評価します。\n<code>next</code> コマンドは次の行にステップオーバーします。\n他にもいくつかのコマンドを利用することができます。\nその他については <code>help</code> をタイプしてください。\n\n</p>\n",
      "miscs": [
        {
          "textRaw": "Watchers",
          "name": "watchers",
          "desc": "<!--\nYou can watch expression and variable values while debugging your code.\nOn every breakpoint each expression from the watchers list will be evaluated\nin the current context and displayed just before the breakpoint's source code\nlisting.\n-->\n\n<p>デバッグ中に式や変数の値をウォッチすることができます。\n全てのブレークポイントにおいて、ウォッチリストのそれぞれの式は\n現在のコンテキストで評価され、ブレークポイントのソースコードの前に\n表示されます。\n\n</p>\n<!--\nTo start watching an expression, type `watch(\"my_expression\")`. `watchers`\nprints the active watchers. To remove a watcher, type\n`unwatch(\"my_expression\")`.\n-->\n\n<p>式のウォッチを開始するには、<code>watch("my_expression")</code> をタイプします。\n<code>watchers</code> はアクティブなウォッチの一覧を表示します。\nウォッチを解除するには、<code>unwatch("my_expression")</code> とタイプします。\n\n</p>\n",
          "type": "misc",
          "displayName": "Watchers"
        },
        {
          "textRaw": "Commands reference",
          "name": "commands_reference",
          "modules": [
            {
              "textRaw": "Stepping",
              "name": "stepping",
              "desc": "<!--\n* `cont`, `c` - Continue execution\n* `next`, `n` - Step next\n* `step`, `s` - Step in\n* `out`, `o` - Step out\n* `pause` - Pause running code (like pause button in Developer Tools)\n-->\n\n<ul>\n<li><code>cont</code>, <code>c</code> - 実行を継続します。</li>\n<li><code>next</code>, <code>n</code> - 次の行へステップオーバーします。</li>\n<li><code>step</code>, <code>s</code> - ステップインします。</li>\n<li><code>out</code>, <code>o</code> - ステップアウトします。</li>\n<li><code>pause</code> - コードの実行を中断します (Developer Tools の pause\nボタンと同じです。</li>\n</ul>\n",
              "type": "module",
              "displayName": "Stepping"
            },
            {
              "textRaw": "Breakpoints",
              "name": "breakpoints",
              "desc": "<!--\n* `setBreakpoint()`, `sb()` - Set breakpoint on current line\n* `setBreakpoint(line)`, `sb(line)` - Set breakpoint on specific line\n* `setBreakpoint('fn()')`, `sb(...)` - Set breakpoint on a first statement in\nfunctions body\n* `setBreakpoint('script.js', 1)`, `sb(...)` - Set breakpoint on first line of\nscript.js\n* `clearBreakpoint`, `cb(...)` - Clear breakpoint\n-->\n\n<ul>\n<li><code>setBreakpoint()</code>, <code>sb()</code> - 現在行にブレークポイントを設定します。</li>\n<li><code>setBreakpoint(line)</code>, <code>sb(line)</code> - 指定した行にブレークポイントを設定します。</li>\n<li><code>setBreakpoint('fn()')</code>, <code>sb(...)</code> - 指定した関数の先頭行にブレークポイントを設定します</li>\n<li><code>setBreakpoint('script.js', 1)</code>, <code>sb(...)</code> - 指定したスクリプトファイルの指定した行にブレークポイントを設定します。</li>\n<li><code>clearBreakpoint</code>, <code>cb(...)</code> - ブレークポイントを削除します。</li>\n</ul>\n<!--\nIt is also possible to set a breakpoint in a file (module) that\nisn't loaded yet:\n-->\n\n<p>まだロードされていないファイル (モジュール) にブレークポイントを\n設定することもできます。\n\n</p>\n<pre><code>% ./node debug test/fixtures/break-in-module/main.js\n< debugger listening on port 5858\nconnecting to port 5858... ok\nbreak in test/fixtures/break-in-module/main.js:1\n  1 var mod = require('./mod.js');\n  2 mod.hello();\n  3 mod.hello();\ndebug> setBreakpoint('mod.js', 23)\nWarning: script 'mod.js' was not loaded yet.\n  1 var mod = require('./mod.js');\n  2 mod.hello();\n  3 mod.hello();\ndebug> c\nbreak in test/fixtures/break-in-module/mod.js:23\n 21\n 22 exports.hello = function() {\n 23   return 'hello from module';\n 24 };\n 25\ndebug></code></pre>\n",
              "type": "module",
              "displayName": "Breakpoints"
            },
            {
              "textRaw": "Info",
              "name": "info",
              "desc": "<!--\n* `backtrace`, `bt` - Print backtrace of current execution frame\n* `list(5)` - List scripts source code with 5 line context (5 lines before and\nafter)\n* `watch(expr)` - Add expression to watch list\n* `unwatch(expr)` - Remove expression from watch list\n* `watchers` - List all watchers and their values (automatically listed on each\nbreakpoint)\n* `repl` - Open debugger's repl for evaluation in debugging script's context\n-->\n\n<ul>\n<li><code>backtrace</code>, <code>bt</code> - 現在の実行フレームのバックトレースを表示します。</li>\n<li><code>list(5)</code> - 現在の行の前後のソースコードを表示します (例では前後とも 5 行が表示されます)。</li>\n<li><code>watch(expr)</code> - 式をウォッチリストに追加します。</li>\n<li><code>unwatch(expr)</code> - 式をウォッチリストから削除します。</li>\n<li><code>watchers</code> - ウォッチしている全ての式とその値を表示します (各ブレークポイントで自動的に表示されます)。</li>\n<li><code>repl</code> - デバッグしているスクリプトをコンテキストとする REPL を開きます。</li>\n</ul>\n",
              "type": "module",
              "displayName": "Info"
            },
            {
              "textRaw": "Execution control",
              "name": "execution_control",
              "desc": "<!--\n* `run` - Run script (automatically runs on debugger's start)\n* `restart` - Restart script\n* `kill` - Kill script\n-->\n\n<ul>\n<li><code>run</code> - スクリプトを実行します (デバッガを開始すると自動的に実行します)。</li>\n<li><code>restart</code> - スクリプトを再実行します。</li>\n<li><code>kill</code> - スクリプトを終了します。</li>\n</ul>\n",
              "type": "module",
              "displayName": "Execution control"
            },
            {
              "textRaw": "Various",
              "name": "various",
              "desc": "<!--\n* `scripts` - List all loaded scripts\n* `version` - Display v8's version\n-->\n\n<ul>\n<li><code>scripts</code> - ロードされている全スクリプトの一覧を表示します。</li>\n<li><code>version</code> - v8 のバージョンを表示します。</li>\n</ul>\n",
              "type": "module",
              "displayName": "Various"
            }
          ],
          "type": "misc",
          "displayName": "Commands reference"
        },
        {
          "textRaw": "Advanced Usage",
          "name": "advanced_usage",
          "desc": "<!--\nThe V8 debugger can be enabled and accessed either by starting Node with\nthe `--debug` command-line flag or by signaling an existing Node process\nwith `SIGUSR1`.\n-->\n\n<p>V8 デバッガは Node をコマンドラインの <code>--debug</code> フラグで起動したり、起動済みの Node プロセスに <code>SIGUSR1</code> シグナルを送ることでも有効にできます。\n\n</p>\n<!--\nOnce a process has been set in debug mode with this it can be connected to\nwith the node debugger. Either connect to the `pid` or the URI to the debugger.\nThe syntax is:\n-->\n\n<p>これによって一度デバッグモードに設定されたプロセスは、\n<code>pid</code> または URI のどちらでも node デバッガに接続することができます。\n形式は:\n\n</p>\n<!--\n* `node debug -p <pid>` - Connects to the process via the `pid`\n* `node debug <URI>` - Connects to the process via the URI such as localhost:5858\n-->\n\n<ul>\n<li><code>node debug -p <pid></code> - <code>pid</code> を通じてプロセスに接続</li>\n<li><code>node debug <URI> - </code>localhost:585` のような URI を通じてプロセスに接続</li>\n</ul>\n",
          "type": "misc",
          "displayName": "Advanced Usage"
        }
      ]
    }
  ],
  "globals": [
    {
      "textRaw": "global",
      "name": "global",
      "type": "global",
      "desc": "<!--\n* {Object} The global namespace object.\n-->\n\n<ul>\n<li>{Object} グローバルなネームスペースのオブジェクト</li>\n</ul>\n<!--\nIn browsers, the top-level scope is the global scope. That means that in\nbrowsers if you're in the global scope `var something` will define a global\nvariable. In Node this is different. The top-level scope is not the global\nscope; `var something` inside a Node module will be local to that module.\n-->\n\n<p>ブラウザでは、トップレベルのスコープはグローバルスコープです。\nこれは、ブラウザではグローバルスコープで <code>var something</code> と定義するとグローバル変数になることを意味します。\nNode では異なります。\nトップレベルのスコープはグローバルスコープではありません;\nNode のモジュール内での <code>var something</code> はそのモジュールでローカルになります。\n\n</p>\n"
    },
    {
      "textRaw": "process",
      "name": "process",
      "type": "global",
      "desc": "<!--\nThe process object. See the [process object][] section.\n-->\n\n<p>プロセスオブジェクトです。[process オブジェクト][] の節を参照してください。\n\n</p>\n"
    },
    {
      "textRaw": "console",
      "name": "console",
      "type": "global",
      "desc": "<!--\nUsed to print to stdout and stderr. See the [console][] section.\n-->\n\n<p>標準出力および標準エラー出力へのプリントに使われます。\n[コンソール][] を参照してください。\n\n</p>\n"
    },
    {
      "textRaw": "Class: Buffer",
      "type": "global",
      "name": "Buffer",
      "desc": "<!--\nUsed to handle binary data. See the [buffer section][]\n-->\n\n<p>バイナリデータを扱うために使われます。\n[バッファセクション][] を参照してください。\n\n</p>\n"
    },
    {
      "textRaw": "clearInterval(t)",
      "type": "global",
      "name": "clearInterval",
      "desc": "<!--\nStop a timer that was previously created with `setInterval()`. The callback\nwill not execute.\n-->\n\n<p><code>setInterval()</code> によって以前に作成されたタイマを終了します。\nコールバックは実行されなくなります。\n\n</p>\n<!--\nThe timer functions are global variables. See the [timers][] section.\n-->\n\n<p>タイマー関数はグローバル変数です。[タイマー][] を参照してください。\n\n</p>\n<!--\n[buffer section]: buffer.html\n[module section]: modules.html\n[module system documentation]: modules.html\n[Modules]: modules.html#modules_modules\n[process object]: process.html#process_process\n[console]: console.html\n[timers]: timers.html\n-->\n\n"
    },
    {
      "textRaw": "console",
      "name": "console",
      "stability": 4,
      "stabilityText": "API Frozen",
      "type": "global",
      "desc": "<!--\nFor printing to stdout and stderr.  Similar to the console object functions\nprovided by most web browsers, here the output is sent to stdout or stderr.\n-->\n\n<p>標準出力と標準エラーに出力するためのものです。\nほとんどのブラウザで提供されているコンソールオブジェクトと同様ですが、\n出力は標準出力か標準エラー出力に送られます。\n\n</p>\n<!--\nThe console functions are synchronous when the destination is a terminal or\na file (to avoid lost messages in case of premature exit) and asynchronous\nwhen it's a pipe (to avoid blocking for long periods of time).\n-->\n\n<p>コンソール関数は出力先がターミナルまたはファイルの場合は同期\n(早すぎる終了によりメッセージが失われるケースを防ぐため)、\nパイプの場合は非同期 (長時間ブロックすることを防ぐため) です。\n\n</p>\n<!--\nThat is, in the following example, stdout is non-blocking while stderr\nis blocking:\n-->\n\n<p>つまり、以下の例では標準出力はノンブロッキングですが、\n標準エラー出力はブロッキングです:\n\n</p>\n<pre><code>$ node script.js 2> error.log | tee info.log</code></pre>\n<!--\nIn daily use, the blocking/non-blocking dichotomy is not something you\nshould worry about unless you log huge amounts of data.\n-->\n\n<p>通常の使用では、膨大な量のデータを記録するのではない限り、\nブロッキング／ノンブロッキングのどちらなのかを心配する必要はありません。\n\n\n</p>\n",
      "methods": [
        {
          "textRaw": "console.log([data], [...])",
          "type": "method",
          "name": "log",
          "desc": "<!--\nPrints to stdout with newline. This function can take multiple arguments in a\n`printf()`-like way. Example:\n-->\n\n<p>改行を伴って標準出力へプリントします。\nこの関数は <code>printf()</code> のように複数の引数を受け付けます。\n\n</p>\n<pre><code>console.log('count: %d', count);</code></pre>\n<!--\nIf formatting elements are not found in the first string then `util.inspect`\nis used on each argument.  See [util.format()][] for more information.\n-->\n\n<p>最初の引数文字列からフォーマット要素が見つからなかった場合は、\n<code>util.inspect</code> が各引数に使われます。\nより詳細は [util.format()][] を参照してください。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "data",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "console.info([data], [...])",
          "type": "method",
          "name": "info",
          "desc": "<!--\nSame as `console.log`.\n-->\n\n<p><code>console.log</code> と同じです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "data",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "console.error([data], [...])",
          "type": "method",
          "name": "error",
          "desc": "<!--\nSame as `console.log` but prints to stderr.\n-->\n\n<p><code>console.log</code> と同様ですが、標準エラー出力にプリントします。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "data",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "console.warn([data], [...])",
          "type": "method",
          "name": "warn",
          "desc": "<!--\nSame as `console.error`.\n-->\n\n<p><code>console.error()</code> と同じです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "data",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "console.dir(obj)",
          "type": "method",
          "name": "dir",
          "desc": "<!--\nUses `util.inspect` on `obj` and prints resulting string to stdout.\n-->\n\n<p><code>util.inspect</code> を使って <code>obj</code> を文字列化した結果を標準出力にプリントします。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "obj"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "console.time(label)",
          "type": "method",
          "name": "time",
          "desc": "<!--\nMark a time.\n-->\n\n<p>タイマを作成します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "label"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "console.timeEnd(label)",
          "type": "method",
          "name": "timeEnd",
          "desc": "<!--\nFinish timer, record output. Example:\n-->\n\n<p>タイマを終了し、結果を出力します。例:\n\n</p>\n<pre><code>console.time('100-elements');\nfor (var i = 0; i < 100; i++) {\n  ;\n}\nconsole.timeEnd('100-elements');</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "label"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "console.trace(label)",
          "type": "method",
          "name": "trace",
          "desc": "<!--\nPrint a stack trace to stderr of the current position.\n-->\n\n<p>現在のスタックトレースを標準エラー出力にプリントします。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "label"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "console.assert(expression, [message])",
          "type": "method",
          "name": "assert",
          "desc": "<!--\nSame as [assert.ok()][] where if the `expression` evaluates as `false` throw an\nAssertionError with `message`.\n-->\n\n<p>[assert.ok()][] と同様に、もし <code>expression</code> が <code>false</code> に評価されると、\n<code>message</code> を持つ AssertionError がスローされます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "expression"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "textRaw": "process",
      "name": "process",
      "type": "global",
      "desc": "<!--\nThe `process` object is a global object and can be accessed from anywhere.\nIt is an instance of [EventEmitter][].\n-->\n\n<p><code>process</code> はグローバルオブジェクトで、どこからでもアクセスすることができます。\nそれは [EventEmitter][] のインスタンスです。\n\n\n</p>\n",
      "events": [
        {
          "textRaw": "Event: 'exit'",
          "type": "event",
          "name": "exit",
          "desc": "<!--\nEmitted when the process is about to exit. There is no way to prevent the\nexiting of the event loop at this point, and once all `exit` listeners have\nfinished running the process will exit. Therefore you **must** only perform\n**synchronous** operations in this handler. This is a good hook to perform\nchecks on the module's state (like for unit tests). The callback takes one\nargument, the code the process is exiting with.\n-->\n\n<p>プロセスが終了しようとしている時に生成されます。\nこの位置からイベントループを抜けることを防ぐ方法はなく、全ての <code>'exit'</code>\nリスナーの実行が完了すると、プロセスは終了します。\n従って、このハンドラでできることは <strong>同期</strong> 操作 <strong>だけ</strong> です。\nこれは (ユニットテストのように) モジュールの状態をチェックするのに適した\nフックとなります。\nコールバックはプロセスの終了コードを唯一の引数として呼び出されます。\n\n</p>\n<!--\nExample of listening for `exit`:\n-->\n\n<p><code>exit</code> を監視する例:\n\n</p>\n<pre><code>process.on('exit', function(code) {\n  // do *NOT* do this\n  setTimeout(function() {\n    console.log('This will not run');\n  }, 0);\n  console.log('About to exit with code:', code);\n});</code></pre>\n",
          "params": []
        },
        {
          "textRaw": "Event: 'uncaughtException'",
          "type": "event",
          "name": "uncaughtException",
          "desc": "<!--\nEmitted when an exception bubbles all the way back to the event loop. If a\nlistener is added for this exception, the default action (which is to print\na stack trace and exit) will not occur.\n-->\n\n<p>発生した例外がイベントループまでたどり着いた場合に生成されます。\nもしこの例外に対するリスナーが加えられていれば、\nデフォルトの動作 (それはスタックトレースをプリントして終了します) は起こりません。\n\n</p>\n<!--\nExample of listening for `uncaughtException`:\n-->\n\n<p><code>uncaughtException</code> を監視する例:\n\n</p>\n<pre><code>process.on('uncaughtException', function(err) {\n  console.log('Caught exception: ' + err);\n});\n\nsetTimeout(function() {\n  console.log('This will still run.');\n}, 500);\n\n// Intentionally cause an exception, but don't catch it.\nnonexistentFunc();\nconsole.log('This will not run.');</code></pre>\n<!--\nNote that `uncaughtException` is a very crude mechanism for exception\nhandling and may be removed in the future.\n-->\n\n<p><code>uncaughtException</code> は例外を扱うとても荒削りなメカニズムであり、\n将来削除されるかもしれないことに注意してください。\n\n</p>\n<!--\nDon't use it, use [domains](domain.html) instead. If you do use it, restart\nyour application after every unhandled exception!\n-->\n\n<p>これを使う代わりに、<a href="\"domain.html\"">ドメイン</a> を使ってください。\nそれを使えば、捕まえられない例外が発生した後でもアプリケーションを\n再開することができます！\n\n</p>\n<!--\nDo *not* use it as the node.js equivalent of `On Error Resume Next`. An\nunhandled exception means your application - and by extension node.js itself -\nis in an undefined state. Blindly resuming means *anything* could happen.\n-->\n\n<p>これを Node.js における <code>On Error Resume Next</code> として <em>使わないで</em> ください。\n捕まえられなかった例外は、アプリケーション\n- および Node.js 自身の拡張 - が未定義の状態となることを意味します。\nやみくもな再開は <em>どんなことでも</em> 起こることを意味します。\n\n</p>\n<!--\nThink of resuming as pulling the power cord when you are upgrading your system.\nNine out of ten times nothing happens - but the 10th time, your system is bust.\n-->\n\n<p>電源を引き抜きながらアプリケーションをアップグレードすることを\n想像してください。\n10 回中 9 回は何も起こりません\n- しかし 10 回目にはそのシステムは使えなくなるかもしれません。\n\n</p>\n<!--\nYou have been warned.\n-->\n\n<p>これは警告です。\n\n</p>\n",
          "params": []
        },
        {
          "textRaw": "Signal Events",
          "name": "SIGINT, SIGHUP, etc.",
          "type": "event",
          "desc": "<!--\nEmitted when the processes receives a signal. See sigaction(2) for a list of\nstandard POSIX signal names such as SIGINT, SIGHUP, etc.\n-->\n\n<p>プロセスがシグナルを受信した場合に生成されます。\nSIGINT、SIGHUP、その他の POSIX 標準シグナル名の一覧について は sigaction(2) を参照してください。\n\n</p>\n<!--\nExample of listening for `SIGINT`:\n-->\n\n<p><code>SIGINT</code>を監視する例:\n\n</p>\n<pre><code>// Start reading from stdin so we don't exit.\nprocess.stdin.resume();\n\nprocess.on('SIGINT', function() {\n  console.log('Got SIGINT.  Press Control-D to exit.');\n});</code></pre>\n<!--\nAn easy way to send the `SIGINT` signal is with `Control-C` in most terminal\nprograms.\n-->\n\n<p>多くの端末プログラムで簡単に <code>SIGINT</code> を送る方法は <code>Control-C</code> を押すことです。\n\n</p>\n<!--\nNote:\n-->\n\n<p>注意:\n\n</p>\n<!--\n- `SIGUSR1` is reserved by node.js to start the debugger.  It's possible to\n  install a listener but that won't stop the debugger from starting.\n- `SIGTERM` and `SIGINT` have default handlers on non-Windows platforms that resets\n  the terminal mode before exiting with code `128 + signal number`. If one of\n  these signals has a listener installed, its default behaviour will be removed\n  (node will no longer exit).\n- `SIGPIPE` is ignored by default, it can have a listener installed.\n- `SIGHUP` is generated on Windows when the console window is closed, and on other\n  platforms under various similar conditions, see signal(7). It can have a\n  listener installed, however node will be unconditionally terminated by Windows\n  about 10 seconds later. On non-Windows platforms, the default behaviour of\n  `SIGHUP` is to terminate node, but once a listener has been installed its\n  default behaviour will be removed.\n- `SIGTERM` is not supported on Windows, it can be listened on.\n- `SIGINT` from the terminal is supported on all platforms, and can usually be\n  generated with `CTRL+C` (though this may be configurable). It is not generated\n  when terminal raw mode is enabled.\n- `SIGBREAK` is delivered on Windows when `CTRL+BREAK` is pressed, on non-Windows\n  platforms it can be listened on, but there is no way to send or generate it.\n- `SIGWINCH` is delivered when the console has been resized. On Windows, this will\n  only happen on write to the console when the cursor is being moved, or when a\n  readable tty is used in raw mode.\n- `SIGKILL` cannot have a listener installed, it will unconditionally terminate\n  node on all platforms.\n- `SIGSTOP` cannot have a listener installed.\n-->\n\n<ul>\n<li><code>SIGUSR1</code> は Node.js がデバッガを起動するために予約されています。\nリスナを登録することは出来ますが、デバッガの起動を止めることは出来ません。</li>\n<li><code>SIGTERM</code> および <code>SIGINT</code> は、Windows 以外のプラットフォームでは\n<code>128</code> + シグナル番号で終了する前にターミナルのモードをリセットする\nデフォルトのハンドラを持ちます。\nこれらのシグナルのどちらかにリスナが登録されると、デフォルトの振る舞いは\n削除されます (node は終了しなくなります)。</li>\n<li><code>SIGPIPE</code> はデフォルトでは無視され、リスナを登録することが出来ます。</li>\n<li><code>SIGHUP</code> は Windows ではコンソールウィンドウが閉じられると発生します。\n他のプラットフォームでも同様の条件で発生します。詳細は signal(7)\nを参照してください。\nリスナを登録することは出来ますが、Windows では約 10 秒後に node は無条件に\nWindows によって終了されます。\nWindows 以外のプラットフォームでは、<code>SIGHUP</code> のデフォルトの振る舞いは\nnodeを終了することですが、リスナを登録するとデフォルトの振る舞いは\n削除されます。</li>\n<li><code>SIGTERM</code> は Windows ではサポートされません。\nしかし、リスナを登録することは可能です。</li>\n<li>端末からの <code>SIGINT</code> は全てのプラットフォームでサポートされ、通常 <code>CTRL+C</code>\n(おそらく設定可能でしょう) によって生成されます。\nターミナルが raw モードの場合は生成されません。</li>\n<li><code>SIGBREAK</code> は Windows において <code>CTRL+BREAK</code> が推された時に送られます。\nWindows 以外のプラットフォームでもリスナを登録することは出来ますが、\nそれを生成したり送信する方法はありません。</li>\n<li><code>SIGWINCH</code> はコンソールのサイズが変更された場合に送られます。\nWindows では、カーソルが移動するか、tty が raw モードの場合に、\nコンソールへ書き込むと発生します。</li>\n<li><code>SIGKILL</code> のリスナを組み込むことは出来ません。\nそれは全てのプラットフォームで node を無条件に終了します。</li>\n<li><code>SIGSTOP</code> のリスナを組み込むことは出来ません。</li>\n</ul>\n<!--\nNote that Windows does not support sending Signals, but node offers some\nemulation with `process.kill()`, and `child_process.kill()`:\n- Sending signal `0` can be used to search for the existence of a process\n- Sending `SIGINT`, `SIGTERM`, and `SIGKILL` cause the unconditional exit of the\n  target process.\n-->\n\n<p>Windows はシグナルの送信をサポートしていませんが、nodeは<code>process.kill()</code> や\n<code>child_process.kill()</code> をエミュレートする方法を提供します:\n\n</p>\n<ul>\n<li>シグナル <code>0</code> は既存のプロセスを検索するためのものです。</li>\n<li><code>SIGINT</code>、<code>SIGTERM</code>、そして <code>SIGKILL</code> は、ターゲットのプロセスが無条件に\n終了する原因となります。</li>\n</ul>\n",
          "params": []
        }
      ],
      "properties": [
        {
          "textRaw": "process.stdout",
          "name": "stdout",
          "desc": "<!--\nA `Writable Stream` to `stdout`.\n-->\n\n<p><code>stdout</code> に対する <code>Writable Stream</code> です。\n\n</p>\n<!--\nExample: the definition of `console.log`\n-->\n\n<p>例: <code>console.log</code> の定義\n\n</p>\n<pre><code>console.log = function(d) {\n  process.stdout.write(d + '\\n');\n};</code></pre>\n<!--\n`process.stderr` and `process.stdout` are unlike other streams in Node in\nthat writes to them are usually blocking.\n-->\n\n<p><code>process.stderr</code> と <code>process.stdout</code> は Node の他のストリームと異なり、\nそれらへの書き込みは通常ブロックします。\n\n</p>\n<!--\n- They are blocking in the case that they refer to regular files or TTY file\n  descriptors.\n- In the case they refer to pipes:\n  - They are blocking in Linux/Unix.\n  - They are non-blocking like other streams in Windows.\n-->\n\n<ul>\n<li>ファイル記述子が通常ファイルや TTY を参照しているケースでは、\nそれらはブロックします。</li>\n<li>パイプを参照しているケースでは:<ul>\n<li>Linux/Unix ではそれらはブロックします。</li>\n<li>Windows では他のストリームと同様にブロックしません。</li>\n</ul>\n</li>\n</ul>\n<!--\nTo check if Node is being run in a TTY context, read the `isTTY` property\non `process.stderr`, `process.stdout`, or `process.stdin`:\n-->\n\n<p>Node が TTY のコンテキストで実行されているかチェックするには、\n<code>process.stderr</code>, <code>process.stdout</code>, または <code>process.stdin</code> の\n<code>isTTY</code> プロパティを参照します。\n\n</p>\n<pre><code>$ node -p "Boolean(process.stdin.isTTY)"\ntrue\n$ echo "foo" | node -p "Boolean(process.stdin.isTTY)"\nfalse\n\n$ node -p "Boolean(process.stdout.isTTY)"\ntrue\n$ node -p "Boolean(process.stdout.isTTY)" | cat\nfalse</code></pre>\n<!--\nSee [the tty docs](tty.html#tty_tty) for more information.\n-->\n\n<p>より詳細は <a href="\"tty.html#tty_tty\"">the tty docs</a> を参照してください。\n\n</p>\n"
        },
        {
          "textRaw": "process.stderr",
          "name": "stderr",
          "desc": "<!--\nA writable stream to stderr.\n\n`process.stderr` and `process.stdout` are unlike other streams in Node in\nthat writes to them are usually blocking.\n-->\n\n<p><code>stderr</code> に対する <code>Writable Stream</code> です。\n\n</p>\n<p><code>process.stderr</code> と <code>process.stdout</code> は Node の他のストリームと異なり、\nそれらへの書き込みは通常ブロックします。\n\n</p>\n<!--\n- They are blocking in the case that they refer to regular files or TTY file\n  descriptors.\n- In the case they refer to pipes:\n  - They are blocking in Linux/Unix.\n  - They are non-blocking like other streams in Windows.\n-->\n\n<ul>\n<li>ファイル記述子が通常ファイルや TTY を参照しているケースでは、\nそれらはブロックします。</li>\n<li>パイプを参照しているケースでは:<ul>\n<li>Linux/Unix ではそれらはブロックします。</li>\n<li>Windows では他のストリームと同様にブロックしません。</li>\n</ul>\n</li>\n</ul>\n"
        },
        {
          "textRaw": "process.stdin",
          "name": "stdin",
          "desc": "<!--\nA `Readable Stream` for stdin. \n-->\n\n<p>標準入力に対する <code>Readable Stream</code> です。\n\n</p>\n<!--\nExample of opening standard input and listening for both events:\n-->\n\n<p>標準入力をオープンして二つのイベントを監視する例:\n\n</p>\n<pre><code>process.stdin.setEncoding('utf8');\n\nprocess.stdin.on('readable', function(chunk) {\n  var chunk = process.stdin.read();\n  if (chunk !== null) {\n    process.stdout.write('data: ' + chunk);\n  }\n});\n\nprocess.stdin.on('end', function() {\n  process.stdout.write('end');\n});</code></pre>\n<!--\nAs a Stream, `process.stdin` can also be used in \"old\" mode that is compatible\nwith scripts written for node prior v0.10.\nFor more information see\n[Stream compatibility](stream.html#stream_compatibility_with_older_node_versions).\n-->\n\n<p>ストリームであるため、<code>process.stdin</code> は v0.10 以前の node 向けに書かれた\nスクリプトと互換性のある "old" モードで使うことが出来ます。より詳細な情報は\n<a href="\"stream.html#stream_compatibility_with_older_node_versions\"">Stream compatibility</a>\nを参照してください。\n\n</p>\n<!--\nIn \"old\" Streams mode the stdin stream is paused by default, so one\nmust call `process.stdin.resume()` to read from it. Note also that calling\n`process.stdin.resume()` itself would switch stream to \"old\" mode.\n-->\n\n<p>"old" モードでは標準入力ストリームはデフォルトで中断状態のため、\n読み込みには <code>process.stdin.resume()</code> の呼び出しが必須です。\n<code>process.stdin.resume()</code> を呼び出すことにより、それ自体がストリームを\n"old" モードに切り替えることに注意してください。\n\n</p>\n<!--\nIf you are starting a new project you should prefer a more recent \"new\" Streams\nmode over \"old\" one.\n-->\n\n<p>もし新しいプロジェクトを始めるなら、"old" よりも\n"new" ストリームを好むべきです。\n\n</p>\n"
        },
        {
          "textRaw": "process.argv",
          "name": "argv",
          "desc": "<!--\nAn array containing the command line arguments.  The first element will be\n'node', the second element will be the name of the JavaScript file.  The\nnext elements will be any additional command line arguments.\n-->\n\n<p>コマンドライン引数を含む配列です。\n最初の要素は 'node'、2 番目の要素は JavaScript ファイルの名前になります。\nその後の要素はコマンドラインの追加の引数になります。\n\n</p>\n<pre><code>// print process.argv\nprocess.argv.forEach(function(val, index, array) {\n  console.log(index + ': ' + val);\n});</code></pre>\n<!--\nThis will generate:\n-->\n\n<p>このように出力されます:\n\n</p>\n<pre><code>$ node process-2.js one two=three four\n0: node\n1: /Users/mjr/work/node/process-2.js\n2: one\n3: two=three\n4: four</code></pre>\n"
        },
        {
          "textRaw": "process.execPath",
          "name": "execPath",
          "desc": "<!--\nThis is the absolute pathname of the executable that started the process.\n-->\n\n<p>プロセスによって開始された実行可能ファイルの絶対パスです。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>/usr/local/bin/node</code></pre>\n"
        },
        {
          "textRaw": "process.execArgv",
          "name": "execArgv",
          "desc": "<!--\nThis is the set of node-specific command line options from the\nexecutable that started the process.  These options do not show up in\n`process.argv`, and do not include the node executable, the name of\nthe script, or any options following the script name. These options\nare useful in order to spawn child processes with the same execution\nenvironment as the parent.\n-->\n\n<p>これはプロセス起動時に実行可能ファイルに与えられた node 固有の\nコマンドライン・オプション群です。\nそれらのオプションは <code>process.argv</code> には現れず、node の実行可能ファイルや\nスクリプト名、スクリプト名に続くどんなオプションも含まれません。\nこれらのオプションは親プロセスと同じ実行環境を持つ子プロセスを起動するために\n役に立ちます。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>$ node --harmony script.js --version</code></pre>\n<!--\nresults in process.execArgv:\n-->\n\n<p><code>process.execArgv</code> の結果:\n\n</p>\n<pre><code>['--harmony']</code></pre>\n<!--\nand process.argv:\n-->\n\n<p>そして <code>process.argv</code> の結果:\n\n</p>\n<pre><code>['/usr/local/bin/node', 'script.js', '--version']</code></pre>\n"
        },
        {
          "textRaw": "process.env",
          "name": "env",
          "desc": "<!--\nAn object containing the user environment. See environ(7).\n-->\n\n<p>ユーザの環境を含むオブジェクトです。environ(7) を参照してください。\n\n\n</p>\n"
        },
        {
          "textRaw": "process.version",
          "name": "version",
          "desc": "<!--\nA compiled-in property that exposes `NODE_VERSION`.\n-->\n\n<p><code>NODE_VERSION</code> を提示するコンパイル済みプロパティです。\n\n</p>\n<pre><code>console.log('Version: ' + process.version);</code></pre>\n"
        },
        {
          "textRaw": "process.versions",
          "name": "versions",
          "desc": "<!--\nA property exposing version strings of node and its dependencies.\n-->\n\n<p>node と依存ライブラリのバージョン文字列を提示します。\n\n</p>\n<pre><code>console.log(process.versions);</code></pre>\n<!--\nWill print something like:\n-->\n\n<p>は以下のように出力します。\n\n</p>\n<pre><code>{ http_parser: '1.0',\n  node: '0.10.4',\n  v8: '3.14.5.8',\n  ares: '1.9.0-DEV',\n  uv: '0.10.3',\n  zlib: '1.2.3',\n  modules: '11',\n  openssl: '1.0.1e' }</code></pre>\n"
        },
        {
          "textRaw": "process.config",
          "name": "config",
          "desc": "<!--\nAn Object containing the JavaScript representation of the configure options\nthat were used to compile the current node executable. This is the same as\nthe \"config.gypi\" file that was produced when running the `./configure` script.\n\nAn example of the possible output looks like:\n-->\n\n<p>現在のnode実行ファイルをコンパイルした際に使われた configure のオプションを\nJavaScript で表現したオブジェクトを保持します。\nこれは <code>./configure</code> スクリプトを実行した際に生成された "cofnig.gypi"\nファイルと同じです。\n\n</p>\n<p>実際の出力の例です:\n\n</p>\n<pre><code>{ target_defaults:\n   { cflags: [],\n     default_configuration: 'Release',\n     defines: [],\n     include_dirs: [],\n     libraries: [] },\n  variables:\n   { host_arch: 'x64',\n     node_install_npm: 'true',\n     node_prefix: '',\n     node_shared_cares: 'false',\n     node_shared_http_parser: 'false',\n     node_shared_libuv: 'false',\n     node_shared_v8: 'false',\n     node_shared_zlib: 'false',\n     node_use_dtrace: 'false',\n     node_use_openssl: 'true',\n     node_shared_openssl: 'false',\n     strict_aliasing: 'true',\n     target_arch: 'x64',\n     v8_use_snapshot: 'true' } }</code></pre>\n"
        },
        {
          "textRaw": "process.pid",
          "name": "pid",
          "desc": "<!--\nThe PID of the process.\n-->\n\n<p>このプロセスの PID です。\n\n</p>\n<pre><code>console.log('This process is pid ' + process.pid);</code></pre>\n"
        },
        {
          "textRaw": "process.title",
          "name": "title",
          "desc": "<!--\nGetter/setter to set what is displayed in 'ps'.\n-->\n\n<p>'ps' でどのよう表示されるかを設定するための getter/setter です。\n\n</p>\n<!--\nWhen used as a setter, the maximum length is platform-specific and probably\nshort.\n-->\n\n<p>setter が使われる場合、その最大長はプラットフォーム依存で、おそらく短いです。\n\n</p>\n<!--\nOn Linux and OS X, it's limited to the size of the binary name plus the\nlength of the command line arguments because it overwrites the argv memory.\n-->\n\n<p>Linux と OS X では、それは argv のメモリを上書きするため、\nバイナリ名にコマンドライン引数を加えたものに制限されます。\n\n</p>\n<!--\nv0.8 allowed for longer process title strings by also overwriting the environ\nmemory but that was potentially insecure/confusing in some (rather obscure)\ncases.\n-->\n\n<p>v0.8 はより長いプロセスタイトル文字列で環境を上書きしていましたが、\nそれはいくつかの (はっきりしない) ケースにおいて、\n潜在的に危険で混乱していました。\n\n\n</p>\n"
        },
        {
          "textRaw": "process.arch",
          "name": "arch",
          "desc": "<!--\nWhat processor architecture you're running on: `'arm'`, `'ia32'`, or `'x64'`.\n-->\n\n<p>実行しているプロセッサのアーキテクチャ: <code>'arm'</code>、<code>'ia32'</code>、または\n<code>'x64'</code>。\n\n</p>\n<pre><code>console.log('This processor architecture is ' + process.arch);</code></pre>\n"
        },
        {
          "textRaw": "process.platform",
          "name": "platform",
          "desc": "<!--\nWhat platform you're running on:\n`'darwin'`, `'freebsd'`, `'linux'`, `'sunos'` or `'win32'`\n-->\n\n<p>どのプラットフォームで動いているかを示します:\n<code>'darwin'</code>、<code>'freebsd'</code>、<code>'linux'</code>、<code>'sunos'</code>、または <code>'win32'</code>\n\n</p>\n<pre><code>console.log('This platform is ' + process.platform);</code></pre>\n"
        },
        {
          "textRaw": "`maxTickDepth` {Number} Default = 1000 ",
          "name": "maxTickDepth",
          "desc": "<!--\nCallbacks passed to `process.nextTick` will *usually* be called at the\nend of the current flow of execution, and are thus approximately as fast\nas calling a function synchronously.  Left unchecked, this would starve\nthe event loop, preventing any I/O from occurring.\n-->\n\n<p><code>process.nextTick()</code> に渡されたコールバックは、<em>通常</em> 現在の実行フローの\n後で呼び出され、それは関数を同期的に呼び出すのと同じくらい高速です。\nこれを放置するとあらゆる I/O が阻まれ、イベントループは飢餓状態となるでしょう。\n\n</p>\n<!--\nConsider this code:\n-->\n\n<p>以下のコードを考えてみてください。\n\n</p>\n<pre><code>process.nextTick(function foo() {\n  process.nextTick(foo);\n});</code></pre>\n<!--\nIn order to avoid the situation where Node is blocked by an infinite\nloop of recursive series of nextTick calls, it defers to allow some I/O\nto be done every so often.\n-->\n\n<p>nextTick の再帰が連鎖する無限ループによって Node がブロックする状況を\n避けるには、それを先送りして時々 I/O を可能にします。\n\n</p>\n<!--\nThe `process.maxTickDepth` value is the maximum depth of\nnextTick-calling nextTick-callbacks that will be evaluated before\nallowing other forms of I/O to occur.\n-->\n\n<p><code>process.maxTickDepth</code> の値は、nextTick が nextTick のコールバックを呼び出す\n最大の深さで、他の I/O を可能にする前に評価されます。\n\n</p>\n",
          "shortDesc": "Default = 1000"
        }
      ],
      "methods": [
        {
          "textRaw": "process.abort()",
          "type": "method",
          "name": "abort",
          "desc": "<!--\nThis causes node to emit an abort. This will cause node to exit and\ngenerate a core file.\n-->\n\n<p>これは node をアボートさせます。\nこれは node が終了してコアファイルを生成する原因となります。\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.chdir(directory)",
          "type": "method",
          "name": "chdir",
          "desc": "<!--\nChanges the current working directory of the process or throws an exception if that fails.\n-->\n\n<p>プロセスのカレントワーキングディレクトリを変更します。\nもし失敗した場合は例外をスローします。\n\n</p>\n<pre><code>console.log('Starting directory: ' + process.cwd());\ntry {\n  process.chdir('/tmp');\n  console.log('New directory: ' + process.cwd());\n}\ncatch (err) {\n  console.log('chdir: ' + err);\n}</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "directory"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.cwd()",
          "type": "method",
          "name": "cwd",
          "desc": "<!--\nReturns the current working directory of the process.\n-->\n\n<p>プロセスのカレントワーキングディレクトリを返します。\n\n</p>\n<pre><code>console.log('Current directory: ' + process.cwd());</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.exit([code])",
          "type": "method",
          "name": "exit",
          "desc": "<!--\nEnds the process with the specified `code`.  If omitted, exit uses the\n'success' code `0`.\n-->\n\n<p>指定の <code>code</code> でプロセスを終了します。\nもし省略されると、「成功」を示すコード <code>0</code> を使って終了します。\n\n</p>\n<!--\nTo exit with a 'failure' code:\n-->\n\n<p>「失敗」を示すコードで終了する例:\n\n</p>\n<pre><code>process.exit(1);</code></pre>\n<!--\nThe shell that executed node should see the exit code as 1.\n-->\n\n<p>node を実行したシェルで終了コードが 1 であることを見ることができるでしょう。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "code",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.getgid()",
          "type": "method",
          "name": "getgid",
          "desc": "<!--\nNote: this function is only available on POSIX platforms (i.e. not Windows)\n-->\n\n<p>注意: この関数は POSIX プラットフォーム (すなわち、非 Windows)\nでのみ利用可能です。\n\n</p>\n<!--\nGets the group identity of the process. (See getgid(2).)\nThis is the numerical group id, not the group name.\n-->\n\n<p>プロセスのグループ識別子を取得します (getgid(2) 参照)。\nこれは数値によるグループ ID で、グループ名ではありません。\n\n</p>\n<pre><code>if (process.getgid) {\n  console.log('Current gid: ' + process.getgid());\n}</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.setgid(id)",
          "type": "method",
          "name": "setgid",
          "desc": "<!--\nNote: this function is only available on POSIX platforms (i.e. not Windows)\n-->\n\n<p>注意: この関数は POSIX プラットフォーム (すなわち、非 Windows)\nでのみ利用可能です。\n\n</p>\n<!--\nSets the group identity of the process. (See setgid(2).)  This accepts either\na numerical ID or a groupname string. If a groupname is specified, this method\nblocks while resolving it to a numerical ID.\n-->\n\n<p>プロセスのグループ識別子を設定します (setgid(2) 参照)。\nこれは数値による ID もグループ名の文字列のどちらも受け入れます。\nもしグループ名が指定されると、数値による ID が解決できるまでこのメソッドはブロックします。\n\n</p>\n<pre><code>if (process.getgid && process.setgid) {\n  console.log('Current gid: ' + process.getgid());\n  try {\n    process.setgid(501);\n    console.log('New gid: ' + process.getgid());\n  }\n  catch (err) {\n    console.log('Failed to set gid: ' + err);\n  }\n}</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "id"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.getuid()",
          "type": "method",
          "name": "getuid",
          "desc": "<!--\nNote: this function is only available on POSIX platforms (i.e. not Windows)\n-->\n\n<p>注意: この関数は POSIX プラットフォーム (すなわち、非 Windows)\nでのみ利用可能です。\n\n</p>\n<!--\nGets the user identity of the process. (See getuid(2).)\nThis is the numerical userid, not the username.\n-->\n\n<p>プロセスのユーザ識別子を取得します (getuid(2) 参照)。\nこれは数値によるユーザ ID で、ユーザ名ではありません。\n\n</p>\n<pre><code>if (process.getuid) {\n  console.log('Current uid: ' + process.getuid());\n}</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.setuid(id)",
          "type": "method",
          "name": "setuid",
          "desc": "<!--\nNote: this function is only available on POSIX platforms (i.e. not Windows)\n-->\n\n<p>注意: この関数は POSIX プラットフォーム (すなわち、非 Windows)\nでのみ利用可能です。\n\n</p>\n<!--\nSets the user identity of the process. (See setuid(2).)  This accepts either\na numerical ID or a username string.  If a username is specified, this method\nblocks while resolving it to a numerical ID.\n-->\n\n<p>プロセスのユーザ識別子を設定します (setuid(2) 参照)。\nこれは数値による ID もユーザ名の文字列のどちらも受け入れます。\nもしユーザ名が指定されると、数値による ID が解決できるまでこのメソッドはブロックします。\n\n</p>\n<pre><code>if (process.getuid && process.setuid) {\n  console.log('Current uid: ' + process.getuid());\n  try {\n    process.setuid(501);\n    console.log('New uid: ' + process.getuid());\n  }\n  catch (err) {\n    console.log('Failed to set uid: ' + err);\n  }\n}</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "id"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.getgroups()",
          "type": "method",
          "name": "getgroups",
          "desc": "<!--\nNote: this function is only available on POSIX platforms (i.e. not Windows)\n-->\n\n<p>注意: この関数は POSIC プラットフォーム (つまり Windows 以外)\nでのみ利用可能です。\n\n</p>\n<!--\nReturns an array with the supplementary group IDs. POSIX leaves it unspecified\nif the effective group ID is included but node.js ensures it always is.\n-->\n\n<p>補助グループ ID の配列を返します。\nPOSIX は実効グループ ID が含まれることを明示していませんが、\nNode.js では常にそれが含まれることを保証します。\n\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.setgroups(groups)",
          "type": "method",
          "name": "setgroups",
          "desc": "<!--\nNote: this function is only available on POSIX platforms (i.e. not Windows)\n-->\n\n<p>注意: この関数は POSIC プラットフォーム (つまり Windows 以外)\nでのみ利用可能です。\n\n</p>\n<!--\nSets the supplementary group IDs. This is a privileged operation, meaning you\nneed to be root or have the CAP_SETGID capability.\n-->\n\n<p>補助グループ ID を設定します。\nこれは特権オペレーションであり、ルートであるか、または CAP_SETGID ケーパビリティを持つ必要があります。\n\n</p>\n<!--\nThe list can contain group IDs, group names or both.\n-->\n\n<p>リストはグループ ID、グループ名、または両方を含むことができます。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "groups"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.initgroups(user, extra_group)",
          "type": "method",
          "name": "initgroups",
          "desc": "<!--\nNote: this function is only available on POSIX platforms (i.e. not Windows)\n-->\n\n<p>注意: この関数は POSIC プラットフォーム (つまり Windows 以外)\nでのみ利用可能です。\n\n</p>\n<!--\nReads /etc/group and initializes the group access list, using all groups of\nwhich the user is a member. This is a privileged operation, meaning you need\nto be root or have the CAP_SETGID capability.\n-->\n\n<p><code>/etc/group</code> を読み込んでグループアクセスリストを初期化し、\nuser がメンバーである全てのグループを使用します。\nこれは特権オペレーションであり、ルートであるか、または CAP_SETGID ケーパビリティを持つ必要があります。\n\n</p>\n<!--\n`user` is a user name or user ID. `extra_group` is a group name or group ID.\n-->\n\n<p><code>user</code> はユーザ名またはユーザ ID、\n<code>extra_group</code> はグループ名またはグループ ID です。\n\n</p>\n<!--\nSome care needs to be taken when dropping privileges. Example:\n-->\n\n<p>特権を落とす際は、いくつか注意すべき事があります。例:\n\n</p>\n<pre><code>console.log(process.getgroups());         // [ 0 ]\nprocess.initgroups('bnoordhuis', 1000);   // switch user\nconsole.log(process.getgroups());         // [ 27, 30, 46, 1000, 0 ]\nprocess.setgid(1000);                     // drop root gid\nconsole.log(process.getgroups());         // [ 27, 30, 46, 1000 ]</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "user"
                },
                {
                  "name": "extra_group"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.kill(pid, [signal])",
          "type": "method",
          "name": "kill",
          "desc": "<!--\nSend a signal to a process. `pid` is the process id and `signal` is the\nstring describing the signal to send.  Signal names are strings like\n'SIGINT' or 'SIGHUP'.  If omitted, the signal will be 'SIGTERM'.\nSee [Signal Events](#process_signal_events) and kill(2) for more information.\n-->\n\n<p>プロセスにシグナルを送ります。\n<code>pid</code> はプロセス ID で <code>signal</code> は送信されるシグナルを文字列で記述したものです。\nシグナルの名前は 'SIGINT' や 'SIGHUP' のような文字列です。\n省略すると、シグナルは 'SIGTERM' となります。\n詳細は <a href="\"#process_signal_events\"">Signal Events</a> または kill(2)\nを参照してください。\n\n</p>\n<!--\nWill throw an error if target does not exist, and as a special case, a signal of\n`0` can be used to test for the existence of a process.\n-->\n\n<p>対象が存在しなければエラーがスローされます。\n特別なケースとして、プロセスが存在するかどうかテストするためにシグナル\n<code>0</code> を使うことが出来ます。\n\n</p>\n<!--\nNote that just because the name of this function is `process.kill`, it is\nreally just a signal sender, like the `kill` system call.  The signal sent\nmay do something other than kill the target process.\n-->\n\n<p>この関数の名前が <code>process.kill</code> であるとおり、これは <code>kill</code>\nシステムコールのように単にシグナルを送信することに注意してください。\n対象のプロセスを殺すためだけでなく、他のシグナルも送信できます。\n\n</p>\n<!--\nExample of sending a signal to yourself:\n-->\n\n<p>自身にシグナルを送信する例:\n\n</p>\n<pre><code>process.on('SIGHUP', function() {\n  console.log('Got SIGHUP signal.');\n});\n\nsetTimeout(function() {\n  console.log('Exiting.');\n  process.exit(0);\n}, 100);\n\nprocess.kill(process.pid, 'SIGHUP');</code></pre>\n<!--\nNote: When SIGUSR1 is received by Node.js it starts the debugger, see\n[Signal Events](#process_signal_events).\n-->\n\n<p>注意: SIGUSR1はnode.jsによって受信され、デバッガを起動します。\n詳細は <a href="\"#process_signal_events\"">Signal Events</a> を参照してください。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "pid"
                },
                {
                  "name": "signal",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.memoryUsage()",
          "type": "method",
          "name": "memoryUsage",
          "desc": "<!--\nReturns an object describing the memory usage of the Node process\nmeasured in bytes.\n-->\n\n<p>Node プロセスのメモリ使用状況をバイト単位で記述したオブジェクトを返します。\n\n</p>\n<pre><code>var util = require('util');\n\nconsole.log(util.inspect(process.memoryUsage()));</code></pre>\n<!--\nThis will generate:\n-->\n\n<p>このように生成されます:\n\n</p>\n<pre><code>{ rss: 4935680,\n  heapTotal: 1826816,\n  heapUsed: 650472 }</code></pre>\n<!--\n`heapTotal` and `heapUsed` refer to V8's memory usage.\n-->\n\n<p><code>heapTotal</code> と <code>heapUsed</code> は V8 のメモリ使用状況を参照します。\n\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.nextTick(callback)",
          "type": "method",
          "name": "nextTick",
          "desc": "<!--\nOn the next loop around the event loop call this callback.\nThis is *not* a simple alias to `setTimeout(fn, 0)`, it's much more\nefficient.  It typically runs before any other I/O events fire, but there\nare some exceptions.  See `process.maxTickDepth` below.\n-->\n\n<p>イベントループの次以降のループでコールバックを呼び出します。\nこれは <code>setTimeout(fn, 0)</code> の単純なエイリアス<em>ではなく</em>、\nはるかに効率的です。\nこれは通常他の I/O イベントが発生するよりも前に実行されますが、\nいくつかの例外があります。\n後述の <code>process.maxTickDepth</code> を参照してください。\n\n</p>\n<pre><code>process.nextTick(function() {\n  console.log('nextTick callback');\n});</code></pre>\n<!--\nThis is important in developing APIs where you want to give the user the\nchance to assign event handlers after an object has been constructed,\nbut before any I/O has occurred.\n-->\n\n<p>これは API の開発において、オブジェクトが構築された後で\nどんな I/O イベントが発生するよりも前に、\nイベントハンドラを割り当てるチャンスをユーザに与えたい場合に重要になります。\n\n</p>\n<pre><code>function MyThing(options) {\n  this.setupOptions(options);\n\n  process.nextTick(function() {\n    this.startDoingStuff();\n  }.bind(this));\n}\n\nvar thing = new MyThing();\nthing.getReadyForStuff();\n\n// thing.startDoingStuff() gets called now, not before.</code></pre>\n<!--\nIt is very important for APIs to be either 100% synchronous or 100%\nasynchronous.  Consider this example:\n-->\n\n<p>API は 100% 同期的か、100% 非同期的かのどちらかであることがとても重要です。\nこの例を考えてみてください:\n\n</p>\n<pre><code>// WARNING!  DO NOT USE!  BAD UNSAFE HAZARD!\nfunction maybeSync(arg, cb) {\n  if (arg) {\n    cb();\n    return;\n  }\n\n  fs.stat('file', cb);\n}</code></pre>\n<!--\nThis API is hazardous.  If you do this:\n-->\n\n<p>この API は危険です。こうすると:\n\n</p>\n<pre><code>maybeSync(true, function() {\n  foo();\n});\nbar();</code></pre>\n<!--\nthen it's not clear whether `foo()` or `bar()` will be called first.\n-->\n\n<p><code>foo()</code> と <code>bar()</code> のどちらが先に呼び出されるか不明瞭になります。\n\n</p>\n<!--\nThis approach is much better:\n-->\n\n<p>以下のアプローチはずっと優れています:\n\n</p>\n<pre><code>function definitelyAsync(arg, cb) {\n  if (arg) {\n    process.nextTick(cb);\n    return;\n  }\n\n  fs.stat('file', cb);\n}</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.umask([mask])",
          "type": "method",
          "name": "umask",
          "desc": "<!--\nSets or reads the process's file mode creation mask. Child processes inherit\nthe mask from the parent process. Returns the old mask if `mask` argument is\ngiven, otherwise returns the current mask.\n-->\n\n<p>プロセスのファイルモード作成マスクを設定または読み込みます。\n子プロセスは親プロセスからマスクを継承します。\n<code>mask</code> 引数が与えられると元のマスクが返され、そうでなければ現在のマスクが返されます。\n\n</p>\n<pre><code>var oldmask, newmask = 0644;\n\noldmask = process.umask(newmask);\nconsole.log('Changed umask from: ' + oldmask.toString(8) +\n            ' to ' + newmask.toString(8));</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "mask",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "process.uptime()",
          "type": "method",
          "name": "uptime",
          "desc": "<!--\nNumber of seconds Node has been running.\n-->\n\n<p>Node が実行されてからの秒数です。\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "process.hrtime()",
          "type": "method",
          "name": "hrtime",
          "desc": "<!--\nReturns the current high-resolution real time in a `[seconds, nanoseconds]`\ntuple Array. It is relative to an arbitrary time in the past. It is not\nrelated to the time of day and therefore not subject to clock drift. The\nprimary use is for measuring performance between intervals.\n\nYou may pass in the result of a previous call to `process.hrtime()` to get\na diff reading, useful for benchmarks and measuring intervals:\n-->\n\n<p>高分解能な現在時刻を <code>[seconds, nanoseconds]</code> の配列で返します。\n過去の任意の時間との比較することができます。\nそれは一日における時刻には関連が無いため、クロックドリフトに影響されません。\n主な用途はベンチマークやインターバルの測定です。\n\n</p>\n<p>以前に <code>process.hrtime()</code> を呼び出した結果を渡すことにより、\n差分を得ることができます。これはベンチマークやインターバルの測定に便利です。\n\n</p>\n<pre><code>var time = process.hrtime();\n// [ 1800216, 25 ]\n\nsetTimeout(function() {\n  var diff = process.hrtime(time);\n  // [ 1, 552 ]\n\n  console.log('benchmark took %d nanoseconds', diff[0] * 1e9 + diff[1]);\n  // benchmark took 1000000527 nanoseconds\n}, 1000);</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ]
    }
  ],
  "vars": [
    {
      "textRaw": "require()",
      "type": "var",
      "name": "require",
      "desc": "<!--\nTo require modules. See the [Modules][] section.  `require` isn't actually a\nglobal but rather local to each module.\n-->\n\n<p>require モジュールを指します。[モジュール][] の節を参照してください。\n<code>require</code> は実際はグローバルではなく、各モジュール毎のローカルです。\n\n</p>\n",
      "methods": [
        {
          "textRaw": "require.resolve()",
          "type": "method",
          "name": "resolve",
          "desc": "<!--\nUse the internal `require()` machinery to look up the location of a module,\nbut rather than loading the module, just return the resolved filename.\n-->\n\n<p><code>require()</code> の内部でモジュールの位置を検索するために使われます。\nモジュールのロードは行わず、ファイル名を解決して返すだけです。\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "`cache` {Object} ",
          "name": "cache",
          "desc": "<!--\nModules are cached in this object when they are required. By deleting a key\nvalue from this object, the next `require` will reload the module.\n-->\n\n<p>モジュールが要求されると、このオブジェクトの中にキャッシュされます。\nこのオブジェクトからキーと値を削除すると、次にそのモジュールが\n<code>require</code> されたときにリロードされます。\n\n</p>\n"
        },
        {
          "textRaw": "`extensions` {Object} ",
          "name": "extensions",
          "stability": 0,
          "stabilityText": "Deprecated",
          "desc": "<!--\nInstruct `require` on how to handle certain file extensions.\n\nProcess files with the extension `.sjs` as `.js`:\n-->\n\n<p><code>require</code> にファイル拡張子を扱う方法を教えます。\n\n</p>\n<p>拡張子が <code>.sjs</code> であるファイルの処理を <code>.js</code> と同じにするには:\n\n</p>\n<pre><code>require.extensions['.sjs'] = require.extensions['.js'];</code></pre>\n<!--\n**Deprecated**  In the past, this list has been used to load\nnon-JavaScript modules into Node by compiling them on-demand.\nHowever, in practice, there are much better ways to do this, such as\nloading modules via some other Node program, or compiling them to\nJavaScript ahead of time.\n-->\n\n<p><strong>廃止予定</strong> かつて、このリストは非 JavaScript モジュールを必要に応じて\nコンパイルし、Node にロードするために使われていました。\nしかし実際には、他の Node プログラムを通じてロードしたり、\n事前に JavaScript にコンパイルするなど、よりよい方法があります。\n\n</p>\n<!--\nSince the Module system is locked, this feature will probably never go\naway.  However, it may have subtle bugs and complexities that are best\nleft untouched.\n-->\n\n<p>モジュールシステムはロックされているので、この機能はおそらく\n無くならないでしょう。\nしかしながら、それは微妙なバグや複雑さがあってもそのまま放置されるでしょう。\n\n</p>\n"
        }
      ]
    },
    {
      "textRaw": "__filename",
      "name": "__filename",
      "type": "var",
      "desc": "<!--\nThe filename of the code being executed.  This is the resolved absolute path\nof this code file.  For a main program this is not necessarily the same\nfilename used in the command line.  The value inside a module is the path\nto that module file.\n-->\n\n<p>実行されているコードのファイル名です。これは解決された絶対パスです。\nメインプログラムでは、必ずしもコマンドライン引数で使われたファイル名と\n同じではありません。\nモジュールの中では、この値はそのモジュールファイルのパスとなります。\n\n</p>\n<!--\nExample: running `node example.js` from `/Users/mjr`\n-->\n\n<p>例: <code>node example.js</code> を <code>/Users/mjr</code> で実行する\n\n</p>\n<pre><code>console.log(__filename);\n// /Users/mjr/example.js</code></pre>\n<!--\n`__filename` isn't actually a global but rather local to each module.\n-->\n\n<p><code>__filename</code> は実際はグローバルではなく、各モジュール毎のローカルです。\n\n</p>\n"
    },
    {
      "textRaw": "__dirname",
      "name": "__dirname",
      "type": "var",
      "desc": "<!--\nThe name of the directory that the currently executing script resides in.\n-->\n\n<p>現在実行されているスクリプトが存在するディレクトリの名前です。\n\n</p>\n<!--\nExample: running `node example.js` from `/Users/mjr`\n-->\n\n<p>例: <code>node example.js</code> を <code>/Users/mjr</code> で実行する\n\n</p>\n<pre><code>console.log(__dirname);\n// /Users/mjr</code></pre>\n<!--\n`__dirname` isn't actually a global but rather local to each module.\n-->\n\n<p><code>__dirname</code> は実際はグローバルではなく、各モジュール毎のローカルです。\n\n\n</p>\n"
    },
    {
      "textRaw": "module",
      "name": "module",
      "type": "var",
      "desc": "<!--\nA reference to the current module. In particular\n`module.exports` is used for defining what a module exports and makes\navailable through `require()`.\n-->\n\n<p>現在のモジュールへの参照です。\n<code>module.exports</code> は、モジュールが公開して <code>require()</code> を通じて利用可能になる\nものを定めるために使われます。\n\n</p>\n<!--\n`module` isn't actually a global but rather local to each module.\n-->\n\n<p><code>module</code> は実際はグローバルではなく、各モジュール毎のローカルです。\n\n</p>\n<!--\nSee the [module system documentation][] for more information.\n-->\n\n<p>より詳しくは [モジュールシステムのドキュメント][] を参照してください。\n\n</p>\n"
    },
    {
      "textRaw": "exports",
      "name": "exports",
      "type": "var",
      "desc": "<!--\nA reference to the `module.exports` that is shorter to type.\nSee [module system documentation][] for details on when to use `exports` and\nwhen to use `module.exports`.\n-->\n\n<p><code>module.exports</code> への参照です。\nいつ <code>exports</code> を使い、いつ <code>module.exports</code> を使うかの詳細は\n[モジュールシステムのドキュメント][] を参照してください。\n\n</p>\n<!--\n`exports` isn't actually a global but rather local to each module.\n-->\n\n<p><code>exports</code> は実際はグローバルではなく、各モジュール毎のローカルです。\n\n</p>\n<!--\nSee the [module system documentation][] for more information.\n\nSee the [module section][] for more information.\n-->\n\n<p>より詳しくは [モジュール][] を参照してください。\n\n</p>\n"
    }
  ],
  "methods": [
    {
      "textRaw": "setTimeout(cb, ms)",
      "type": "method",
      "name": "setTimeout",
      "desc": "<!--\nRun callback `cb` after *at least* `ms` milliseconds. The actual delay depends\non external factors like OS timer granularity and system load.\n-->\n\n<p><em>少なくとも</em> <code>ms</code> ミリ秒が経過した後、コールバック <code>cb</code> を実行します。\n実際の遅延は OS のタイマ分解能やシステムの負荷など外部要因に依存します。\n\n</p>\n<!--\nThe timeout must be in the range of 1-2,147,483,647 inclusive. If the value is\noutside that range, it's changed to 1 millisecond. Broadly speaking, a timer\ncannot span more than 24.8 days.\n-->\n\n<p>タイムアウト値は 1～2,147,483,647 の範囲内でなければなりません。\nもし値がこの範囲外だった場合は 1 ミリ秒となります。\n大雑把に言って、タイマは 24.8 日を越えることはできません。\n\n</p>\n<!--\nReturns an opaque value that represents the timer.\n-->\n\n<p>タイマを表現する不透明な値を返します。\n\n</p>\n",
      "signatures": [
        {
          "params": [
            {
              "name": "cb"
            },
            {
              "name": "ms"
            }
          ]
        }
      ]
    },
    {
      "textRaw": "clearTimeout(t)",
      "type": "method",
      "name": "clearTimeout",
      "desc": "<!--\nStop a timer that was previously created with `setTimeout()`. The callback will\nnot execute.\n-->\n\n<p><code>setTimeout()</code> によって以前に作成されたタイマを終了します。\nコールバックは実行されなくなります。\n\n</p>\n",
      "signatures": [
        {
          "params": [
            {
              "name": "t"
            }
          ]
        }
      ]
    },
    {
      "textRaw": "setInterval(cb, ms)",
      "type": "method",
      "name": "setInterval",
      "desc": "<!--\nRun callback `cb` repeatedly every `ms` milliseconds. Note that the actual\ninterval may vary, depending on external factors like OS timer granularity and\nsystem load. It's never less than `ms` but it may be longer.\n-->\n\n<p><code>ms</code> ミリ秒ごとにコールバック <code>cb</code> を繰り返し実行します。\nOS のタイマ分解能やシステムの負荷など外部要因によって、\n実際のインターバルが異なるかもしれないことに注意してください。\nそれは決して <code>ms</code> より短いことはありませんが、より長いことがあります。\n\n</p>\n<!--\nThe interval must be in the range of 1-2,147,483,647 inclusive. If the value is\noutside that range, it's changed to 1 millisecond. Broadly speaking, a timer\ncannot span more than 24.8 days.\n-->\n\n<p>インターバル値は 1～2,147,483,647 の範囲内でなければなりません。\nもし値がこの範囲外だった場合は 1 ミリ秒となります。\n大雑把に言って、タイマは 24.8 日を越えることはできません。\n\n</p>\n<!--\nReturns an opaque value that represents the timer.\n-->\n\n<p>タイマを表現する不透明な値を返します。\n\n</p>\n",
      "signatures": [
        {
          "params": [
            {
              "name": "cb"
            },
            {
              "name": "ms"
            }
          ]
        }
      ]
    }
  ],
  "modules": [
    {
      "textRaw": "Timers",
      "name": "timers",
      "stability": 5,
      "stabilityText": "Locked",
      "desc": "<!--\nAll of the timer functions are globals.  You do not need to `require()`\nthis module in order to use them.\n-->\n\n<p>全てのタイマ関数はグローバルです。\nこのモジュールを使うために <code>require()</code> をする必要はありません。\n\n</p>\n",
      "methods": [
        {
          "textRaw": "setTimeout(callback, delay, [arg], [...])",
          "type": "method",
          "name": "setTimeout",
          "desc": "<!--\nTo schedule execution of a one-time `callback` after `delay` milliseconds. Returns a\n`timeoutObject` for possible use with `clearTimeout()`. Optionally you can\nalso pass arguments to the callback.\n-->\n\n<p><code>delay</code> ミリ秒が経過した後で、\n<code>callback</code> が一度だけ実行されるようにスケジュールします。\n<code>clearTimeout()</code> で使うことができる <code>timeoutObject</code> を返します。\nオプションとして、コールバックへの引数を渡すこともできます。\n\n</p>\n<!--\nIt is important to note that your callback will probably not be called in exactly\n`delay` milliseconds - Node.js makes no guarantees about the exact timing of when\nthe callback will fire, nor of the ordering things will fire in. The callback will\nbe called as close as possible to the time specified.\n-->\n\n<p>コールバックが正確に <code>delay</code> ミリ秒後に呼び出されるとは限らない点に\n注目することは重要です - \nNode.js はコールバックが呼び出される正確なタイミングも、\n呼び出される順番も保証しません。\nコールバックはできるだけ指定された時間に近いタイミングで呼び出されます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "callback"
                },
                {
                  "name": "delay"
                },
                {
                  "name": "arg",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "clearTimeout(timeoutObject)",
          "type": "method",
          "name": "clearTimeout",
          "desc": "<!--\nPrevents a timeout from triggering.\n-->\n\n<p>タイムアウトがトリガーされるのを止めます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "timeoutObject"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "setInterval(callback, delay, [arg], [...])",
          "type": "method",
          "name": "setInterval",
          "desc": "<!--\nTo schedule the repeated execution of `callback` every `delay` milliseconds.\nReturns a `intervalObject` for possible use with `clearInterval()`. Optionally\nyou can also pass arguments to the callback.\n-->\n\n<p><code>delay</code> ミリ秒が経過するごとに繰り返し <code>callback</code> が実行されるようにスケジュールします。\n<code>clearInterval()</code> で使うことができる <code>intervalObject</code> を返します。\nオプションとして、コールバックへの引数を渡すこともできます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "callback"
                },
                {
                  "name": "delay"
                },
                {
                  "name": "arg",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "clearInterval(intervalObject)",
          "type": "method",
          "name": "clearInterval",
          "desc": "<!--\nStops a interval from triggering.\n-->\n\n<p>インターバルがトリガーされるのを止めます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "intervalObject"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "unref()",
          "type": "method",
          "name": "unref",
          "desc": "<!--\nThe opaque value returned by `setTimeout` and `setInterval` also has the method\n`timer.unref()` which will allow you to create a timer that is active but if\nit is the only item left in the event loop won't keep the program running.\nIf the timer is already `unref`d calling `unref` again will have no effect.\n-->\n\n<p><code>setTimeout()</code> あるいは <code>setInterval()</code> が返す不透明な値は、\nアクティブであるにもかかわらず、それがイベントループの最後の一つになっても\nプログラムの実行を継続しないタイマを作ることを可能にする、\n<code>timer.unref()</code> メソッドを持っています。\n既に <code>unref</code> されたタイマで再び <code>unref</code> が呼び出されても影響はありません。\n\n</p>\n<!--\nIn the case of `setTimeout` when you `unref` you create a separate timer that\nwill wakeup the event loop, creating too many of these may adversely effect\nevent loop performance -- use wisely.\n-->\n\n<p><code>setTimeout()</code> が <code>unref</code> された場合、イベントループを起こすために独立した\nタイマが作成されるため、それらがあまりに多く作成されるとイベントループの\nパフォーマンスに悪影響を与えます -- 賢明に使ってください。\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "ref()",
          "type": "method",
          "name": "ref",
          "desc": "<!--\nIf you had previously `unref()`d a timer you can call `ref()` to explicitly\nrequest the timer hold the program open. If the timer is already `ref`d calling\n`ref` again will have no effect.\n-->\n\n<p>以前に <code>unref</code> されたタイマは、明示的に <code>ref()</code> を呼び出すことで\nプログラムを実行したままにするよう要求することができます。\n既に <code>ref</code> されたタイマで再び <code>ref</code> が呼び出されても影響はありません。\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "setImmediate(callback, [arg], [...])",
          "type": "method",
          "name": "setImmediate",
          "desc": "<!--\nTo schedule the \"immediate\" execution of `callback` after I/O events\ncallbacks and before `setTimeout` and `setInterval` . Returns an\n`immediateObject` for possible use with `clearImmediate()`. Optionally you\ncan also pass arguments to the callback.\n-->\n\n<p><code>callback</code> を「即時」 (I/O イベントのコールバックより後、<code>setTimeout</code> および\n<code>setInterval</code> よりも前) に実行するようスケジュールします。\n<code>clearImmediate()</code> に渡すことのできる <code>immediateObject</code> を返します。\nオプションとして、コールバックへの引数を渡すことができます。\n\n</p>\n<!--\nImmediates are queued in the order created, and are popped off the queue once\nper loop iteration. This is different from `process.nextTick` which will\nexecute `process.maxTickDepth` queued callbacks per iteration. `setImmediate`\nwill yield to the event loop after firing a queued callback to make sure I/O is\nnot being starved. While order is preserved for execution, other I/O events may\nfire between any two scheduled immediate callbacks.\n-->\n\n<p><code>setImmediate()</code> は作成された順でキューに入れられ、イベントループの\n繰り返し毎に一度、キューから取り出されます。\nこれは繰り返し毎に <code>process.maxTickDepth</code> で指定された回数までキューに\n入れられた関数が実行される <code>process.nextTick()</code> とは異なります。\n<code>setImmediate()</code> は I/O が沈み込まないように、キューイングされたコールバックが\n呼び出された後イベントループに制御を譲ります。\n二つの <code>setImmediate()</code> のコールバックが実行される順序は維持されますが、\n他の I/O が間に挟まるかもしれません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "callback"
                },
                {
                  "name": "arg",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "clearImmediate(immediateObject)",
          "type": "method",
          "name": "clearImmediate",
          "desc": "<!--\nStops an immediate from triggering.\n-->\n\n<p><code>setImmediate()</code> に渡した関数が呼び出されることを中止します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "immediateObject"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Timers"
    },
    {
      "textRaw": "Modules",
      "name": "module",
      "stability": 5,
      "stabilityText": "Locked",
      "desc": "<!--\nNode has a simple module loading system.  In Node, files and modules are in\none-to-one correspondence.  As an example, `foo.js` loads the module\n`circle.js` in the same directory.\n-->\n\n<p>Node はシンプルなモジュールローディングシステムを持ちます。\nNode では、ファイルとモジュールは１対１に対応します。\n例として、 <code>foo.js</code> は、同じディレクトリにある <code>circle.js</code> をロードしています。\n\n</p>\n<!--\nThe contents of `foo.js`:\n-->\n\n<p><code>foo.js</code> の内容:\n\n</p>\n<pre><code>var circle = require('./circle.js');\nconsole.log( 'The area of a circle of radius 4 is '\n           + circle.area(4));</code></pre>\n<!--\nThe contents of `circle.js`:\n-->\n\n<p><code>circle.js</code> の内容:\n\n</p>\n<pre><code>var PI = Math.PI;\n\nexports.area = function (r) {\n  return PI * r * r;\n};\n\nexports.circumference = function (r) {\n  return 2 * PI * r;\n};</code></pre>\n<!--\nThe module `circle.js` has exported the functions `area()` and\n`circumference()`.  To add functions and objects to the root of your module,\nyou can add them to the special `exports` object.\n-->\n\n<p><code>circle.js</code> モジュールは <code>area()</code> と <code>circumference()</code> を公開しています。\n関数やオブジェクトをモジュールのルートに加えるには、\n<code>exports</code> という特別なオブジェクトに加えます。\n\n</p>\n<!--\nVariables local to the module will be private, as though the module was wrapped\nin a function. In this example the variable `PI` is private to `circle.js`.\n-->\n\n<p>モジュールのローカル変数は関数に包まれているかのようにプライベートになります。\nこの例の場合、変数 <code>PI</code> は <code>circle.js</code> のプライベート変数です。\n\n</p>\n<!--\nIf you want the root of your module's export to be a function (such as a\nconstructor) or if you want to export a complete object in one assignment\ninstead of building it one property at a time, assign it to `module.exports`\ninstead of `exports`.\n-->\n\n<p>モジュールのルートとして関数 (たとえばコンストラクタ) を後悔したり、\nプロパティを一つずつ代入するのではなく、完全なオブジェクトを一度に\n公開したければ、<code>exports</code> の代わりに <code>module.exports</code>に代入します。\n\n</p>\n<!--\nBelow, `bar.js` makes use of the `square` module, which exports a constructor:\n-->\n\n<p>以下では、<code>bar.js</code> は <code>square</code> モジュールが公開するコンストラクタを\n使用しています。\n\n</p>\n<pre><code>var square = require('./square.js');\nvar mySquare = square(2);\nconsole.log('The area of my square is ' + mySquare.area());</code></pre>\n<!--\nThe `square` module is defined in `square.js`:\n-->\n\n<p><code>square.js</code> モジュールは <code>square.js</code> で定義されています。\n\n</p>\n<pre><code>// assigning to exports will not modify module, must use module.exports\nmodule.exports = function(width) {\n  return {\n    area: function() {\n      return width * width;\n    }\n  };\n}</code></pre>\n<!--\nThe module system is implemented in the `require(\"module\")` module.\n-->\n\n<p>モジュールシステムは <code>require("module")</code> モジュールによって実装されます。\n\n</p>\n",
      "miscs": [
        {
          "textRaw": "Cycles",
          "name": "Cycles",
          "type": "misc",
          "desc": "<!--\nWhen there are circular `require()` calls, a module might not be\ndone being executed when it is returned.\n\nConsider this situation:\n-->\n\n<p><code>require()</code> が循環的に呼び出される場合、実行が完了していないモジュールが\n返されることがあります。\n\n</p>\n<p>次の状況を考えてください:\n\n</p>\n<p><code>a.js</code>:\n\n</p>\n<pre><code>console.log('a starting');\nexports.done = false;\nvar b = require('./b.js');\nconsole.log('in a, b.done = %j', b.done);\nexports.done = true;\nconsole.log('a done');</code></pre>\n<p><code>b.js</code>:\n\n</p>\n<pre><code>console.log('b starting');\nexports.done = false;\nvar a = require('./a.js');\nconsole.log('in b, a.done = %j', a.done);\nexports.done = true;\nconsole.log('b done');</code></pre>\n<p><code>main.js</code>:\n\n</p>\n<pre><code>console.log('main starting');\nvar a = require('./a.js');\nvar b = require('./b.js');\nconsole.log('in main, a.done=%j, b.done=%j', a.done, b.done);</code></pre>\n<!--\nWhen `main.js` loads `a.js`, then `a.js` in turn loads `b.js`.  At that\npoint, `b.js` tries to load `a.js`.  In order to prevent an infinite\nloop an **unfinished copy** of the `a.js` exports object is returned to the\n`b.js` module.  `b.js` then finishes loading, and its `exports` object is\nprovided to the `a.js` module.\n\nBy the time `main.js` has loaded both modules, they're both finished.\nThe output of this program would thus be:\n-->\n\n<p><code>main.js</code> が <code>a.js</code> をロードすると、<code>a.js</code> は <code>b.js</code> をロードします。\nポイントは、<code>b.js</code> は <code>a.js</code> のロードを試みることです。\n無限ループを避けるため、<code>a.js</code> がエクスポートしたオブジェクトの\n<strong>未完了のコピー</strong> が <code>b.js</code> モジュールに返されます。\n<code>b.js</code> のロードが完了すると、<code>exports</code> オブジェクトが <code>a.js</code> モジュールに\n提供されます。\n\n</p>\n<p><code>main.js</code> が両方のモジュールをロードするまでには、どちらも完了します。\nこのプログラムの出力はこのようになります:\n\n</p>\n<pre><code>$ node main.js\nmain starting\na starting\nb starting\nin b, a.done = false\nb done\nin a, b.done = true\na done\nin main, a.done=true, b.done=true</code></pre>\n<!--\nIf you have cyclic module dependencies in your program, make sure to\nplan accordingly.\n-->\n\n<p>プログラムが循環参照するモジュールを持つ場合は、計画が適切か確認してください。\n\n\n</p>\n"
        },
        {
          "textRaw": "Core Modules",
          "name": "Core Modules",
          "type": "misc",
          "desc": "<!--\nNode has several modules compiled into the binary.  These modules are\ndescribed in greater detail elsewhere in this documentation.\n\nThe core modules are defined in node's source in the `lib/` folder.\n\nCore modules are always preferentially loaded if their identifier is\npassed to `require()`.  For instance, `require('http')` will always\nreturn the built in HTTP module, even if there is a file by that name.\n-->\n\n<p>Node にはバイナリにコンパイル済みのいくつかのモジュールがあります。\nこれらのモジュールについては、このドキュメントの他の場所でより詳しく記述されています。\n\n</p>\n<p>コアモジュールは、 Node のソースの <code>lib/</code> フォルダにて定義されています。\n\n</p>\n<p><code>require()</code> では常にコアモジュールの識別名を優先的に解釈します。\n例えば <code>require('http')</code> は、例え同名のファイルが存在していたとしても、常にビルトイインの HTTP モジュールを返します。\n\n</p>\n"
        },
        {
          "textRaw": "File Modules",
          "name": "File Modules",
          "type": "misc",
          "desc": "<!--\nIf the exact filename is not found, then node will attempt to load the\nrequired filename with the added extension of `.js`, `.json`, and then `.node`.\n\n`.js` files are interpreted as JavaScript text files, and `.json` files are\nparsed as JSON text files. `.node` files are interpreted as compiled addon\nmodules loaded with `dlopen`.\n\nA module prefixed with `'/'` is an absolute path to the file.  For\nexample, `require('/home/marco/foo.js')` will load the file at\n`/home/marco/foo.js`.\n\nA module prefixed with `'./'` is relative to the file calling `require()`.\nThat is, `circle.js` must be in the same directory as `foo.js` for\n`require('./circle')` to find it.\n\nWithout a leading '/' or './' to indicate a file, the module is either a\n\"core module\" or is loaded from a `node_modules` folder.\n-->\n\n<p>指定された名前のファイルが見つからなければ、 Node は指定されたファイル名に\n<code>.js</code>、<code>.json</code>、または <code>.node</code> を付けたものを読み込もうとします。\n\n</p>\n<p><code>.js</code> ファイルは JavaScript ファイルとして解釈され、\n<code>.json</code> ファイルは JSON ファイルとして解釈されます。\n一方 <code>.node</code> ファイルはコンパイル済みのアドオンモジュールとして解釈され、\n<code>dlopen</code> を使って読み込まれます。\n\n</p>\n<p><code>'/'</code> から始まるモジュールは、ファイルへの絶対パスと見なされます。\n例えば、 <code>require('/home/marco/foo.js')</code> は <code>/home/macro/foo.js</code> を読み込みます。\n\n</p>\n<p><code>'./'</code> から始まるモジュールは、 <code>require()</code> を呼んだファイルからの相対パスになります。\nすなわち、 <code>foo.js</code> から <code>require('./circle')</code> によって <code>circle.js</code> を読み込むには、 <code>circle.js</code> は <code>foo.js</code> と同じディレクトリに存在していなければなりません。\n\n</p>\n<p>'/' や './' が先頭になければ、モジュールは "コアモジュール" であるかもしくは <code>node_modules</code> フォルダから読み込まれることになります。\n\n</p>\n<!--\nIf the given path does not exist, `require()` will throw an Error with its\n`code` property set to `'MODULE_NOT_FOUND'`.\n-->\n\n<p>与えられたパスが存在しなかった場合、<code>require()</code> は <code>code</code> プロパティに\n<code>'MODULE_NOT_FOUND'</code> を設定したエラーをスローします。\n\n</p>\n"
        },
        {
          "textRaw": "Loading from `node_modules` Folders",
          "name": "Loading from `node_modules` Folders",
          "type": "misc",
          "desc": "<!--\nIf the module identifier passed to `require()` is not a native module,\nand does not begin with `'/'`, `'../'`, or `'./'`, then node starts at the\nparent directory of the current module, and adds `/node_modules`, and\nattempts to load the module from that location.\n\nIf it is not found there, then it moves to the parent directory, and so\non, until the root of the tree is reached.\n\nFor example, if the file at `'/home/ry/projects/foo.js'` called\n`require('bar.js')`, then node would look in the following locations, in\nthis order:\n-->\n\n<p>もし <code>require()</code> に渡されたモジュール識別子がネイティブモジュールではなく、かつ  <code>'/'</code> や <code>'../'</code> や <code>'./'</code> から始まらないならば、 Node は現在のモジュールの親ディレクトリに <code>'/node_modules'</code> を付与してそこからモジュールを読み込もうとします。\n\n</p>\n<p>そこに見つからない場合はさらに親ディレクトリに移動し、モジュールが見つかるか root ディレクトリに到達するまで同様のことを繰り返していきます。\n\n</p>\n<p>例えば <code>'/home/ry/projects/foo.js'</code> の中で <code>require('bar.js')</code> を呼んでいた場合、 Node は下記の位置を上から順番に見ていきます。\n\n</p>\n<ul>\n<li><code>/home/ry/projects/node_modules/bar.js</code></li>\n<li><code>/home/ry/node_modules/bar.js</code></li>\n<li><code>/home/node_modules/bar.js</code></li>\n<li><code>/node_modules/bar.js</code></li>\n</ul>\n<!--\nThis allows programs to localize their dependencies, so that they do not\nclash.\n-->\n\n<p>この仕組みによって、プログラムはクラッシュを避けるために依存関係を上書きすることができるのです。\n\n</p>\n"
        },
        {
          "textRaw": "Folders as Modules",
          "name": "Folders as Modules",
          "type": "misc",
          "desc": "<!--\nIt is convenient to organize programs and libraries into self-contained\ndirectories, and then provide a single entry point to that library.\nThere are three ways in which a folder may be passed to `require()` as\nan argument.\n\nThe first is to create a `package.json` file in the root of the folder,\nwhich specifies a `main` module.  An example package.json file might\nlook like this:\n-->\n\n<p>プログラムとライブラリをディレクトリ内にまとめて、そのエントリポイントを提示するという便利な方法もあります。\nそれには <code>require()</code> に引数として何を渡すかによって3通りの方法があります。\n\n</p>\n<p>1つ目は、 <code>package.json</code> というファイルをフォルダ直下に作成し、 <code>main</code> モジュールを指定するという方法です。\n例えば、 package.json は以下のようなファイルになります:\n\n</p>\n<pre><code>{ "name" : "some-library",\n  "main" : "./lib/some-library.js" }</code></pre>\n<!--\nIf this was in a folder at `./some-library`, then\n`require('./some-library')` would attempt to load\n`./some-library/lib/some-library.js`.\n\nThis is the extent of Node's awareness of package.json files.\n\nIf there is no package.json file present in the directory, then node\nwill attempt to load an `index.js` or `index.node` file out of that\ndirectory.  For example, if there was no package.json file in the above\nexample, then `require('./some-library')` would attempt to load:\n-->\n\n<p>もし <code>./some-library</code> フォルダ内にこのファイルがあれば、 <code>require('./some-library')</code> は <code>./some-library/lib/some-library.js</code> を読みにいきます。\n\n</p>\n<p>これは、 Node が package.json の存在に気づくことによってもたらされます。\n\n</p>\n<p>もし package.json がディレクトリに存在していなければ、 Node はそのディレクトリで <code>index.js</code> もしくは <code>index.node</code> を探します。\n例えば、もし上の例で package.json がいるが存在しないとすると、 <code>require('./some-library')</code> は以下のファイルを読み込もうとします: \n\n</p>\n<ul>\n<li><code>./some-library/index.js</code></li>\n<li><code>./some-library/index.node</code></li>\n</ul>\n"
        },
        {
          "textRaw": "Caching",
          "name": "Caching",
          "type": "misc",
          "desc": "<!--\nModules are cached after the first time they are loaded.  This means\n(among other things) that every call to `require('foo')` will get\nexactly the same object returned, if it would resolve to the same file.\n-->\n\n<p>モジュールは初めて読み込まれたときにキャッシュされます。\nすなわち（他のキャッシュと同様に） <code>require('foo')</code> を呼ぶたびに、もし引数の意味するものが同一のファイルであったなら全く同一のオブジェクトが返されます。\n\n</p>\n<!--\nMultiple calls to `require('foo')` may not cause the module code to be\nexecuted multiple times.  This is an important feature.  With it,\n\"partially done\" objects can be returned, thus allowing transitive\ndependencies to be loaded even when they would cause cycles.\n-->\n\n<p><code>require('foo')</code> が複数回呼び出されても、モジュールが複数回実行されることにはなりません。\nこれは重要な特徴です。\nそのため、「部分的に完了した」オブジェクトを返すことで、\n推移的な依存関係が循環していてもロードすることができます。\n\n</p>\n<!--\nIf you want to have a module execute code multiple times, then export a\nfunction, and call that function.\n-->\n\n<p>もしモジュールを複数回実行したければ、関数を公開して、\nその関数を呼び出してください。\n\n</p>\n",
          "miscs": [
            {
              "textRaw": "Module Caching Caveats",
              "name": "Module Caching Caveats",
              "type": "misc",
              "desc": "<!--\nModules are cached based on their resolved filename.  Since modules may\nresolve to a different filename based on the location of the calling\nmodule (loading from `node_modules` folders), it is not a *guarantee*\nthat `require('foo')` will always return the exact same object, if it\nwould resolve to different files.\n-->\n\n<p>モジュールは解決されたファイル名に基づいてキャッシュされます。\n異なる場所にあるモジュールから呼び出されたモジュールは、\n(<code>node_module</code> フォルダからロードされるため) 異なったファイル名で\n解決されることがあるため、 <code>require('foo')</code> が常に同じオブジェクトを返す\n<em>保証</em>はなく、異なるファイルとして解決されます。\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "All Together...",
          "name": "All Together...",
          "type": "misc",
          "desc": "<!--\nTo get the exact filename that will be loaded when `require()` is called, use\nthe `require.resolve()` function.\n-->\n\n<p><code>require()</code> が呼び出されると、正確なファイル名を得るために <code>require.resolve()</code> が使われます。\n\n</p>\n<!--\nPutting together all of the above, here is the high-level algorithm\nin pseudocode of what require.resolve does:\n-->\n\n<p>上で述べたことをまとめると、 require.resolve は以下の擬似コードで記述されるようなハイレベルなアルゴリズムに則っています:\n\n</p>\n<pre><code>require(X) from module at path Y\n1. If X is a core module,\n   a. return the core module\n   b. STOP\n2. If X begins with './' or '/' or '../'\n   a. LOAD_AS_FILE(Y + X)\n   b. LOAD_AS_DIRECTORY(Y + X)\n3. LOAD_NODE_MODULES(X, dirname(Y))\n4. THROW "not found"\n\nLOAD_AS_FILE(X)\n1. If X is a file, load X as JavaScript text.  STOP\n2. If X.js is a file, load X.js as JavaScript text.  STOP\n3. If X.node is a file, load X.node as binary addon.  STOP\n\nLOAD_AS_DIRECTORY(X)\n1. If X/package.json is a file,\n   a. Parse X/package.json, and look for "main" field.\n   b. let M = X + (json main field)\n   c. LOAD_AS_FILE(M)\n2. If X/index.js is a file, load X/index.js as JavaScript text.  STOP\n3. If X/index.node is a file, load X/index.node as binary addon.  STOP\n\nLOAD_NODE_MODULES(X, START)\n1. let DIRS=NODE_MODULES_PATHS(START)\n2. for each DIR in DIRS:\n   a. LOAD_AS_FILE(DIR/X)\n   b. LOAD_AS_DIRECTORY(DIR/X)\n\nNODE_MODULES_PATHS(START)\n1. let PARTS = path split(START)\n2. let ROOT = index of first instance of "node_modules" in PARTS, or 0\n3. let I = count of PARTS - 1\n4. let DIRS = []\n5. while I > ROOT,\n   a. if PARTS[I] = "node_modules" CONTINUE\n   c. DIR = path join(PARTS[0 .. I] + "node_modules")\n   b. DIRS = DIRS + DIR\n   c. let I = I - 1\n6. return DIRS</code></pre>\n"
        },
        {
          "textRaw": "Loading from the global folders",
          "name": "Loading from the global folders",
          "type": "misc",
          "desc": "<!--\nIf the `NODE_PATH` environment variable is set to a colon-delimited list\nof absolute paths, then node will search those paths for modules if they\nare not found elsewhere.  (Note: On Windows, `NODE_PATH` is delimited by\nsemicolons instead of colons.)\n\nAdditionally, node will search in the following locations:\n-->\n\n<p><code>NODE_PATH</code> 環境変数に絶対パスをコロンで区切ったリストを設定すると、\nnode は他で見つからなかったモジュールをそれらのパスから探します。\n(注意: Windows では、<code>NODE_PATH</code> はコロンではなくセミコロンで区切られます)\n\n</p>\n<p>加えると、node は以下の場所から検索します。\n\n</p>\n<ul>\n<li>1: <code>$HOME/.node_modules</code></li>\n<li>2: <code>$HOME/.node_libraries</code></li>\n<li>3: <code>$PREFIX/lib/node</code></li>\n</ul>\n<!--\nWhere `$HOME` is the user's home directory, and `$PREFIX` is node's\nconfigured `node_prefix`.\n\nThese are mostly for historic reasons.  You are highly encouraged to\nplace your dependencies locally in `node_modules` folders.  They will be\nloaded faster, and more reliably.\n-->\n\n<p><code>$HOME</code> はユーザのホームディレクトリ、<code>$PREFIX</code> は node を\nconfigure した時の <code>node_prefix</code> です。\n\n</p>\n<p>これらは主に歴史的な理由によるものです。\nあなたが依存するものはローカルの <code>node_modules</code> フォルダに置くことが\n強く推奨されます。それは素早くロードされ、確実です。\n\n</p>\n"
        },
        {
          "textRaw": "Accessing the main module",
          "name": "Accessing the main module",
          "type": "misc",
          "desc": "<!--\nWhen a file is run directly from Node, `require.main` is set to its\n`module`. That means that you can determine whether a file has been run\ndirectly by testing\n-->\n\n<p>ファイルがNodeによって直接実行される場合、その <code>module</code> が\n<code>require.main</code> に設定されます。\nこれは、ファイルが直接実行されたかを決定できることを意味します。\n\n</p>\n<pre><code>require.main === module</code></pre>\n<!--\nFor a file `foo.js`, this will be `true` if run via `node foo.js`, but\n`false` if run by `require('./foo')`.\n\nBecause `module` provides a `filename` property (normally equivalent to\n`__filename`), the entry point of the current application can be obtained\nby checking `require.main.filename`.\n-->\n\n<p><code>foo.js</code> ファイルの場合、<code>node foo.js</code> と実行された場合にこれは <code>true</code> \nになりますが、<code>require('./foo')</code> で実行された場合は <code>false</code> になります。\n\n</p>\n<p><code>module</code> は <code>filename</code> プロパティ (通常 <code>__filename</code> と同じです) \nを提供するため、現在のアプリケーションのエントリポイントは\n<code>require.main.filename</code> をチェックすることで得ることができます。\n\n</p>\n"
        },
        {
          "textRaw": "Addenda: Package Manager Tips",
          "name": "Addenda: Package Manager Tips",
          "type": "misc",
          "desc": "<!--\nThe semantics of Node's `require()` function were designed to be general\nenough to support a number of sane directory structures. Package manager\nprograms such as `dpkg`, `rpm`, and `npm` will hopefully find it possible to\nbuild native packages from Node modules without modification.\n-->\n\n<p>Node の <code>require()</code> は普通のディレクトリ構造をサポートできるよう汎用的に設計されています。\n<code>dpkg</code> や <code>rpm</code> や <code>npm</code> のようなパッケージ管理プログラムは修正なしに Node モジュールからネイティブパッケージを組み立てることができるでしょう。\n\n</p>\n<!--\nBelow we give a suggested directory structure that could work:\n\nLet's say that we wanted to have the folder at\n`/usr/lib/node/<some-package>/<some-version>` hold the contents of a\nspecific version of a package.\n-->\n\n<p>推奨するディレクトリ構造は次のようになります:\n\n</p>\n<p>例えば <code>/usr/lib/node/<some-package>/<some-version></code> フォルダに、あるパッケージの特定のバージョンを保持する形式です。\n\n</p>\n<!--\nPackages can depend on one another. In order to install package `foo`, you\nmay have to install a specific version of package `bar`.  The `bar` package\nmay itself have dependencies, and in some cases, these dependencies may even\ncollide or form cycles.\n-->\n\n<p>パッケージは相互に依存しあうことがあります。\n<code>foo</code> パッケージをインストールするためにはある特定のバージョンの <code>bar</code> パッケージをインストールする必要があります。\n<code>bar</code> パッケージ自身も依存関係をもっているので、ときには依存関係が衝突したり循環したりすることがあります。\n\n</p>\n<!--\nSince Node looks up the `realpath` of any modules it loads (that is,\nresolves symlinks), and then looks for their dependencies in the\n`node_modules` folders as described above, this situation is very simple to\nresolve with the following architecture:\n-->\n\n<p>Node はモジュールの <code>realpath</code> （シンボリックリンクを解釈します）を調べ、その依存関係を上述の <code>node_modules</code> フォルダの仕組みで探しにいきます。\nこれによって次のような構造をとてもシンプルに解釈することができます。\n\n</p>\n<!--\n* `/usr/lib/node/foo/1.2.3/` - Contents of the `foo` package, version 1.2.3.\n* `/usr/lib/node/bar/4.3.2/` - Contents of the `bar` package that `foo`\n  depends on.\n* `/usr/lib/node/foo/1.2.3/node_modules/bar` - Symbolic link to\n  `/usr/lib/node/bar/4.3.2/`.\n* `/usr/lib/node/bar/4.3.2/node_modules/*` - Symbolic links to the packages\n  that `bar` depends on.\n-->\n\n<ul>\n<li><code>/usr/lib/node/foo/1.2.3/</code> - <code>foo</code> パッケージの中身。バージョン1.2.3。</li>\n<li><code>/usr/lib/node/bar/4.3.2/</code> - <code>bar</code> パッケージの中身。 <code>foo</code> が依存している。</li>\n<li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - <code>/usr/lib/node/bar/4.3.2/</code> へのシンボリックリンク。</li>\n<li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - <code>bar</code> が依存しているパッケージへのシンボリックリンク。</li>\n</ul>\n<!--\nThus, even if a cycle is encountered, or if there are dependency\nconflicts, every module will be able to get a version of its dependency\nthat it can use.\n\nWhen the code in the `foo` package does `require('bar')`, it will get the\nversion that is symlinked into `/usr/lib/node/foo/1.2.3/node_modules/bar`.\nThen, when the code in the `bar` package calls `require('quux')`, it'll get\nthe version that is symlinked into\n`/usr/lib/node/bar/4.3.2/node_modules/quux`.\n\nFurthermore, to make the module lookup process even more optimal, rather\nthan putting packages directly in `/usr/lib/node`, we could put them in\n`/usr/lib/node_modules/<name>/<version>`.  Then node will not bother\nlooking for missing dependencies in `/usr/node_modules` or `/node_modules`.\n\nIn order to make modules available to the node REPL, it might be useful to\nalso add the `/usr/lib/node_modules` folder to the `$NODE_PATH` environment\nvariable.  Since the module lookups using `node_modules` folders are all\nrelative, and based on the real path of the files making the calls to\n`require()`, the packages themselves can be anywhere.\n-->\n\n<p>このようにして、もし仮に依存関係に循環や衝突が見つかったとしても、全てのモジュールは依存しているパッケージの特定のバージョンを取得することができます。\n\n</p>\n<p><code>foo</code> パッケージの中で <code>require('bar')</code> したら、 <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> からリンクされているバージョンを取得します。\nそして、 <code>bar</code> パッケージ内で <code>require('quux')</code> を呼んだら、 <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code> からリンクされているバージョンを取得します。\n\n</p>\n<p>さらに、モジュールを探索する過程をより最適化するために、 <code>/usr/lib/node</code> にパッケージを置くよりも <code>/usr/lib/node_modules/<name>/<version></code> に置くのをお勧めします。\nそうすることで Node は見つからない依存パッケージを <code>/usr/node_modules</code> や <code>/node_modules</code> に探しにいかなくてもようなります。\n\n</p>\n<p>Node の REPL でモジュールを使えるようにするために、 <code>/usr/lib/node_modules</code> フォルダを <code>$NODE_PATH</code> 環境変数に追加するとよいでしょう。\n<code>node_modules</code> フォルダを使ったモジュール探索は全て相対的なものであり、 <code>require()</code> を呼び出したファイルの絶対パスを基準としているので、パッケージ自体はどこにでも配置することができます。\n\n</p>\n"
        }
      ],
      "vars": [
        {
          "textRaw": "The `module` Object",
          "name": "The `module` Object",
          "type": "var",
          "desc": "<p>!-- name=module -->\n\n</p>\n<ul>\n<li>{Object}</li>\n</ul>\n<!--\nIn each module, the `module` free variable is a reference to the object\nrepresenting the current module.  For convenience, `module.exports` is\nalso accessible via the `exports` module-global. `module` isn't actually\na global but rather local to each module.\n-->\n\n<p>どのモジュールでも、<code>module</code> 自由変数は現在のモジュールを表現するオブジェクトを\n参照します。\n利便性のため、<code>module.exports</code> は <code>exports</code> オブジェクトを通じて\n参照することもできます。\n<code>module</code> は実際はグローバルではなく、各モジュールのローカル変数です。\n\n</p>\n",
          "properties": [
            {
              "textRaw": "`exports` {Object} ",
              "name": "exports",
              "desc": "<!--\nThe `module.exports` object is created by the Module system. Sometimes this is not\nacceptable; many want their module to be an instance of some class. To do this\nassign the desired export object to `module.exports`. Note that assigning the\ndesired object to `exports` will simply rebind the local `exports` variable,\nwhich is probably not what you want to do.\n-->\n\n<p><code>module.exports</code> オブジェクトはモジュールシステムによって作成されます。\n時々これは受け入れらません;\n多くの人々は、モジュールが何らかのクラスのインスタンスであることを望みます。\nそれには、公開したいオブジェクトを <code>module.exports</code> に割り当てます。\n望ましいオブジェクトを <code>exports</code> へ代入することは、ローカル変数 <code>exports</code> への\n再代入に過ぎずないことに注意すべきです。\nそれはおそらく、やりたかったことではないでしょう。\n\n</p>\n<!--\nFor example suppose we were making a module called `a.js`\n-->\n\n<p>例えば <code>a.js</code> と呼ばれるモジュールを作るとしたら\n\n</p>\n<pre><code>var EventEmitter = require('events').EventEmitter;\n\nmodule.exports = new EventEmitter();\n\n// Do some work, and after some time emit\n// the 'ready' event from the module itself.\nsetTimeout(function() {\n  module.exports.emit('ready');\n}, 1000);</code></pre>\n<!--\nThen in another file we could do\n-->\n\n<p>そして別のファイルで\n\n</p>\n<pre><code>var a = require('./a');\na.on('ready', function() {\n  console.log('module a is ready');\n});</code></pre>\n<!--\nNote that assignment to `module.exports` must be done immediately. It cannot be\ndone in any callbacks.  This does not work:\n-->\n\n<p><code>module.exports</code> への代入はすぐに行わなければなりません。\nコールバックの中ではできません。以下は動きません。\n\n</p>\n<p>x.js:\n\n</p>\n<pre><code>setTimeout(function() {\n  module.exports = { a: "hello" };\n}, 0);</code></pre>\n<p>y.js:\n\n</p>\n<pre><code>var x = require('./x');\nconsole.log(x.a);</code></pre>\n",
              "modules": [
                {
                  "textRaw": "exports alias",
                  "name": "exports_alias",
                  "desc": "<!--\nThe `exports` variable that is available within a module starts as a reference\nto `module.exports`. As with any variable, if you assign a new value to it, it\nis no longer bound to the previous value.\n-->\n\n<p>モジュール内で利用出来る <code>exports</code> 変数は、最初は <code>module.exports</code>\nへの参照です。\n他の変数と同様、それに新しい値を割り当てると元の値はもはや束縛されません。\n\n</p>\n<!--\nTo illustrate the behaviour, imagine this hypothetical implementation of\n`require()`:\n-->\n\n<p>その振る舞いを示すために、この仮定の実装を想像してください。\n\n</p>\n<pre><code>function require(...) {\n  // ...\n  function (module, exports) {\n    // Your module code here\n    exports = some_func;        // re-assigns exports, exports is no longer\n                                // a shortcut, and nothing is exported.\n    module.exports = some_func; // makes your module export 0\n  } (module, module.exports);\n  return module;\n}</code></pre>\n<!--\nAs a guideline, if the relationship between `exports` and `module.exports`\nseems like magic to you, ignore `exports` and only use `module.exports`.\n-->\n\n<p>ガイドラインとして、もし <code>exports</code> と <code>module.exports</code> の間の関係が魔法のように\n見えるなら、<code>exports</code> を無視して <code>module.exports</code> だけを使うようにしてください。\n\n</p>\n",
                  "type": "module",
                  "displayName": "exports alias"
                }
              ]
            },
            {
              "textRaw": "`id` {String} ",
              "name": "id",
              "desc": "<!--\nThe identifier for the module.  Typically this is the fully resolved\nfilename.\n-->\n\n<p>モジュールの識別子。通常は完全に解決されたファイル名です。\n\n\n</p>\n"
            },
            {
              "textRaw": "`filename` {String} ",
              "name": "filename",
              "desc": "<!--\nThe fully resolved filename to the module.\n-->\n\n<p>完全に解決されたモジュールのファイル名です。\n\n\n</p>\n"
            },
            {
              "textRaw": "`loaded` {Boolean} ",
              "name": "loaded",
              "desc": "<!--\nWhether or not the module is done loading, or is in the process of\nloading.\n-->\n\n<p>モジュールのロードが完了したか，あるいはローディング中かを示します。\n\n\n</p>\n"
            },
            {
              "textRaw": "`parent` {Module Object} ",
              "name": "parent",
              "desc": "<!--\nThe module that required this one.\n-->\n\n<p>このモジュールを要求したモジュールです。\n\n\n</p>\n"
            },
            {
              "textRaw": "`children` {Array} ",
              "name": "children",
              "desc": "<!--\nThe module objects required by this one.\n-->\n\n<p>このモジュールが要求したモジュールです。\n\n\n\n</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "module.require(id)",
              "type": "method",
              "name": "require",
              "desc": "<!--\n* `id` {String}\n* Return: {Object} `module.exports` from the resolved module\n-->\n\n<ul>\n<li><code>id</code> {String}</li>\n<li>Return: {Object} 解決されたモジュールの <code>module.exports</code></li>\n</ul>\n<!--\nThe `module.require` method provides a way to load a module as if\n`require()` was called from the original module.\n-->\n\n<p><code>module.require</code> メソッドは、元のモジュールが <code>require()</code>\nを呼び出したかのようにモジュールをロードするために提供されています。\n\n</p>\n<!--\nNote that in order to do this, you must get a reference to the `module`\nobject.  Since `require()` returns the `module.exports`, and the `module` is\ntypically *only* available within a specific module's code, it must be\nexplicitly exported in order to be used.\n-->\n\n<p>それには <code>module</code> オブジェクトの参照が必要なことに注意してください。\n<code>require()</code> が <code>module.exports</code> を返した後、一般的に <code>module</code> \nはそのモジュールのコードで <em>のみ</em> 利用可能です。\nそれが使われるようにするには、明示的にエクスポートする必要があります。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "id"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "module"
    },
    {
      "textRaw": "Addons",
      "name": "addons",
      "desc": "<!--\nAddons are dynamically linked shared objects. They can provide glue to C and\nC++ libraries. The API (at the moment) is rather complex, involving\nknowledge of several libraries:\n-->\n\n<p>アドオンは動的に共有オブジェクトをリンクします。\nそれらは、C や C++ のライブラリに接合点を提供します。\nAPI はいくつかのライブラリの知識が必要で、(現時点では) かなり複雑です。\n\n</p>\n<!--\n - V8 JavaScript, a C++ library. Used for interfacing with JavaScript:\n   creating objects, calling functions, etc.  Documented mostly in the\n   `v8.h` header file (`deps/v8/include/v8.h` in the Node source\n   tree), which is also available\n   [online](http://izs.me/v8-docs/main.html).\n-->\n\n<ul>\n<li>V8 JavaScript は C++ のライブラリです。\nJavaScript のオブジェクト作成や関数呼び出し等のインタフェースに使用されます。\nドキュメントは主に、<code>v8.h</code> のヘッダファイル\n(Node のソースツリーの中の <code>deps/v8/include/v8.h</code>) に記されていますが、\n<a href="\"http://izs.me/v8-docs/main.html\"">オンライン</a> で参照することもできます。</li>\n</ul>\n<!--\n - [libuv](https://github.com/joyent/libuv), C event loop library.\n   Anytime one needs to wait for a file descriptor to become readable,\n   wait for a timer, or wait for a signal to be received one will need\n   to interface with libuv. That is, if you perform any I/O, libuv will\n   need to be used.\n-->\n\n<ul>\n<li><a href="\"https://github.com/joyent/libuv\"">libuv</a> は\nC のイベントループライブラリです。\nファイル記述子が読み取り可能になるのを待つとき、タイマーを待つとき、\nシグナルを受信するのを待つときはいつでも、\nlibv のインタフェースが必要になります。\nつまり、何らかの I/O 処理をすると必ず libuv を使う必要があるということです。</li>\n</ul>\n<!--\n - Internal Node libraries. Most importantly is the `node::ObjectWrap`\n   class which you will likely want to derive from.\n-->\n\n<ul>\n<li>Node の内部ライブラリ。\nもっとも重要なのは <code>node::ObjectWrap</code> クラスで、\nこのクラスから派生させることが多くなるでしょう。</li>\n</ul>\n<!--\n - Others. Look in `deps/` for what else is available.\n-->\n\n<ul>\n<li>その他。どのような物が利用できるかは <code>deps/</code> 以下を参照してさい。</li>\n</ul>\n<!--\nNode statically compiles all its dependencies into the executable.\nWhen compiling your module, you don't need to worry about linking to\nany of these libraries.\n-->\n\n<p>Node は全ての依存ライブラリを実行ファイルに静的にコンパイルします。\nモジュールのコンパイル時には、それらのリンクについて一切気にする必要は有りません。\n\n</p>\n<!--\nAll of the following examples are available for\n[download](https://github.com/rvagg/node-addon-examples) and may be\nused as a starting-point for your own Addon.\n-->\n\n<p>以下のサンプルの全ては\n<a href="\"https://github.com/rvagg/node-addon-examples\"">ダウンロード</a>\nから利用することができ、独自のアドオンの出発点になるでしょう。\n\n</p>\n",
      "modules": [
        {
          "textRaw": "Hello world",
          "name": "hello_world",
          "desc": "<!--\nTo get started let's make a small Addon which is the C++ equivalent of\nthe following JavaScript code:\n-->\n\n<p>では、 以下の JavaScript コードと同じ様に動作する小さなアドオンを\nC++ で作成してみましょう。\n\n</p>\n<pre><code>module.exports.hello = function() { return 'world'; };</code></pre>\n<!--\nFirst we create a file `hello.cc`:\n-->\n\n<p>最初に <code>hello.cc</code> というファイルを作成します:\n\n\n</p>\n<pre><code>#include <node.h>\n#include <v8.h>\n\nusing namespace v8;\n\nHandle<Value> Method(const Arguments& args) {\n  HandleScope scope;\n  return scope.Close(String::New("world"));\n}\n\nvoid init(Handle<Object> exports) {\n  exports->Set(String::NewSymbol("hello"),\n      FunctionTemplate::New(Method)->GetFunction());\n}\n\nNODE_MODULE(hello, init)</code></pre>\n<!--\nNote that all Node addons must export an initialization function:\n-->\n\n<p>全ての Node アドオンは初期化関数をエクスポートしなければならないことに\n注意してください。\n\n</p>\n<pre><code>void Initialize (Handle<Object> exports);\nNODE_MODULE(module_name, Initialize)</code></pre>\n<!--\nThere is no semi-colon after `NODE_MODULE` as it's not a function (see `node.h`).\n\nThe `module_name` needs to match the filename of the final binary (minus the\n.node suffix).\n\nThe source code needs to be built into `hello.node`, the binary Addon. To\ndo this we create a file called `binding.gyp` which describes the configuration\nto build your module in a JSON-like format. This file gets compiled by\n[node-gyp](https://github.com/TooTallNate/node-gyp).\n-->\n\n<p><code>NODE_MODULE</code> は関数ではないので、その後にセミコロンを付けてはいけません\n(<code>node.h</code> を参照してください)。\n\n</p>\n<p><code>module_name</code> は最終的なバイナリのファイル名 (拡張子 .node を除く)\nとマッチする必要があります。\n\n</p>\n<p>このソースコードは、<code>hello.node</code> というバイナリアドオンとしてビルドされる必要が有ります。\nそのために <code>binding.gyp</code> と呼ばれる、あなたのモジュールをビルドするための\n構成を JSON 的なフォーマットで記述したファイルを作成します。\nこのファイルは <a href="\"https://github.com/TooTallNate/node-gyp\"">node-gyp</a>\nによってコンパイルされます。\n\n</p>\n<pre><code>{\n  "targets": [\n    {\n      "target_name": "hello",\n      "sources": [ "hello.cc" ]\n    }\n  ]\n}</code></pre>\n<!--\nThe next step is to generate the appropriate project build files for the\ncurrent platform. Use `node-gyp configure` for that.\n-->\n\n<p>次のステップは現在のプラットフォームに適したプロジェクトビルドファイルを\n生成することです。\n<code>node-gyp configure</code> を使います。\n\n</p>\n<!--\nNow you will have either a `Makefile` (on Unix platforms) or a `vcxproj` file\n(on Windows) in the `build/` directory. Next invoke the `node-gyp build`\ncommand.\n-->\n\n<p>これで、<code>Makefile</code> (Unix プラットフォームの場合)、または <code>vcxproj</code> ファイル\n(Windows の場合) が <code>build/</code> ディレクトリに作られます。\n次に <code>node-gyp build</code> コマンドを起動します。\n\n</p>\n<!--\nNow you have your compiled `.node` bindings file! The compiled bindings end up\nin `build/Release/`.\n-->\n\n<p>これでコンパイルされた <code>.node</code> バインディングファイルが作成されます！\nコンパイルされたバインディングファイルは <code>build/Release/</code> にあります。\n\n</p>\n<!--\nYou can now use the binary addon in a Node project `hello.js` by pointing `require` to\nthe recently built `hello.node` module:\n-->\n\n<p>ビルドされた <code>hello.node</code> モジュールを <code>require</code> で指定することにより、\nこのバイナリアドオンを Node プロジェクトの <code>hello.js</code> から利用することが\n可能になります。\n\n</p>\n<pre><code>var addon = require('./build/Release/hello');\n\nconsole.log(addon.hello()); // 'world'</code></pre>\n<!--\nPlease see patterns below for further information or\n<https://github.com/arturadib/node-qt> for an example in production.\n-->\n\n<p>さらに詳しい情報については下記のパターンか、\n</p>\n<p><a href="\"https://github.com/arturadib/node-qt\"">https://github.com/arturadib/node-qt</a> を実際のプロダクトにおける\n例として参照してください。\n\n</p>\n",
          "type": "module",
          "displayName": "Hello world"
        },
        {
          "textRaw": "Addon patterns",
          "name": "addon_patterns",
          "desc": "<!--\nBelow are some addon patterns to help you get started. Consult the online\n[v8 reference](http://izs.me/v8-docs/main.html) for help with the various v8\ncalls, and v8's [Embedder's Guide](http://code.google.com/apis/v8/embed.html)\nfor an explanation of several concepts used such as handles, scopes,\nfunction templates, etc.\n-->\n\n<p>以下は初心者に役立つアドオンのパターンです。\nv8 の様々な API についてはオンラインの\n<a href="\"http://izs.me/v8-docs/main.html\"">v8 reference</a> が、\nそして ハンドルやスコープ、関数テンプレートなどいくつかの概念については\nv8 の <a href="\"http://code.google.com/apis/v8/embed.html\"">Embedder's Guide</a> が\n役に立つでしょう。\n\n</p>\n<!--\nIn order to use these examples you need to compile them using `node-gyp`.\nCreate the following `binding.gyp` file:\n-->\n\n<p>このサンプルを利用できるようにするには、<code>node-gyp</code> を使用して\nコンパイルする必要があります。\n以下の <code>binding.gyp</code> ファイルを作成します。\n\n</p>\n<pre><code>{\n  "targets": [\n    {\n      "target_name": "addon",\n      "sources": [ "addon.cc" ]\n    }\n  ]\n}</code></pre>\n<!--\nIn cases where there is more than one `.cc` file, simply add the file name to the\n`sources` array, e.g.:\n-->\n\n<p>一つ以上の <code>.cc</code> ファイルがある場合は、単純に <code>sources</code> 配列にファイル名を\n加えるだけです。例:\n\n</p>\n<pre><code>"sources": ["addon.cc", "myexample.cc"]</code></pre>\n<!--\nNow that you have your `binding.gyp` ready, you can configure and build the\naddon:\n-->\n\n<p>これで <code>binding.gyp</code> の準備ができました。\nアドオンをコンフィギュアおよびビルドするには:\n\n</p>\n<pre><code>$ node-gyp configure build</code></pre>\n",
          "modules": [
            {
              "textRaw": "Function arguments",
              "name": "function_arguments",
              "desc": "<!--\nThe following pattern illustrates how to read arguments from JavaScript\nfunction calls and return a result. This is the main and only needed source\n`addon.cc`:\n-->\n\n<p>以下のパターンは JavaScript から呼び出された関数で引数を読み出したり、\n結果を返す方法を示します。これは <code>addon.cc</code> でのみ必要となります。\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include <node.h>\n\nusing namespace v8;\n\nHandle<Value> Add(const Arguments& args) {\n  HandleScope scope;\n\n  if (args.Length() < 2) {\n    ThrowException(Exception::TypeError(String::New("Wrong number of arguments")));\n    return scope.Close(Undefined());\n  }\n\n  if (!args[0]->IsNumber() || !args[1]->IsNumber()) {\n    ThrowException(Exception::TypeError(String::New("Wrong arguments")));\n    return scope.Close(Undefined());\n  }\n\n  Local<Number> num = Number::New(args[0]->NumberValue() +\n      args[1]->NumberValue());\n  return scope.Close(num);\n}\n\nvoid Init(Handle<Object> exports) {\n  exports->Set(String::NewSymbol("add"),\n      FunctionTemplate::New(Add)->GetFunction());\n}\n\nNODE_MODULE(addon, Init)</code></pre>\n<!--\nYou can test it with the following JavaScript snippet:\n-->\n\n<p>以下の JavaScript コード片でテストすることができます。\n\n</p>\n<pre><code>var addon = require('./build/Release/addon');\n\nconsole.log( 'This should be eight:', addon.add(3,5) );</code></pre>\n",
              "type": "module",
              "displayName": "Function arguments"
            },
            {
              "textRaw": "Callbacks",
              "name": "callbacks",
              "desc": "<!--\nYou can pass JavaScript functions to a C++ function and execute them from\nthere. Here's `addon.cc`:\n-->\n\n<p>JavaScript の関数を C++ の関数に渡してそこから呼び出すことができます。\nこれは <code>addon.cc</code> です:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include <node.h>\n\nusing namespace v8;\n\nHandle<Value> RunCallback(const Arguments& args) {\n  HandleScope scope;\n\n  Local<Function> cb = Local<Function>::Cast(args[0]);\n  const unsigned argc = 1;\n  Local<Value> argv[argc] = { Local<Value>::New(String::New("hello world")) };\n  cb->Call(Context::GetCurrent()->Global(), argc, argv);\n\n  return scope.Close(Undefined());\n}\n\nvoid Init(Handle<Object> exports, Handle<Object> module) {\n  module->Set(String::NewSymbol("exports"),\n      FunctionTemplate::New(RunCallback)->GetFunction());\n}\n\nNODE_MODULE(addon, Init)</code></pre>\n<!--\nNote that this example uses a two-argument form of `Init()` that receives\nthe full `module` object as the second argument. This allows the addon\nto completely overwrite `exports` with a single function instead of\nadding the function as a property of `exports`.\n-->\n\n<p>この例は二つの引数を取る形式の <code>Init()</code> を使用して、第2引数で完全な <code>module</code>\nオブジェクトを受け取っていることに注意してください。\nこれは、<code>exports</code> のプロパティとして関数を加える代わりに、アドオンが\n一つの関数で <code>exports</code> を完全に上書きすることを可能にします。\n\n</p>\n<!--\nTo test it run the following JavaScript snippet:\n-->\n\n<p>以下の JavaScript コード片でテストすることができます。\n\n</p>\n<pre><code>var addon = require('./build/Release/addon');\n\naddon(function(msg){\n  console.log(msg); // 'hello world'\n});</code></pre>\n",
              "type": "module",
              "displayName": "Callbacks"
            },
            {
              "textRaw": "Object factory",
              "name": "object_factory",
              "desc": "<!--\nYou can create and return new objects from within a C++ function with this\n`addon.cc` pattern, which returns an object with property `msg` that echoes\nthe string passed to `createObject()`:\n-->\n\n<p>C++ 関数の中から新しいオブジェクトを作成して返すことができます。\n以下の <code>addon.cc</code> のパターンでは、<code>createObject()</code> に渡された文字列を\n反映する <code>msg</code> プロパティを持ったオブジェクトを返します。\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include <node.h>\n\nusing namespace v8;\n\nHandle<Value> CreateObject(const Arguments& args) {\n  HandleScope scope;\n\n  Local<Object> obj = Object::New();\n  obj->Set(String::NewSymbol("msg"), args[0]->ToString());\n\n  return scope.Close(obj);\n}\n\nvoid Init(Handle<Object> exports, Handle<Object> module) {\n  module->Set(String::NewSymbol("exports"),\n      FunctionTemplate::New(CreateObject)->GetFunction());\n}\n\nNODE_MODULE(addon, Init)</code></pre>\n<!--\nTo test it in JavaScript:\n-->\n\n<p>テスト用の JavaScript:\n\n</p>\n<pre><code>var addon = require('./build/Release/addon');\n\nvar obj1 = addon('hello');\nvar obj2 = addon('world');\nconsole.log(obj1.msg+' '+obj2.msg); // 'hello world'</code></pre>\n",
              "type": "module",
              "displayName": "Object factory"
            },
            {
              "textRaw": "Function factory",
              "name": "function_factory",
              "desc": "<!--\nThis pattern illustrates how to create and return a JavaScript function that\nwraps a C++ function:\n-->\n\n<p>このパターンは C++ 関数をラップした JavaScript 関数を作成して返す方法を\n示します。\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include <node.h>\n\nusing namespace v8;\n\nHandle<Value> MyFunction(const Arguments& args) {\n  HandleScope scope;\n  return scope.Close(String::New("hello world"));\n}\n\nHandle<Value> CreateFunction(const Arguments& args) {\n  HandleScope scope;\n\n  Local<FunctionTemplate> tpl = FunctionTemplate::New(MyFunction);\n  Local<Function> fn = tpl->GetFunction();\n  fn->SetName(String::NewSymbol("theFunction")); // omit this to make it anonymous\n\n  return scope.Close(fn);\n}\n\nvoid Init(Handle<Object> exports, Handle<Object> module) {\n  module->Set(String::NewSymbol("exports"),\n      FunctionTemplate::New(CreateFunction)->GetFunction());\n}\n\nNODE_MODULE(addon, Init)</code></pre>\n<!--\nTo test:\n-->\n\n<p>テスト:\n\n</p>\n<pre><code>var addon = require('./build/Release/addon');\n\nvar fn = addon();\nconsole.log(fn()); // 'hello world'</code></pre>\n",
              "type": "module",
              "displayName": "Function factory"
            },
            {
              "textRaw": "Wrapping C++ objects",
              "name": "wrapping_c++_objects",
              "desc": "<!--\nHere we will create a wrapper for a C++ object/class `MyObject` that can be\ninstantiated in JavaScript through the `new` operator. First prepare the main\nmodule `addon.cc`:\n-->\n\n<p>ここでは、\nC++ オブジェクト／クラスをラップし、JavaScript から new 演算子を使って\nインスタンス化できる <code>MyObject</code> を作成します。\n最初にメインモジュール <code>addon.cc</code> を準備します:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include <node.h>\n#include "myobject.h"\n\nusing namespace v8;\n\nvoid InitAll(Handle<Object> exports) {\n  MyObject::Init(exports);\n}\n\nNODE_MODULE(addon, InitAll)</code></pre>\n<!--\nThen in `myobject.h` make your wrapper inherit from `node::ObjectWrap`:\n-->\n\n<p>次に、<code>node::ObjectWrap</code> を継承したラッパーを <code>myobject.h</code> に作成します。\n\n</p>\n<pre><code>#ifndef MYOBJECT_H\n#define MYOBJECT_H\n\n#include <node.h>\n\nclass MyObject : public node::ObjectWrap {\n public:\n  static void Init(v8::Handle<v8::Object> exports);\n\n private:\n  explicit MyObject(double value = 0);\n  ~MyObject();\n\n  static v8::Handle<v8::Value> New(const v8::Arguments& args);\n  static v8::Handle<v8::Value> PlusOne(const v8::Arguments& args);\n  static v8::Persistent<v8::Function> constructor;\n  double value_;\n};\n\n#endif</code></pre>\n<!--\nAnd in `myobject.cc` implement the various methods that you want to expose.\nHere we expose the method `plusOne` by adding it to the constructor's\nprototype:\n-->\n\n<p>公開したい様々なメソッドを <code>myobject.cc</code> に実装します。\nここでは、コンストラクタに渡された値に加算する <code>plusOne</code> を公開しています:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include <node.h>\n#include "myobject.h"\n\nusing namespace v8;\n\nPersistent<Function> MyObject::constructor;\n\nMyObject::MyObject(double value) : value_(value) {\n}\n\nMyObject::~MyObject() {\n}\n\nvoid MyObject::Init(Handle<Object> exports) {\n  // Prepare constructor template\n  Local<FunctionTemplate> tpl = FunctionTemplate::New(New);\n  tpl->SetClassName(String::NewSymbol("MyObject"));\n  tpl->InstanceTemplate()->SetInternalFieldCount(1);\n  // Prototype\n  tpl->PrototypeTemplate()->Set(String::NewSymbol("plusOne"),\n      FunctionTemplate::New(PlusOne)->GetFunction());\n  constructor = Persistent<Function>::New(tpl->GetFunction());\n  exports->Set(String::NewSymbol("MyObject"), constructor);\n}\n\nHandle<Value> MyObject::New(const Arguments& args) {\n  HandleScope scope;\n\n  if (args.IsConstructCall()) {\n    // Invoked as constructor: `new MyObject(...)`\n    double value = args[0]->IsUndefined() ? 0 : args[0]->NumberValue();\n    MyObject* obj = new MyObject(value);\n    obj->Wrap(args.This());\n    return args.This();\n  } else {\n    // Invoked as plain function `MyObject(...)`, turn into construct call.\n    const int argc = 1;\n    Local<Value> argv[argc] = { args[0] };\n    return scope.Close(constructor->NewInstance(argc, argv));\n  }\n}\n\nHandle<Value> MyObject::PlusOne(const Arguments& args) {\n  HandleScope scope;\n\n  MyObject* obj = ObjectWrap::Unwrap<MyObject>(args.This());\n  obj->value_ += 1;\n\n  return scope.Close(Number::New(obj->value_));\n}</code></pre>\n<!--\nTest it with:\n-->\n\n<p>これでテストします:\n\n</p>\n<pre><code>var addon = require('./build/Release/addon');\n\nvar obj = new addon.MyObject(10);\nconsole.log( obj.plusOne() ); // 11\nconsole.log( obj.plusOne() ); // 12\nconsole.log( obj.plusOne() ); // 13</code></pre>\n",
              "type": "module",
              "displayName": "Wrapping C++ objects"
            },
            {
              "textRaw": "Factory of wrapped objects",
              "name": "factory_of_wrapped_objects",
              "desc": "<!--\nThis is useful when you want to be able to create native objects without\nexplicitly instantiating them with the `new` operator in JavaScript, e.g.\n-->\n\n<p>JavaScript の <code>new</code> 演算子で明示的にインスタンス化することなく、\nネイティブオブジェクトを作成できるようにしたい場合に便利です。例:\n\n</p>\n<pre><code>var obj = addon.createObject();\n// instead of:\n// var obj = new addon.Object();</code></pre>\n<!--\nLet's register our `createObject` method in `addon.cc`:\n-->\n\n<p>createObject<code> を </code>addon.cc` に登録しましょう:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include <node.h>\n#include "myobject.h"\n\nusing namespace v8;\n\nHandle<Value> CreateObject(const Arguments& args) {\n  HandleScope scope;\n  return scope.Close(MyObject::NewInstance(args));\n}\n\nvoid InitAll(Handle<Object> exports, Handle<Object> module) {\n  MyObject::Init();\n\n  module->Set(String::NewSymbol("exports"),\n      FunctionTemplate::New(CreateObject)->GetFunction());\n}\n\nNODE_MODULE(addon, InitAll)</code></pre>\n<!--\nIn `myobject.h` we now introduce the static method `NewInstance` that takes\ncare of instantiating the object (i.e. it does the job of `new` in JavaScript):\n-->\n\n<p><code>myobject.h</code> にオブジェクトを生成する static メソッド <code>NewInstance</code> を\n導入しましょう (すなわち，それが JavaScript 内の <code>new</code> の働きをします)。\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#ifndef MYOBJECT_H\n#define MYOBJECT_H\n\n#include <node.h>\n\nclass MyObject : public node::ObjectWrap {\n public:\n  static void Init();\n  static v8::Handle<v8::Value> NewInstance(const v8::Arguments& args);\n\n private:\n  explicit MyObject(double value = 0);\n  ~MyObject();\n\n  static v8::Handle<v8::Value> New(const v8::Arguments& args);\n  static v8::Handle<v8::Value> PlusOne(const v8::Arguments& args);\n  static v8::Persistent<v8::Function> constructor;\n  double value_;\n};\n\n#endif</code></pre>\n<!--\nThe implementation is similar to the above in `myobject.cc`:\n-->\n\n<p>実装は前述の <code>myobject.cc</code> と同様です:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include <node.h>\n#include "myobject.h"\n\nusing namespace v8;\n\nPersistent<Function> MyObject::constructor;\n\nMyObject::MyObject(double value) : value_(value) {\n}\n\nMyObject::~MyObject() {\n}\n\nvoid MyObject::Init() {\n  // Prepare constructor template\n  Local<FunctionTemplate> tpl = FunctionTemplate::New(New);\n  tpl->SetClassName(String::NewSymbol("MyObject"));\n  tpl->InstanceTemplate()->SetInternalFieldCount(1);\n  // Prototype\n  tpl->PrototypeTemplate()->Set(String::NewSymbol("plusOne"),\n      FunctionTemplate::New(PlusOne)->GetFunction());\n  constructor = Persistent<Function>::New(tpl->GetFunction());\n}\n\nHandle<Value> MyObject::New(const Arguments& args) {\n  HandleScope scope;\n\n  if (args.IsConstructCall()) {\n    // Invoked as constructor: `new MyObject(...)`\n    double value = args[0]->IsUndefined() ? 0 : args[0]->NumberValue();\n    MyObject* obj = new MyObject(value);\n    obj->Wrap(args.This());\n    return args.This();\n  } else {\n    // Invoked as plain function `MyObject(...)`, turn into construct call.\n    const int argc = 1;\n    Local<Value> argv[argc] = { args[0] };\n    return scope.Close(constructor->NewInstance(argc, argv));\n  }\n}\n\nHandle<Value> MyObject::NewInstance(const Arguments& args) {\n  HandleScope scope;\n\n  const unsigned argc = 1;\n  Handle<Value> argv[argc] = { args[0] };\n  Local<Object> instance = constructor->NewInstance(argc, argv);\n\n  return scope.Close(instance);\n}\n\nHandle<Value> MyObject::PlusOne(const Arguments& args) {\n  HandleScope scope;\n\n  MyObject* obj = ObjectWrap::Unwrap<MyObject>(args.This());\n  obj->value_ += 1;\n\n  return scope.Close(Number::New(obj->value_));\n}</code></pre>\n<!--\nTest it with:\n-->\n\n<p>これでテストします:\n\n</p>\n<pre><code>var createObject = require('./build/Release/addon');\n\nvar obj = createObject(10);\nconsole.log( obj.plusOne() ); // 11\nconsole.log( obj.plusOne() ); // 12\nconsole.log( obj.plusOne() ); // 13\n\nvar obj2 = createObject(20);\nconsole.log( obj2.plusOne() ); // 21\nconsole.log( obj2.plusOne() ); // 22\nconsole.log( obj2.plusOne() ); // 23</code></pre>\n",
              "type": "module",
              "displayName": "Factory of wrapped objects"
            },
            {
              "textRaw": "Passing wrapped objects around",
              "name": "passing_wrapped_objects_around",
              "desc": "<!--\nIn addition to wrapping and returning C++ objects, you can pass them around\nby unwrapping them with Node's `node::ObjectWrap::Unwrap` helper function.\nIn the following `addon.cc` we introduce a function `add()` that can take on two\n`MyObject` objects:\n-->\n\n<p>C++ オブジェクトをラップして返すことに加えて、Node が提供するヘルパ関数\n<code>node::ObjectWrap::Unwrap</code> を使用してアンラップすることもできます。\n以下の <code>addon.cc</code> では、二つの <code>MyObject</code> オブジェクトを受け取る <code>add()</code>\n関数を導入します:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include <node.h>\n#include "myobject.h"\n\nusing namespace v8;\n\nHandle<Value> CreateObject(const Arguments& args) {\n  HandleScope scope;\n  return scope.Close(MyObject::NewInstance(args));\n}\n\nHandle<Value> Add(const Arguments& args) {\n  HandleScope scope;\n\n  MyObject* obj1 = node::ObjectWrap::Unwrap<MyObject>(\n      args[0]->ToObject());\n  MyObject* obj2 = node::ObjectWrap::Unwrap<MyObject>(\n      args[1]->ToObject());\n\n  double sum = obj1->Value() + obj2->Value();\n  return scope.Close(Number::New(sum));\n}\n\nvoid InitAll(Handle<Object> exports) {\n  MyObject::Init();\n\n  exports->Set(String::NewSymbol("createObject"),\n      FunctionTemplate::New(CreateObject)->GetFunction());\n\n  exports->Set(String::NewSymbol("add"),\n      FunctionTemplate::New(Add)->GetFunction());\n}\n\nNODE_MODULE(addon, InitAll)</code></pre>\n<!--\nTo make things interesting we introduce a public method in `myobject.h` so we\ncan probe private values after unwrapping the object:\n-->\n\n<p>よりおもしろくするために、<code>myobject.h</code> にパブリックメソッドを導入しましょう。\nしたがって、アンラップされたオブジェクトのプライベート変数を調べることが\nできます。\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#ifndef MYOBJECT_H\n#define MYOBJECT_H\n\n#include <node.h>\n\nclass MyObject : public node::ObjectWrap {\n public:\n  static void Init();\n  static v8::Handle<v8::Value> NewInstance(const v8::Arguments& args);\n  double Value() const { return value_; }\n\n private:\n  explicit MyObject(double value = 0);\n  ~MyObject();\n\n  static v8::Handle<v8::Value> New(const v8::Arguments& args);\n  static v8::Persistent<v8::Function> constructor;\n  double value_;\n};\n\n#endif</code></pre>\n<!--\nThe implementation of `myobject.cc` is similar as before:\n-->\n\n<p><code>myobject.cc</code> の実装はこれまでと同様です:\n\n</p>\n<pre><code>#define BUILDING_NODE_EXTENSION\n#include <node.h>\n#include "myobject.h"\n\nusing namespace v8;\n\nPersistent<Function> MyObject::constructor;\n\nMyObject::MyObject(double value) : value_(value) {\n}\n\nMyObject::~MyObject() {\n}\n\nvoid MyObject::Init() {\n  // Prepare constructor template\n  Local<FunctionTemplate> tpl = FunctionTemplate::New(New);\n  tpl->SetClassName(String::NewSymbol("MyObject"));\n  tpl->InstanceTemplate()->SetInternalFieldCount(1);\n  constructor = Persistent<Function>::New(tpl->GetFunction());\n}\n\nHandle<Value> MyObject::New(const Arguments& args) {\n  HandleScope scope;\n\n  if (args.IsConstructCall()) {\n    // Invoked as constructor: `new MyObject(...)`\n    double value = args[0]->IsUndefined() ? 0 : args[0]->NumberValue();\n    MyObject* obj = new MyObject(value);\n    obj->Wrap(args.This());\n    return args.This();\n  } else {\n    // Invoked as plain function `MyObject(...)`, turn into construct call.\n    const int argc = 1;\n    Local<Value> argv[argc] = { args[0] };\n    return scope.Close(constructor->NewInstance(argc, argv));\n  }\n}\n\nHandle<Value> MyObject::NewInstance(const Arguments& args) {\n  HandleScope scope;\n\n  const unsigned argc = 1;\n  Handle<Value> argv[argc] = { args[0] };\n  Local<Object> instance = constructor->NewInstance(argc, argv);\n\n  return scope.Close(instance);\n}</code></pre>\n<!--\nTest it with:\n-->\n\n<p>これでテストします:\n\n</p>\n<pre><code>var addon = require('./build/Release/addon');\n\nvar obj1 = addon.createObject(10);\nvar obj2 = addon.createObject(20);\nvar result = addon.add(obj1, obj2);\n\nconsole.log(result); // 30</code></pre>\n",
              "type": "module",
              "displayName": "Passing wrapped objects around"
            }
          ],
          "type": "module",
          "displayName": "Addon patterns"
        }
      ],
      "type": "module",
      "displayName": "Addons"
    },
    {
      "textRaw": "util",
      "name": "util",
      "stability": 4,
      "stabilityText": "API Frozen",
      "desc": "<!--\nThese functions are in the module `'util'`. Use `require('util')` to access\nthem.\n-->\n\n<p>これらの関数はモジュール <code>'util'</code> 内にあります。\n<code>require('util')</code> を使うことでこれらにアクセスします。\n\n\n</p>\n",
      "methods": [
        {
          "textRaw": "util.format(format, [...])",
          "type": "method",
          "name": "format",
          "desc": "<!--\nReturns a formatted string using the first argument as a `printf`-like format.\n-->\n\n<p>最初の引数を <code>printf</code> のようなフォーマットとして使用して、フォーマット化された\n文字列を返します。\n\n</p>\n<!--\nThe first argument is a string that contains zero or more *placeholders*.\nEach placeholder is replaced with the converted value from its corresponding\nargument. Supported placeholders are:\n-->\n\n<p>第一引数は文字列で、0 個以上の <em>プレースホルダ</em> を含みます。\nそれぞれのプレースホルダは対応する引数を変換した値で置換されます。\nサポートするプレースホルダは:\n\n</p>\n<!--\n* `%s` - String.\n* `%d` - Number (both integer and float).\n* `%j` - JSON.\n* `%` - single percent sign (`'%'`). This does not consume an argument.\n-->\n\n<ul>\n<li><code>%s</code> - 文字列。</li>\n<li><code>%d</code> - 数値 (整数と浮動小数点数の両方)。</li>\n<li><code>%j</code> - JSON。</li>\n<li><code>%</code> - 一つのパーセント記号 (<code>'%'</code>)。これは引数を消費しません。</li>\n</ul>\n<!--\nIf the placeholder does not have a corresponding argument, the placeholder is\nnot replaced.\n-->\n\n<p>プレースホルダに対応する引数が無い場合、そのプレースホルダは置換されません。\n\n</p>\n<pre><code>util.format('%s:%s', 'foo'); // 'foo:%s'</code></pre>\n<!--\nIf there are more arguments than placeholders, the extra arguments are\nconverted to strings with `util.inspect()` and these strings are concatenated,\ndelimited by a space.\n-->\n\n<p>プレースホルダより多くの引数がある場合、余った引数は <code>util.inspect()</code> によって\n文字列化され、それらはスペース区切りで連結されます。\n\n</p>\n<pre><code>util.format('%s:%s', 'foo', 'bar', 'baz'); // 'foo:bar baz'</code></pre>\n<!--\nIf the first argument is not a format string then `util.format()` returns\na string that is the concatenation of all its arguments separated by spaces.\nEach argument is converted to a string with `util.inspect()`.\n-->\n\n<p>第一引数がフォーマット文字列ではない場合、<code>util.format()</code> は全ての引数を\nスペース区切りで連結して返します。\nここの引数は <code>util.inspect()</code> で文字列に変換されます。\n\n</p>\n<pre><code>util.format(1, 2, 3); // '1 2 3'</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "format"
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.debug(string)",
          "type": "method",
          "name": "debug",
          "desc": "<!--\nA synchronous output function. Will block the process and\noutput `string` immediately to `stderr`.\n-->\n\n<p>同期的な出力関数です。\nプロセスをブロックして即座に <code>string</code> を <code>stderr</code> に出力します。\n\n</p>\n<pre><code>require('util').debug('message on stderr');</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "string"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.error([...])",
          "type": "method",
          "name": "error",
          "desc": "<!--\nSame as `util.debug()` except this will output all arguments immediately to\n`stderr`.\n-->\n\n<p>全ての引数をすぐに <code>stderr</code> に出力することを除いて <code>util.debug()</code> と同じです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.puts([...])",
          "type": "method",
          "name": "puts",
          "desc": "<!--\nA synchronous output function. Will block the process and output all arguments\nto `stdout` with newlines after each argument.\n-->\n\n<p>同期的な出力関数です。\nプロセスをブロックして即座に <code>stdout</code> に出力します。\n各引数は改行が付加されます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.print([...])",
          "type": "method",
          "name": "print",
          "desc": "<!--\nA synchronous output function. Will block the process, cast each argument to a\nstring then output to `stdout`. Does not place newlines after each argument.\n-->\n\n<p>同期的な出力関数です。\nプロセスをブロックして、引数を文字列に変換して <code>stdout</code> に出力します。\n各引数に改行は付加されません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.log(string)",
          "type": "method",
          "name": "log",
          "desc": "<!--\nOutput with timestamp on `stdout`.\n-->\n\n<p>タイムスタンプとともに <code>stdout</code> へ出力します。\n\n</p>\n<pre><code>require('util').log('Timestamped message.');</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "string"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.inspect(object, [options])",
          "type": "method",
          "name": "inspect",
          "desc": "<!--\nReturn a string representation of `object`, which is useful for debugging.\n-->\n\n<p>デバッグで有用な、<code>object</code> の文字列表現を返します。\n\n</p>\n<!--\nAn optional *options* object may be passed that alters certain aspects of the\nformatted string:\n-->\n\n<p>オプションの <em>options</em> オブジェクトは、フォーマット化された文字列の\n特定の側面を変更するために渡すことができます。\n\n</p>\n<!--\n - `showHidden` - if `true` then the object's non-enumerable properties will be\n   shown too. Defaults to `false`.\n-->\n\n<ul>\n<li><code>showHidden</code> - <code>true</code> の場合、\nオブジェクトの Enumerable でないプロパティも表示されます。\nデフォルトは <code>false</code> です。</li>\n</ul>\n<!--\n - `depth` - tells `inspect` how many times to recurse while formatting the\n   object. This is useful for inspecting large complicated objects. Defaults to\n   `2`. To make it recurse indefinitely pass `null`.\n-->\n\n<ul>\n<li><code>depth</code> - オブジェクトをフォーマットするために何回再帰するかを\n<code>inspect</code> に伝えます。\nこれは巨大で複雑なオブジェクトを調査する場合に便利です。\nデフォルトは <code>2</code> です。\n無限に再帰するには、<code>null</code> を渡します。</li>\n</ul>\n<!--\n - `colors` - if `true`, then the output will be styled with ANSI color codes.\n   Defaults to `false`. Colors are customizable, see below.\n-->\n\n<ul>\n<li><code>colors</code> - <code>true</code> の場合、出力は ANSI カラーコードで色づけされます。\nデフォルトは <code>false</code> です。\n後述するように、色はカスタマイズ可能です。</li>\n</ul>\n<!--\n - `customInspect` - if `false`, then custom `inspect()` functions defined on the\n   objects being inspected won't be called. Defaults to `true`.\n-->\n\n<ul>\n<li><code>customInspect</code> - <code>false</code> の場合、オブジェクト独自の <code>inspect()</code> 関数は\n呼び出されません。デフォルトは <code>false</code> です。</li>\n</ul>\n<!--\nExample of inspecting all properties of the `util` object:\n-->\n\n<p><code>util</code> オブジェクトの全てのプロパティを調査する例:\n\n</p>\n<pre><code>var util = require('util');\n\nconsole.log(util.inspect(util, { showHidden: true, depth: null }));</code></pre>\n",
          "modules": [
            {
              "textRaw": "Customizing `util.inspect` colors",
              "name": "customizing_`util.inspect`_colors",
              "desc": "<!--\nColor output (if enabled) of `util.inspect` is customizable globally\nvia `util.inspect.styles` and `util.inspect.colors` objects.\n-->\n\n<p><code>util.inspect</code> が出力する色は、(有効であれば) <code>util.inspect.styles</code> および\n<code>util.inspect.colors</code> オブジェクトを通じてグローバルにカスタマイズすることが\n可能です。\n\n</p>\n<!--\n`util.inspect.styles` is a map assigning each style a color\nfrom `util.inspect.colors`.\nHighlighted styles and their default values are:\n-->\n\n<p><code>util.inspect.styles</code> は各スタイルと <code>util.inspect.colors</code> に\n定義された色を割り当てたマッピングです。\n強調されるスタイルとそれらのデフォルト値は:\n\n</p>\n<!--\n * `number` (yellow)\n * `boolean` (yellow)\n * `string` (green)\n * `date` (magenta)\n * `regexp` (red)\n * `null` (bold)\n * `undefined` (grey)\n * `special` - only function at this time (cyan)\n * `name` (intentionally no styling)\n-->\n\n<ul>\n<li><code>number</code> (黄)</li>\n<li><code>boolean</code> (黄)</li>\n<li><code>string</code> (緑)</li>\n<li><code>date</code> (紫)</li>\n<li><code>regexp</code> (赤)</li>\n<li><code>null</code> (太字)</li>\n<li><code>undefined</code> (灰)</li>\n<li><code>special</code> - only function at this time (水色)</li>\n<li><code>name</code> (意図的にスタイル無し)</li>\n</ul>\n<!--\nPredefined color codes are: `white`, `grey`, `black`, `blue`, `cyan`, \n`green`, `magenta`, `red` and `yellow`.\nThere are also `bold`, `italic`, `underline` and `inverse` codes.\n-->\n\n<p>事前に定義された色は: <code>white</code>、<code>grey</code>、<code>black</code>、<code>blue</code>、<code>cyan</code>、\n<code>green</code>、<code>magenta</code>、<code>red</code>、および <code>yellow</code> です。\n<code>bold</code>、<code>italic</code>、<code>underline</code>、および <code>inverse</code> コードを使うこともできます。\n\n</p>\n<!--\nObjects also may define their own `inspect(depth)` function which `util.inspect()`\nwill invoke and use the result of when inspecting the object:\n-->\n\n<p>オブジェクトは <code>util.inspect()</code> から呼び出される自前の <code>inspect(depth)</code>\n関数を持つことができ、その結果はオブジェクトを調査するために使われます。\n\n</p>\n<pre><code>var util = require('util');\n\nvar obj = { name: 'nate' };\nobj.inspect = function(depth) {\n  return '{' + this.name + '}';\n};\n\nutil.inspect(obj);\n  // "{nate}"</code></pre>\n",
              "type": "module",
              "displayName": "Customizing `util.inspect` colors"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isArray(object)",
          "type": "method",
          "name": "isArray",
          "desc": "<!--\nReturns `true` if the given \"object\" is an `Array`. `false` otherwise.\n-->\n\n<p><code>object</code> が配列なら <code>true</code> を、それ以外は <code>false</code> を返します。\n\n</p>\n<pre><code>var util = require('util');\n\nutil.isArray([])\n  // true\nutil.isArray(new Array)\n  // true\nutil.isArray({})\n  // false</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isRegExp(object)",
          "type": "method",
          "name": "isRegExp",
          "desc": "<!--\nReturns `true` if the given \"object\" is a `RegExp`. `false` otherwise.\n-->\n\n<p><code>object</code> が <code>RegExp</code> なら <code>true</code> を、それ以外なら <code>false</code> を返します。\n\n</p>\n<pre><code>var util = require('util');\n\nutil.isRegExp(/some regexp/)\n  // true\nutil.isRegExp(new RegExp('another regexp'))\n  // true\nutil.isRegExp({})\n  // false</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isDate(object)",
          "type": "method",
          "name": "isDate",
          "desc": "<!--\nReturns `true` if the given \"object\" is a `Date`. `false` otherwise.\n-->\n\n<p><code>object</code> が <code>Date</code> なら <code>true</code> を、それ以外なら <code>false</code> を返します。\n\n</p>\n<pre><code>var util = require('util');\n\nutil.isDate(new Date())\n  // true\nutil.isDate(Date())\n  // false (without 'new' returns a String)\nutil.isDate({})\n  // false</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isError(object)",
          "type": "method",
          "name": "isError",
          "desc": "<!--\nReturns `true` if the given \"object\" is an `Error`. `false` otherwise.\n-->\n\n<p><code>object</code> が <code>Error</code> なら <code>true</code> を、それ以外なら <code>false</code> を返します。\n\n</p>\n<pre><code>var util = require('util');\n\nutil.isError(new Error())\n  // true\nutil.isError(new TypeError())\n  // true\nutil.isError({ name: 'Error', message: 'an error occurred' })\n  // false</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.pump(readableStream, writableStream, [callback])",
          "type": "method",
          "name": "pump",
          "desc": "<!--\n    Stability: 0 - Deprecated: Use readableStream.pipe(writableStream)\n-->\n\n<pre><code>Stability: 0 - Deprecated: `readableStream.pipe(writableStream)` を使ってください。</code></pre>\n<!--\nRead the data from `readableStream` and send it to the `writableStream`.\nWhen `writableStream.write(data)` returns `false` `readableStream` will be\npaused until the `drain` event occurs on the `writableStream`. `callback` gets\nan error as its only argument and is called when `writableStream` is closed or\nwhen an error occurs.\n-->\n\n<p><code>readableStream</code> からデータを読み、それ を<code>writableStream</code> に送ります。\n<code>writableStream.write(data)</code> が <code>false</code> を返す場合、\n<code>writableStream</code> が <code>drain</code> イベントを生成するまで、\n<code>readableStream</code> は中断します。\n<code>writableStream</code> がクローズされるかエラーが発生すると、<code>callback</code> は error を唯一の引数として呼び出されます。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "readableStream"
                },
                {
                  "name": "writableStream"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.inherits(constructor, superConstructor)",
          "type": "method",
          "name": "inherits",
          "desc": "<!--\nInherit the prototype methods from one\n[constructor](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/constructor)\ninto another.  The prototype of `constructor` will be set to a new\nobject created from `superConstructor`.\n-->\n\n<p>ある\n<a href="\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/constructor\"">コンストラクタ</a>\nからプロトタイプメソッドを継承します。\n<code>constructor</code> のプロトタイプは <code>superConstructor</code> から作られたオブジェクトに設定されます。\n\n</p>\n<!--\nAs an additional convenience, `superConstructor` will be accessible\nthrough the `constructor.super_` property.\n-->\n\n<p>さらなる利便性のために、<code>superConstructor</code> は <code>constructor.super_</code>\nプロパティを通じてアクセスすることができるようになります。\n\n</p>\n<pre><code>var util = require("util");\nvar events = require("events");\n\nfunction MyStream() {\n    events.EventEmitter.call(this);\n}\n\nutil.inherits(MyStream, events.EventEmitter);\n\nMyStream.prototype.write = function(data) {\n    this.emit("data", data);\n}\n\nvar stream = new MyStream();\n\nconsole.log(stream instanceof events.EventEmitter); // true\nconsole.log(MyStream.super_ === events.EventEmitter); // true\n\nstream.on("data", function(data) {\n    console.log('Received data: "' + data + '"');\n})\nstream.write("It works!"); // Received data: "It works!"</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "constructor"
                },
                {
                  "name": "superConstructor"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "util"
    },
    {
      "textRaw": "Events",
      "name": "Events",
      "stability": 4,
      "stabilityText": "API Frozen",
      "type": "module",
      "desc": "<!--\nMany objects in Node emit events: a `net.Server` emits an event each time\na peer connects to it, a `fs.readStream` emits an event when the file is\nopened. All objects which emit events are instances of `events.EventEmitter`.\nYou can access this module by doing: `require(\"events\");`\n-->\n\n<p>Node のオブジェクトの多くはイベントを生成します:\n<code>net.Server</code>は相手から接続するたびにイベントを生成し、\n<code>fs.readStream</code>はファイルがオープンされるたびにイベントを生成します。\nイベントを生成する全てのオブジェクトは <code>events.EventEmitter</code> のインスタンスです。\n次のようにすることでこのモジュールにアクセスできます: <code>require("events");</code>\n\n</p>\n<!--\nTypically, event names are represented by a camel-cased string, however,\nthere aren't any strict restrictions on that, as any string will be accepted.\n-->\n\n<p>通常、イベント名はキャメル記法による文字列で表現されますが、\n厳格な制限ではなく、どんな文字列でも受け入れられます。\n\n</p>\n<!--\nFunctions can then be attached to objects, to be executed when an event\nis emitted. These functions are called _listeners_. Inside a listener\nfunction, `this` refers to the `EventEmitter` that the listener was\nattached to.\n-->\n\n<p>関数をオブジェクトにアタッチすることができ、それはイベントが生成された時に実行されます。\nこれらの関数は<em>リスナー</em>と呼ばれます。\nリスナ関数の中では、<code>this</code> はそのリスナがアタッチされた <code>EventEmitter</code>\nを参照します。\n\n\n</p>\n",
      "classes": [
        {
          "textRaw": "Class: events.EventEmitter",
          "type": "class",
          "name": "events.EventEmitter",
          "desc": "<!--\nTo access the EventEmitter class, `require('events').EventEmitter`.\n-->\n\n<p>EventEmitterクラスにアクセスするには、<code>require('events').EventEmitter</code> を使います。\n\n</p>\n<!--\nWhen an `EventEmitter` instance experiences an error, the typical action is\nto emit an `'error'` event.  Error events are treated as a special case in node.\nIf there is no listener for it, then the default action is to print a stack\ntrace and exit the program.\n-->\n\n<p><code>EventEmitter</code> のインスタンスがエラーに遭遇した時、\n典型的な動作は <code>'error'</code> イベントを生成することです。\nnode ではエラーイベントは特別に扱われます．\nもしそのリスナーがなければ、デフォルトの動作はスタックトレースを出力してプログラムを終了することです。\n\n</p>\n<!--\nAll EventEmitters emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when a listener is removed.\n-->\n\n<p>全ての EventEmitter は、新しいリスナーが加えられるとイベント <code>'newListener'</code> を生成し、リスナーが削除されると <code>'removeListener'</code> を生成します。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "emitter.addListener(event, listener)",
              "type": "method",
              "name": "addListener",
              "desc": "<!--\nAdds a listener to the end of the listeners array for the specified event.\n-->\n\n<p>指定されたイベントに対するリスナー配列の最後にリスナーを追加します。\n\n</p>\n<pre><code>server.on('connection', function (stream) {\n  console.log('someone connected!');\n});</code></pre>\n<!--\nReturns emitter, so calls can be chained.\n-->\n\n<p>EventEmitter 自身を返すので、呼び出しをチェーンすることができます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "event"
                    },
                    {
                      "name": "listener"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "event"
                    },
                    {
                      "name": "listener"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "emitter.on(event, listener)",
              "type": "method",
              "name": "on",
              "desc": "<!--\nAdds a listener to the end of the listeners array for the specified event.\n-->\n\n<p>指定されたイベントに対するリスナー配列の最後にリスナーを追加します。\n\n</p>\n<pre><code>server.on('connection', function (stream) {\n  console.log('someone connected!');\n});</code></pre>\n<!--\nReturns emitter, so calls can be chained.\n-->\n\n<p>EventEmitter 自身を返すので、呼び出しをチェーンすることができます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "event"
                    },
                    {
                      "name": "listener"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "emitter.once(event, listener)",
              "type": "method",
              "name": "once",
              "desc": "<!--\nAdds a **one time** listener for the event. This listener is\ninvoked only the next time the event is fired, after which\nit is removed.\n-->\n\n<p><strong>一回限り</strong>のリスナーをイベントに追加します。\nこのリスナーは次にイベントが発生した時に限り起動され、その後で削除されます。\n\n</p>\n<pre><code>server.once('connection', function (stream) {\n  console.log('Ah, we have our first user!');\n});</code></pre>\n<!--\nReturns emitter, so calls can be chained.\n-->\n\n<p>EventEmitter 自身を返すので、呼び出しをチェーンすることができます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "event"
                    },
                    {
                      "name": "listener"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "emitter.removeListener(event, listener)",
              "type": "method",
              "name": "removeListener",
              "desc": "<!--\nRemove a listener from the listener array for the specified event.\n**Caution**: changes array indices in the listener array behind the listener.\n-->\n\n<p>指定されたイベントに対するリスナー配列からリスナーを削除します。\n<strong>注意</strong>: リスナーの背後にあるリスナー配列のインデックスが変化します。\n\n</p>\n<pre><code>var callback = function(stream) {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);</code></pre>\n<!--\nReturns emitter, so calls can be chained.\n-->\n\n<p>EventEmitter 自身を返すので、呼び出しをチェーンすることができます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "event"
                    },
                    {
                      "name": "listener"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "emitter.removeAllListeners([event])",
              "type": "method",
              "name": "removeAllListeners",
              "desc": "<!--\nRemoves all listeners, or those of the specified event.\n-->\n\n<p>全てのリスナーまたは指定されたイベントに対するリスナーを削除します。\n\n</p>\n<!--\nReturns emitter, so calls can be chained.\n-->\n\n<p>EventEmitter 自身を返すので、呼び出しをチェーンすることができます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "event",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "emitter.setMaxListeners(n)",
              "type": "method",
              "name": "setMaxListeners",
              "desc": "<!--\nBy default EventEmitters will print a warning if more than 10 listeners are\nadded for a particular event. This is a useful default which helps finding memory leaks.\nObviously not all Emitters should be limited to 10. This function allows\nthat to be increased. Set to zero for unlimited.\n-->\n\n<p>デフォルトでは、EventEmitter は 10 を越えるリスナが特定のイベントに追加されると警告を出力します。\nこれはメモリリークを見つけるために役に立つデフォルト値です。\n全ての EventEmitter が 10 に制限されなければならないわけではないことは明らかです。\nこの関数は制限を増やすことを許可します。\n0 を設定すると無制限になります。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "n"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "emitter.listeners(event)",
              "type": "method",
              "name": "listeners",
              "desc": "<!--\nReturns an array of listeners for the specified event.\n-->\n\n<p>指定されたイベントに対するリスナー配列を返します。\n\n</p>\n<pre><code>server.on('connection', function (stream) {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection'))); // [ [Function] ]</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "event"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "emitter.emit(event, [arg1], [arg2], [...])",
              "type": "method",
              "name": "emit",
              "desc": "<!--\nExecute each of the listeners in order with the supplied arguments.\n-->\n\n<p>提供された引数の並びでそれぞれのリスナーを実行します。\n\n</p>\n<!--\nReturns `true` if event had listeners, `false` otherwise.\n-->\n\n<p>イベントに対応するリスナがあった場合は <code>true</code>、それ以外は <code>false</code> を返します。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "event"
                    },
                    {
                      "name": "arg1",
                      "optional": true
                    },
                    {
                      "name": "arg2",
                      "optional": true
                    },
                    {
                      "name": "...",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "classMethods": [
            {
              "textRaw": "Class Method: EventEmitter.listenerCount(emitter, event)",
              "type": "classMethod",
              "name": "listenerCount",
              "desc": "<!--\nReturn the number of listeners for a given event.\n-->\n\n<p>与えられたイベントのリスナー数を返します。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "emitter"
                    },
                    {
                      "name": "event"
                    }
                  ]
                }
              ]
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'newListener'",
              "type": "event",
              "name": "newListener",
              "params": [],
              "desc": "<!--\nThis event is emitted any time someone adds a new listener.  It is unspecified\nif `listener` is in the list returned by `emitter.listeners(event)`.\n-->\n\n<p>このイベントは新しいリスナーが追加されるたびに生成されます。\n<code>emitter.listeners(event)</code> が返すリストに <code>listener</code> が含まれているかどうかは\n未定義です。\n\n\n\n</p>\n"
            },
            {
              "textRaw": "Event: 'removeListener'",
              "type": "event",
              "name": "removeListener",
              "desc": "<!--\n* `event` {String} The event name\n* `listener` {Function} The event handler function\n-->\n\n<ul>\n<li><code>event</code> {String} イベント名</li>\n<li><code>listener</code> {Function} イベントハンドラ関数</li>\n</ul>\n<!--\nThis event is emitted any time someone removes a listener.  It is unspecified\nif `listener` is in the list returned by `emitter.listeners(event)`.\n-->\n\n<p>このイベントはリスナが取り除かれるたびに生成されます。\n<code>emitter.listeners(event)</code> が返すリストから <code>listener</code> が除かれているかどうかは\n未定義です。\n\n</p>\n",
              "params": []
            }
          ]
        }
      ]
    },
    {
      "textRaw": "Domain",
      "name": "domain",
      "stability": 2,
      "stabilityText": "Unstable",
      "desc": "<!--\nDomains provide a way to handle multiple different IO operations as a\nsingle group.  If any of the event emitters or callbacks registered to a\ndomain emit an `error` event, or throw an error, then the domain object\nwill be notified, rather than losing the context of the error in the\n`process.on('uncaughtException')` handler, or causing the program to\nexit immediately with an error code.\n-->\n\n<p>ドメインは複数の異なる I/O 操作を一つのグループとして扱う方法を\n提供します。\nもし EventEmitter またはコールバックがドメインに登録されると、\n<code>'error'</code> がイベントが発生したり例外がスローされた場合、\n<code>process.on('uncaughtException')</code> ハンドラでエラーのコンテキストが失われたり、\nプログラムがエラーコードと共に即座に終了する代わりに、\nドメインオブジェクトに通知されます\n\n</p>\n<!--\nThis feature is new in Node version 0.8.  It is a first pass, and is\nexpected to change significantly in future versions.  Please use it and\nprovide feedback.\n-->\n\n<p>この機能は Node バージョン 0.8 からの新しいものです。\nこれはファーストパスであり、将来のバージョンで大きく変更されると予想されます。\n是非これを使ってフィードバックをしてください。\n\n</p>\n<!--\nDue to their experimental nature, the Domains features are disabled unless\nthe `domain` module is loaded at least once.  No domains are created or\nregistered by default.  This is by design, to prevent adverse effects on\ncurrent programs.  It is expected to be enabled by default in future\nNode.js versions.\n-->\n\n<p>これらは実験的であるため、ドメインの機能は <code>domain</code> モジュールが少なくとも\n一回はロードされるまで無効になっています。\nデフォルトではドメインは作成されず、デフォルトで登録もされません。\nそれは既存のプログラムに悪影響を与えることを防ぐために設計されています。\n将来の Node.js バージョンではデフォルトで有効になることが期待されます。\n\n</p>\n",
      "miscs": [
        {
          "textRaw": "Warning: Don't Ignore Errors!",
          "name": "Warning: Don't Ignore Errors!",
          "type": "misc",
          "desc": "<!--\nDomain error handlers are not a substitute for closing down your\nprocess when an error occurs.\n-->\n\n<p>ドメインのエラーハンドラは、エラーが発生した時に\nプロセスを終了する代わりにはなりません。\n\n</p>\n<!--\nBy the very nature of how `throw` works in JavaScript, there is almost\nnever any way to safely \"pick up where you left off\", without leaking\nreferences, or creating some other sort of undefined brittle state.\n-->\n\n<p>JavaScript において「throw」がどのように働くかという性質により、\n参照のリークや未定義の脆弱な状態を作ることなく「中断したところを取得する」\n方法はほとんどありません。\n\n</p>\n<!--\nThe safest way to respond to a thrown error is to shut down the\nprocess.  Of course, in a normal web server, you might have many\nconnections open, and it is not reasonable to abruptly shut those down\nbecause an error was triggered by someone else.\n-->\n\n<p>スローされたエラーに対処するもっとも安全な方法はプロセスを終了することです。\nもちろん、通常の Web サーバは多くの接続をオープンしていており、\n他の誰かによって引き起こされたエラーのためにそれらをシャットダウンすることは\n合理的ではありません。\n\n</p>\n<!--\nThe better approach is send an error response to the request that\ntriggered the error, while letting the others finish in their normal\ntime, and stop listening for new requests in that worker.\n-->\n\n<p>よりよいアプローチは、エラーを引き起こしたリクエストにエラーを応答し、\nそれ以外の接続が正常に終了するまでの間、ワーカは新しいリクエストのリスニングを\n止めることです。\n\n</p>\n<!--\nIn this way, `domain` usage goes hand-in-hand with the cluster module,\nsince the master process can fork a new worker when a worker\nencounters an error.  For node programs that scale to multiple\nmachines, the terminating proxy or service registry can take note of\nthe failure, and react accordingly.\n-->\n\n<p>この方法では、<code>domain</code> はクラスタモジュールと手を取り合う利用方法により、\nワーカプロセスがエラーに遭遇した場合に新しいワーカをフォークできます。\n複数のマシンにスケールする node プログラムでは、\n終端のプロキシやサービスレジストリは障害に注意し、\nそれに応じて対処することができます。\n\n</p>\n<!--\nFor example, this is not a good idea:\n-->\n\n<p>たとえば、これはいいアイディアではありません:\n\n</p>\n<pre><code class="\"javascript\"">// XXX WARNING!  BAD IDEA!\n\nvar d = require('domain').create();\nd.on('error', function(er) {\n  // The error won't crash the process, but what it does is worse!\n  // Though we've prevented abrupt process restarting, we are leaking\n  // resources like crazy if this ever happens.\n  // This is no better than process.on('uncaughtException')!\n  console.log('error, but oh well', er.message);\n});\nd.run(function() {\n  require('http').createServer(function(req, res) {\n    handleRequest(req, res);\n  }).listen(PORT);\n});</code></pre>\n<!--\nBy using the context of a domain, and the resilience of separating our\nprogram into multiple worker processes, we can react more\nappropriately, and handle errors with much greater safety.\n-->\n\n<p>domain の利用と、プログラムを複数のワーカプロセスに分割することによる\n復元力により、とても安全にエラーを扱う、より適切な対処をすることができます。\n\n</p>\n<pre><code class="\"javascript\"">// Much better!\n\nvar cluster = require('cluster');\nvar PORT = +process.env.PORT || 1337;\n\nif (cluster.isMaster) {\n  // In real life, you'd probably use more than just 2 workers,\n  // and perhaps not put the master and worker in the same file.\n  //\n  // You can also of course get a bit fancier about logging, and\n  // implement whatever custom logic you need to prevent DoS\n  // attacks and other bad behavior.\n  //\n  // See the options in the cluster documentation.\n  //\n  // The important thing is that the master does very little,\n  // increasing our resilience to unexpected errors.\n\n  cluster.fork();\n  cluster.fork();\n\n  cluster.on('disconnect', function(worker) {\n    console.error('disconnect!');\n    cluster.fork();\n  });\n\n} else {\n  // the worker\n  //\n  // This is where we put our bugs!\n\n  var domain = require('domain');\n\n  // See the cluster documentation for more details about using\n  // worker processes to serve requests.  How it works, caveats, etc.\n\n  var server = require('http').createServer(function(req, res) {\n    var d = domain.create();\n    d.on('error', function(er) {\n      console.error('error', er.stack);\n\n      // Note: we're in dangerous territory!\n      // By definition, something unexpected occurred,\n      // which we probably didn't want.\n      // Anything can happen now!  Be very careful!\n\n      try {\n        // make sure we close down within 30 seconds\n        var killtimer = setTimeout(function() {\n          process.exit(1);\n        }, 30000);\n        // But don't keep the process open just for that!\n        killtimer.unref();\n\n        // stop taking new requests.\n        server.close();\n\n        // Let the master know we're dead.  This will trigger a\n        // 'disconnect' in the cluster master, and then it will fork\n        // a new worker.\n        cluster.worker.disconnect();\n\n        // try to send an error to the request that triggered the problem\n        res.statusCode = 500;\n        res.setHeader('content-type', 'text/plain');\n        res.end('Oops, there was a problem!\\n');\n      } catch (er2) {\n        // oh well, not much we can do at this point.\n        console.error('Error sending 500!', er2.stack);\n      }\n    });\n\n    // Because req and res were created before this domain existed,\n    // we need to explicitly add them.\n    // See the explanation of implicit vs explicit binding below.\n    d.add(req);\n    d.add(res);\n\n    // Now run the handler function in the domain.\n    d.run(function() {\n      handleRequest(req, res);\n    });\n  });\n  server.listen(PORT);\n}\n\n// This part isn't important.  Just an example routing thing.\n// You'd put your fancy application logic here.\nfunction handleRequest(req, res) {\n  switch(req.url) {\n    case '/error':\n      // We do some async stuff, and then...\n      setTimeout(function() {\n        // Whoops!\n        flerb.bark();\n      });\n      break;\n    default:\n      res.end('ok');\n  }\n}</code></pre>\n"
        },
        {
          "textRaw": "Additions to Error objects",
          "name": "Additions to Error objects",
          "type": "misc",
          "desc": "<!--\nAny time an Error object is routed through a domain, a few extra fields\nare added to it.\n-->\n\n<p>どんな場合でも、ドメインに送られた Error オブジェクトは\nいくつかのフィールドが加えられます。\n\n</p>\n<!--\n* `error.domain` The domain that first handled the error.\n* `error.domainEmitter` The event emitter that emitted an 'error' event\n  with the error object.\n* `error.domainBound` The callback function which was bound to the\n  domain, and passed an error as its first argument.\n* `error.domainThrown` A boolean indicating whether the error was\n  thrown, emitted, or passed to a bound callback function.\n-->\n\n<ul>\n<li><code>error.domain</code> このエラーを最初に捕まえたドメイン。</li>\n<li><code>error.domainEmitter</code> このエラーオブジェクトと共に <code>error</code> イベントを\n生成した EventEmitter。</li>\n<li><code>error.domainBound</code> ドメインに束縛されたコールバック関数で、\nその第 1 引数にエラーが渡されたもの。</li>\n<li><code>error.domainThrown</code> エラーがスローされたか、EventEmitter から生成されたか、\nそれとも束縛されたコールバック関数に渡されたかを示す boolean 値。</li>\n</ul>\n"
        },
        {
          "textRaw": "Implicit Binding",
          "name": "Implicit Binding",
          "type": "misc",
          "desc": "<!--\nIf domains are in use, then all **new** EventEmitter objects (including\nStream objects, requests, responses, etc.) will be implicitly bound to\nthe active domain at the time of their creation.\n-->\n\n<p>一度ドメインが作成されると、全ての <strong>新しい</strong> EventEmitter オブジェクト\n(ストリームオブジェクトやリクエスト、レスポンス、その他を含む) は、\nそれが作成された時点でアクティブなドメインに暗黙的に束縛されます。\n\n</p>\n<!--\nAdditionally, callbacks passed to lowlevel event loop requests (such as\nto fs.open, or other callback-taking methods) will automatically be\nbound to the active domain.  If they throw, then the domain will catch\nthe error.\n-->\n\n<p>加えて、コールバックが低水準のイベントループ要求 (例えば <code>fs.open()</code>、\nあるいは他のコールバックを受け取るメソッド) もアクティブなドメインに\n束縛されます。\nもしそれらが例外をスローすると、ドメインはそれを捕まえます。\n\n</p>\n<!--\nIn order to prevent excessive memory usage, Domain objects themselves\nare not implicitly added as children of the active domain.  If they\nwere, then it would be too easy to prevent request and response objects\nfrom being properly garbage collected.\n-->\n\n<p>必要以上にメモリを消費するのを防ぐため、ドメインオブジェクトそれ自身は\n暗黙的にアクティブドメインの子として暗黙的には追加されません。\nそれをすれば、リクエストやレスポンスオブジェクトがきちんと GC されることを\nあまりにも簡単に妨害してしまうでしょう。\n\n</p>\n<!--\nIf you *want* to nest Domain objects as children of a parent Domain,\nthen you must explicitly add them.\n-->\n\n<p>もしネストしたドメインを子として他のドメインに <em>加えたければ</em>\n明示的にそれを加えなければなりません。\n\n</p>\n<!--\nImplicit binding routes thrown errors and `'error'` events to the\nDomain's `error` event, but does not register the EventEmitter on the\nDomain, so `domain.dispose()` will not shut down the EventEmitter.\nImplicit binding only takes care of thrown errors and `'error'` events.\n-->\n\n<p>暗黙的なドメインはスローされたエラーや <code>'error'</code> イベントを、\nドメインの <code>'error'</code> イベントにルーティングしますが、\nその EventEmitter をドメインに登録しないので、<code>domain.dispose()</code> は\nEventEmitter をシャットダウンしません。\n暗黙的なバインディングはスローされた例外と <code>'error'</code> イベントにだけ\n注意を払います。\n\n</p>\n"
        },
        {
          "textRaw": "Explicit Binding",
          "name": "Explicit Binding",
          "type": "misc",
          "desc": "<!--\nSometimes, the domain in use is not the one that ought to be used for a\nspecific event emitter.  Or, the event emitter could have been created\nin the context of one domain, but ought to instead be bound to some\nother domain.\n-->\n\n<p>時には、使用中のドメインは特定の EventEmitter に使用されるべきではありません。\nあるいは、EventEmitter はあるドメインのコンテキスト中で作成されますが、\nその他のドメインに結びつけられるべきかもしれません。\n\n</p>\n<!--\nFor example, there could be one domain in use for an HTTP server, but\nperhaps we would like to have a separate domain to use for each request.\n-->\n\n<p>例えば、HTTP サーバで使われるドメインが一つあるとしても、\nおそらくリクエスト毎に独立したドメインを持ちたいでしょう。\n\n</p>\n<!--\nThat is possible via explicit binding.\n-->\n\n<p>これは明示的なバインディングによって可能となります。\n\n</p>\n<!--\nFor example:\n-->\n\n<p>例:\n\n</p>\n<pre><code>// create a top-level domain for the server\nvar serverDomain = domain.create();\n\nserverDomain.run(function() {\n  // server is created in the scope of serverDomain\n  http.createServer(function(req, res) {\n    // req and res are also created in the scope of serverDomain\n    // however, we'd prefer to have a separate domain for each request.\n    // create it first thing, and add req and res to it.\n    var reqd = domain.create();\n    reqd.add(req);\n    reqd.add(res);\n    reqd.on('error', function(er) {\n      console.error('Error', er, req.url);\n      try {\n        res.writeHead(500);\n        res.end('Error occurred, sorry.');\n      } catch (er) {\n        console.error('Error sending 500', er, req.url);\n      }\n    });\n  }).listen(1337);\n});</code></pre>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "domain.create()",
          "type": "method",
          "name": "create",
          "signatures": [
            {
              "return": {
                "textRaw": "return: {Domain} ",
                "name": "return",
                "type": "Domain"
              },
              "params": []
            },
            {
              "params": []
            }
          ],
          "desc": "<!--\nReturns a new Domain object.\n-->\n\n<p>新しいドメインオブジェクトを返します。\n\n</p>\n"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Domain",
          "type": "class",
          "name": "Domain",
          "desc": "<!--\nThe Domain class encapsulates the functionality of routing errors and\nuncaught exceptions to the active Domain object.\n-->\n\n<p>ドメインクラスはエラーのルーティングや捕まえられなかった例外をアクティブな\nドメインにルーティングする機能をカプセル化します。\n\n</p>\n<!--\nDomain is a child class of [EventEmitter][].  To handle the errors that it\ncatches, listen to its `error` event.\n-->\n\n<p>ドメインは [EventEmitter][] の子クラスです。\nこれが捕まえたエラーを扱いたければ、<code>'error'</code> イベントを監視してください。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "domain.run(fn)",
              "type": "method",
              "name": "run",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`fn` {Function} ",
                      "name": "fn",
                      "type": "Function"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "fn"
                    }
                  ]
                }
              ],
              "desc": "<!--\nRun the supplied function in the context of the domain, implicitly\nbinding all event emitters, timers, and lowlevel requests that are\ncreated in that context.\n-->\n\n<p>与えられた関数をこのドメインのコンテキストで実行します。\nこのコンテキストで作成される全ての EventEmitter、タイマ、そして低水準の要求は\n暗黙的にバインドされます。\n\n</p>\n<!--\nThis is the most basic way to use a domain.\n-->\n\n<p>これはドメインを使用するもっとも一般的な方法です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var d = domain.create();\nd.on('error', function(er) {\n  console.error('Caught error!', er);\n});\nd.run(function() {\n  process.nextTick(function() {\n    setTimeout(function() { // simulating some various async stuff\n      fs.open('non-existent file', 'r', function(er, fd) {\n        if (er) throw er;\n        // proceed...\n      });\n    }, 100);\n  });\n});</code></pre>\n<!--\nIn this example, the `d.on('error')` handler will be triggered, rather\nthan crashing the program.\n-->\n\n<p>この例では、プログラムはクラッシュせずに <code>d.on('error')</code> ハンドラが\n呼び出されます。\n\n</p>\n"
            },
            {
              "textRaw": "domain.add(emitter)",
              "type": "method",
              "name": "add",
              "desc": "<!--\n* `emitter` {EventEmitter | Timer} emitter or timer to be added to the domain\n-->\n\n<ul>\n<li><code>emitter</code> {EventEmitter | Timer} ドメインに加えられる EventEmitter\nまたはタイマ</li>\n</ul>\n<!--\nExplicitly adds an emitter to the domain.  If any event handlers called by\nthe emitter throw an error, or if the emitter emits an `error` event, it\nwill be routed to the domain's `error` event, just like with implicit\nbinding.\n-->\n\n<p>明示的に EventEmitter をドメインに追加します。\nこの EventEmitter から呼ばれたどのイベントハンドラがエラーをスローしても、\nあるいはこの EventEmitter が <code>'error'</code> イベントを発生しても、\n暗黙的にバインディングされたのと同様、それはこのドメインの <code>'error</code>'\nイベントにルーティングされます。\n\n</p>\n<!--\nThis also works with timers that are returned from `setInterval` and\n`setTimeout`.  If their callback function throws, it will be caught by\nthe domain 'error' handler.\n-->\n\n<p>これは同様に <code>setIntervalu</code> および <code>setTimeout</code> から返されるタイマでも\n働きます。それらのコールバック関数がエラーをスローすると、それは\nドメインの <code>'error'</code> ハンドに捕まえられます。\n\n</p>\n<!--\nIf the Timer or EventEmitter was already bound to a domain, it is removed\nfrom that one, and bound to this one instead.\n-->\n\n<p>もしタイマまたは EventEmitter が既に他のドメインに束縛されていた場合、\nそれは元のドメインから削除され、代わりにこのドメインに束縛されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "emitter"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "domain.remove(emitter)",
              "type": "method",
              "name": "remove",
              "desc": "<!--\n* `emitter` {EventEmitter | Timer} emitter or timer to be removed from the domain\n-->\n\n<ul>\n<li><code>emitter</code> {EventEmitter | Timer} このドメインから削除される EventEmitter\nまたはタイマ</li>\n</ul>\n<!--\nThe opposite of `domain.add(emitter)`.  Removes domain handling from the\nspecified emitter.\n-->\n\n<p>これは <code>domain.add(emitter)</code> と対照的です。指定された EventEmitter を\nドメインから削除します。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "emitter"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "domain.bind(callback)",
              "type": "method",
              "name": "bind",
              "desc": "<!--\n* `callback` {Function} The callback function\n* return: {Function} The bound function\n-->\n\n<ul>\n<li><code>callback</code> {Function} コールバック関数</li>\n<li>return: {Function} 束縛された関数</li>\n</ul>\n<!--\nThe returned function will be a wrapper around the supplied callback\nfunction.  When the returned function is called, any errors that are\nthrown will be routed to the domain's `error` event.\n-->\n\n<p>返される関数は与えられたコールバック関数のラッパーです。\n返された関数が呼び出されると、スローされたエラーはドメインの <code>'error'</code>\nイベントにルーティングされます。\n\n</p>\n<h4>Example</h4>\n<pre><code>var d = domain.create();\n\nfunction readSomeFile(filename, cb) {\n  fs.readFile(filename, 'utf8', d.bind(function(er, data) {\n    // if this throws, it will also be passed to the domain\n    return cb(er, data ? JSON.parse(data) : null);\n  }));\n}\n\nd.on('error', function(er) {\n  // an error occurred somewhere.\n  // if we throw it now, it will crash the program\n  // with the normal line number and stack message.\n});</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "domain.intercept(callback)",
              "type": "method",
              "name": "intercept",
              "desc": "<!--\n* `callback` {Function} The callback function\n* return: {Function} The intercepted function\n-->\n\n<ul>\n<li><code>callback</code> {Function} コールバック関数</li>\n<li>return: {Function} インターセプトされた関数</li>\n</ul>\n<!--\nThis method is almost identical to `domain.bind(callback)`.  However, in\naddition to catching thrown errors, it will also intercept `Error`\nobjects sent as the first argument to the function.\n-->\n\n<p>このメソッドはほとんど <code>domain.bind(callback)</code> と同じです。\nただし、スローされたエラーを捕まえることに加えて、関数に渡される最初の引数が\n<code>Error</code> オブジェクトの場合もインターセプトします。\n\n</p>\n<!--\nIn this way, the common `if (er) return callback(er);` pattern can be replaced\nwith a single error handler in a single place.\n-->\n\n<p>これは、一般的な <code>if (er) return callback(er);</code> パターンを一カ所で単一の\nエラーハンドラに置き換えることができます。\n\n</p>\n<h4>Example</h4>\n<pre><code>var d = domain.create();\n\nfunction readSomeFile(filename, cb) {\n  fs.readFile(filename, 'utf8', d.intercept(function(data) {\n    // note, the first argument is never passed to the\n    // callback since it is assumed to be the 'Error' argument\n    // and thus intercepted by the domain.\n\n    // if this throws, it will also be passed to the domain\n    // so the error-handling logic can be moved to the 'error'\n    // event on the domain instead of being repeated throughout\n    // the program.\n    return cb(null, JSON.parse(data));\n  }));\n}\n\nd.on('error', function(er) {\n  // an error occurred somewhere.\n  // if we throw it now, it will crash the program\n  // with the normal line number and stack message.\n});</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "domain.enter()",
              "type": "method",
              "name": "enter",
              "desc": "<!--\nThe `enter` method is plumbing used by the `run`, `bind`, and `intercept`\nmethods to set the active domain. It sets `domain.active` and `process.domain`\nto the domain, and implicitly pushes the domain onto the domain stack managed\nby the domain module (see `domain.exit()` for details on the domain stack). The\ncall to `enter` delimits the beginning of a chain of asynchronous calls and I/O\noperations bound to a domain.\n-->\n\n<p><code>enter()</code> メソッドは、<code>run()</code>、<code>bind()</code>、そして <code>intercept()</code> メソッドを\nアクティブなドメインに結びつけるために使われます。\nこれは (このドメインオブジェクト、すなわち <code>this</code> を) <code>domain.active</code> および\n<code>process.domain</code> を設定し、ドメインモジュールによって管理される\nドメインのスタックに暗黙的に積み上げます (ドメインのスタックに関する詳細は\n<code>domain.exit()</code> を参照)。\n\n</p>\n<!--\nCalling `enter` changes only the active domain, and does not alter the domain\nitself. `Enter` and `exit` can be called an arbitrary number of times on a\nsingle domain.\n-->\n\n<p><code>enter()</code> の呼び出しはアクティブなドメインを変更することだけで、\nドメイン自身は変化しません。\n<code>enter()</code> と <code>exit()</code> は一つのドメインに対して何度でも呼び出すことができます。\n\n</p>\n<!--\nIf the domain on which `enter` is called has been disposed, `enter` will return\nwithout setting the domain.\n-->\n\n<p>もし <code>enter()</code> が呼び出されたドメインが破棄済みだと、\n<code>enter()</code> は何も設定せずにリターンします。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "domain.exit()",
              "type": "method",
              "name": "exit",
              "desc": "<!--\nThe `exit` method exits the current domain, popping it off the domain stack.\nAny time execution is going to switch to the context of a different chain of\nasynchronous calls, it's important to ensure that the current domain is exited.\nThe call to `exit` delimits either the end of or an interruption to the chain\nof asynchronous calls and I/O operations bound to a domain.\n-->\n\n<p><code>exit()</code> メソッドは現在のドメインから抜け出し、スタックから取り除きます。\n非同期呼び出しのチェーンが異なるコンテキストに切り替わる場合はどんな時でも、\n現在のドメインから確実に抜け出すことは重要です。\n<code>exit()</code> の呼び出しは、ドメインに束縛された非同期呼び出しおよび\nI/O 操作のチェーンを、終端または途中で区切ります。\n\n</p>\n<!--\nIf there are multiple, nested domains bound to the current execution context,\n`exit` will exit any domains nested within this domain.\n-->\n\n<p>もし複数のネストしたドメインが現在の実行コンテキストに束縛されていると、\n<code>exit()</code> はネストしたどのドメインからも抜け出します。\n\n</p>\n<!--\nCalling `exit` changes only the active domain, and does not alter the domain\nitself. `Enter` and `exit` can be called an arbitrary number of times on a\nsingle domain.\n-->\n\n<p><code>exit()</code> の呼び出しはアクティブなドメインを変更することだけで、\nドメイン自身は変化しません。\n<code>enter()</code> と <code>exit()</code> は一つのドメインに対して何度でも呼び出すことができます。\n\n</p>\n<!--\nIf the domain on which `exit` is called has been disposed, `exit` will return\nwithout exiting the domain.\n-->\n\n<p>もし <code>exit()</code> が呼び出されたドメインが破棄済みだと、\n<code>exit()</code> は何も設定せずにリターンします。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "domain.dispose()",
              "type": "method",
              "name": "dispose",
              "desc": "<!--\nThe dispose method destroys a domain, and makes a best effort attempt to\nclean up any and all IO that is associated with the domain.  Streams are\naborted, ended, closed, and/or destroyed.  Timers are cleared.\nExplicitly bound callbacks are no longer called.  Any error events that\nare raised as a result of this are ignored.\n-->\n\n<p><code>dispose()</code> メソッドはドメインを破棄し、ドメインに関連づけられた全ての\nI/O を可能な限りクリーンナップしようと試みます。\nストリームはアボートされ、終了され、クローズされ、そして／または破棄されます。\nタイマはクリアされます。明示的に束縛されたコールバックはもう呼び出されません。\n結果として発生するどんなエラーイベントも無視されます。\n\n</p>\n<!--\nThe intention of calling `dispose` is generally to prevent cascading\nerrors when a critical part of the Domain context is found to be in an\nerror state.\n-->\n\n<p><code>dispose()</code> を呼び出す意図は通常、エラー状態の中でドメインコンテキストの\nクリティカルな部分が見つかった場合に、カスケードしたエラーを防ぐことです。\n\n</p>\n<!--\nOnce the domain is disposed the `dispose` event will emit.\n-->\n\n<p>ドメインが破棄されると、<code>'dispose'</code> イベントが生成されます。\n\n</p>\n<!--\nNote that IO might still be performed.  However, to the highest degree\npossible, once a domain is disposed, further errors from the emitters in\nthat set will be ignored.  So, even if some remaining actions are still\nin flight, Node.js will not communicate further about them.\n-->\n\n<p>I/O がまだ行われているかもしれないことに注意してください。\nしかしながら、可能な限り高い視点から見ると、一度ドメインが破棄されれば、\nその集合の中の EventEmitter からのさらなるエラーは無視されます。\nそのため、たとえ残りのアクションがまだ実行中だとしても、\nNode.js はそれらとコミュニケートしません。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "`members` {Array} ",
              "name": "members",
              "desc": "<!--\nAn array of timers and event emitters that have been explicitly added\nto the domain.\n-->\n\n<p>このドメインに明示的に加えられたタイマまたは EventEmitter の配列です。\n\n</p>\n"
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Domain"
    },
    {
      "textRaw": "Buffer",
      "name": "buffer",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<!--\nPure JavaScript is Unicode friendly but not nice to binary data.  When\ndealing with TCP streams or the file system, it's necessary to handle octet\nstreams. Node has several strategies for manipulating, creating, and\nconsuming octet streams.\n-->\n\n<p>純粋な JavaScript は Unicode と相性がいいものの、バイナリデータの扱いはうまくありません。\nTCP ストリームやファイルシステムを扱う場合は、オクテットストリームを処理する必要があります。\nNode にはオクテットストリームを操作、作成、消費するためにいくつかの戦略があります。\n\n</p>\n<!--\nRaw data is stored in instances of the `Buffer` class. A `Buffer` is similar\nto an array of integers but corresponds to a raw memory allocation outside\nthe V8 heap. A `Buffer` cannot be resized.\n-->\n\n<p>生のデータは <code>Buffer</code> クラスのインスタンスに保存されます。\n<code>Buffer</code> は整数の配列と似ていますが、\nV8 ヒープの外部に割り当てられた生のメモリに対応します。\n<code>Buffer</code> のサイズを変更することはできません。\n\n</p>\n<!--\nThe `Buffer` class is a global, making it very rare that one would need\nto ever `require('buffer')`.\n-->\n\n<p><code>Buffer</code> クラスはグローバルなので、<code>require('buffer')</code> が必要になることは\nほとんどありません。\n\n</p>\n<!--\nConverting between Buffers and JavaScript string objects requires an explicit\nencoding method.  Here are the different string encodings.\n-->\n\n<p>バッファを JavaScript 文字列オブジェクトとの間で変換するにはエンコーディング方式を明示する必要があります。\nいくつかのエンコーディング方式があります。\n\n</p>\n<!--\n* `'ascii'` - for 7 bit ASCII data only.  This encoding method is very fast, and\n  will strip the high bit if set.\n\n  Note that when converting from string to buffer, this encoding converts a null\n  character (`'\\0'` or `'\\u0000'`) into `0x20` (character code of a space). If\n  you want to convert a null character into `0x00`, you should use `'utf8'`.\n\n* `'utf8'` - Multibyte encoded Unicode characters. Many web pages and other\n  document formats use UTF-8.\n\n* `'utf16le'` - 2 or 4 bytes, little endian encoded Unicode characters.\n  Surrogate pairs (U+10000 to U+10FFFF) are supported.\n\n* `'ucs2'` - Alias of `'utf16le'`.\n\n* `'base64'` - Base64 string encoding.\n\n* `'binary'` - A way of encoding raw binary data into strings by using only\n  the first 8 bits of each character. This encoding method is deprecated and\n  should be avoided in favor of `Buffer` objects where possible. This encoding\n  will be removed in future versions of Node.\n\n* `'hex'` - Encode each byte as two hexadecimal characters.\n-->\n\n<ul>\n<li><p><code>'ascii'</code> - 7bit の ASCII データ専用です。\nこのエンコーディング方式はとても高速で、\nもし上位ビットがセットされていれば取り除かれます。\n文字列からバッファへの変換時、このエンコーディングは null 文字\n(<code>'\\0'</code> または <code>'\\u0000'</code>) を <code>0x20</code> (スペースの文字コード)\nに変換することに注意してください。\nnull 文字を 0x00 に変換したい場合は <code>'utf8'</code> を使用してください。</p>\n</li>\n<li><p><code>'utf8'</code> - 可変長のバイト単位でエンコードされたUnicode文字。\n多くのWebページやその他のドキュメントは UTF-8 を使っています。</p>\n</li>\n<li><p><code>'utf16le'</code> - 2 または 4 バイトのリトルエンディアンでエンコードされた\nUnicode 文字。\nサロゲートペア (U+10000～U+10FFFF) もサポートされます。</p>\n</li>\n<li><p><code>'ucs2'</code> - <code>'utf16le'</code> の別名です。</p>\n</li>\n<li><p><code>'base64'</code> - Base64 文字列エンコーディング.</p>\n</li>\n<li><p><code>'binary'</code> - 生のバイナリデータを各文字の最初の 8bit として使用するエンコーディング方式。\nこのエンコーディング方式はもはや価値がなく、<code>Buffer</code> オブジェクトでは可能な限り使用すべきではありません。\nこのエンコーディングは、Node の将来のバージョンで削除される予定です。</p>\n</li>\n<li><p><code>'hex'</code> - 各バイトを 2 桁の16進数文字列でエンコードします。</p>\n</li>\n</ul>\n<!--\nA `Buffer` object can also be used with typed arrays.  The buffer object is\ncloned to an `ArrayBuffer` that is used as the backing store for the typed\narray.  The memory of the buffer and the `ArrayBuffer` is not shared.\n-->\n\n<p><code>Buffer</code> は Typed Array として使うことができます。\nバッファオブジェクトは、Typed Array のバッキングストアとして使われる\n<code>ArrayBuffer</code> から複製されます。\nバッファと <code>Typed Array</code> はメモリを共有しません。\n\n</p>\n<!--\nNOTE: Node.js v0.8 simply retained a reference to the buffer in `array.buffer`\ninstead of cloning it.\n-->\n\n<p>Node.js の v0.8 では、バッファを複製するのではなく、単純に <code>array.buffer</code>\nに参照を維持していました。\n\n</p>\n<!--\nWhile more efficient, it introduces subtle incompatibilities with the typed\narrays specification.  `ArrayBuffer#slice()` makes a copy of the slice while\n`Buffer#slice()` creates a view.\n-->\n\n<p>それは効率的ではあったものの、Typed Array との微妙な非互換性をもたらしました。\n<code>ArrayBuffer#slice()</code> はスライスのコピーを作成する一方、\n<code>Buffer#slice()</code> はビューを作成します。\n\n</p>\n",
      "classes": [
        {
          "textRaw": "Class: Buffer",
          "type": "class",
          "name": "Buffer",
          "desc": "<!--\nThe Buffer class is a global type for dealing with binary data directly.\nIt can be constructed in a variety of ways.\n-->\n\n<p>Buffer クラスはバイナリデータを直接扱うためのグローバルな型です。\nそれは様々な方法で構築することができます。\n\n</p>\n",
          "classMethods": [
            {
              "textRaw": "Class Method: Buffer.isEncoding(encoding)",
              "type": "classMethod",
              "name": "isEncoding",
              "desc": "<!--\n* `encoding` {String} The encoding string to test\n-->\n\n<ul>\n<li><code>encoding</code> {String} 検証するエンコーディング名</li>\n</ul>\n<!--\nReturns true if the `encoding` is a valid encoding argument, or false\notherwise.\n-->\n\n<p><code>encoding</code> が正しければ <code>true</code>、それ以外は <code>false</code> を返します。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Class Method: Buffer.isBuffer(obj)",
              "type": "classMethod",
              "name": "isBuffer",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Boolean ",
                    "name": "return",
                    "desc": "Boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`obj` Object ",
                      "name": "obj",
                      "desc": "Object"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "obj"
                    }
                  ]
                }
              ],
              "desc": "<!--\nTests if `obj` is a `Buffer`.\n-->\n\n<p><code>obj</code> が <code>Buffer</code> かどうかテストします。\n\n</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.byteLength(string, [encoding])",
              "type": "classMethod",
              "name": "byteLength",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`string` String ",
                      "name": "string",
                      "desc": "String"
                    },
                    {
                      "textRaw": "`encoding` String, Optional, Default: 'utf8' ",
                      "name": "encoding",
                      "desc": "String, Optional, Default: 'utf8'",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nGives the actual byte length of a string. `encoding` defaults to `'utf8'`.\nThis is not the same as `String.prototype.length` since that returns the\nnumber of *characters* in a string.\n-->\n\n<p>文字列の実際のバイト数を返します。<code>encoding</code> のデフォルトは <code>'utf8'</code> です。\nこれは文字列の<em>文字</em>数を返す <code>String.prototype.length</code> と同じではありません。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>str = '\\u00bd + \\u00bc = \\u00be';\n\nconsole.log(str + ": " + str.length + " characters, " +\n  Buffer.byteLength(str, 'utf8') + " bytes");\n\n// ½ + ¼ = ¾: 9 characters, 12 bytes</code></pre>\n"
            },
            {
              "textRaw": "Class Method: Buffer.concat(list, [totalLength])",
              "type": "classMethod",
              "name": "concat",
              "desc": "<!--\n* `list` {Array} List of Buffer objects to concat\n* `totalLength` {Number} Total length of the buffers when concatenated\n-->\n\n<ul>\n<li><code>list</code> {Array} 結合するバッファのリスト</li>\n<li><code>totalLength</code> {Number} 結合されるバッファ全体の長さ</li>\n</ul>\n<!--\nReturns a buffer which is the result of concatenating all the buffers in\nthe list together.\n-->\n\n<p>リストに含まれるバッファ全体を結合した結果のバッファを返します。\n\n</p>\n<!--\nIf the list has no items, or if the totalLength is 0, then it returns a\nzero-length buffer.\n-->\n\n<p>リストが空の場合、または <code>totalLength</code> が 0 の場合は長さが\n0 のバッファを返します。\n\n</p>\n<!--\nIf the list has exactly one item, then the first item of the list is\nreturned.\n-->\n\n<p>リストが一つだけの要素を持つ場合、リストの先頭要素が返されます。\n\n</p>\n<!--\nIf the list has more than one item, then a new Buffer is created.\n-->\n\n<p>リストが複数の要素を持つ場合、新しいバッファが作成されます。\n\n</p>\n<!--\nIf totalLength is not provided, it is read from the buffers in the list.\nHowever, this adds an additional loop to the function, so it is faster\nto provide the length explicitly.\n-->\n\n<p><code>totalLength</code> が与えられない場合はリスト中のバッファから求められます。\nしかし、これは余計なループが必要になるため、明示的に長さを指定する方が\n高速です。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "list"
                    },
                    {
                      "name": "totalLength",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "methods": [
            {
              "textRaw": "buf.write(string, [offset], [length], [encoding])",
              "type": "method",
              "name": "write",
              "desc": "<!--\n* `string` String - data to be written to buffer\n* `offset` Number, Optional, Default: 0\n* `length` Number, Optional, Default: `buffer.length - offset`\n* `encoding` String, Optional, Default: 'utf8'\n-->\n\n<ul>\n<li><code>string</code> String - バッファに書き込まれるデータ</li>\n<li><code>offset</code> Number, Optional, Default: 0</li>\n<li><code>length</code> Number, Optional</li>\n<li><code>encoding</code> String, Optional, Default: 'utf8'</li>\n</ul>\n<!--\nWrites `string` to the buffer at `offset` using the given encoding.\n`offset` defaults to `0`, `encoding` defaults to `'utf8'`. `length` is\nthe number of bytes to write. Returns number of octets written. If `buffer` did\nnot contain enough space to fit the entire string, it will write a partial\namount of the string. `length` defaults to `buffer.length - offset`.\nThe method will not write partial characters.\n-->\n\n<p>与えられたエンコーディングを使用して、<code>string</code> をバッファの <code>offset</code> から書き込みます。\n<code>offset</code> のデフォルトは <code>0</code>、<code>encoding</code> のデフォルトは <code>'utf8'</code> です。\n<code>length</code> は書き込むバイト数です。書き込まれたオクテット数を返します。\nもし <code>buffer</code> が文字列全体を挿入するのに十分なスペースを含んでいなければ、文字列の一部だけを書き込みます。\n<code>length</code> のデフォルトは <code>buffer.length - offset</code> です。\nこのメソッドは文字の一部だけを書き込むことはありません。\n\n</p>\n<!--\nExample: write a utf8 string into a buffer, then print it\n-->\n\n<p>例: utf8 の文字列をバッファに書き込み、それをプリントします\n\n</p>\n<pre><code>buf = new Buffer(256);\nlen = buf.write('\\u00bd + \\u00bc = \\u00be', 0);\nconsole.log(len + " bytes: " + buf.toString('utf8', 0, len));</code></pre>\n<!--\nThe number of characters written (which may be different than the number of\nbytes written) is set in `Buffer._charsWritten` and will be overwritten the\nnext time `buf.write()` is called.\n-->\n\n<p>書き込まれた文字数 (書き込まれたバイト数とは異なる場合があります) は、\n次に <code>buf.write()</code> が呼び出されて上書きされるまで\n<code>Buffer._charsWritten</code> に設定されています。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "offset",
                      "optional": true
                    },
                    {
                      "name": "length",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "buf.toString([encoding], [start], [end])",
              "type": "method",
              "name": "toString",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`encoding` String, Optional, Default: 'utf8' ",
                      "name": "encoding",
                      "desc": "String, Optional, Default: 'utf8'",
                      "optional": true
                    },
                    {
                      "textRaw": "`start` Number, Optional, Default: 0 ",
                      "name": "start",
                      "desc": "Number, Optional, Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` Number, Optional, Default: `buffer.length` ",
                      "name": "end",
                      "desc": "Number, Optional, Default: `buffer.length`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "start",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nDecodes and returns a string from buffer data encoded with `encoding`\n(defaults to `'utf8'`) beginning at `start` (defaults to `0`) and ending at\n`end` (defaults to `buffer.length`).\n-->\n\n<p><code>encoding</code> (デフォルトは <code>'utf8'</code>) でエンコードされたバッファデータの\n<code>start</code> (デフォルトは <code>0</code>) から <code>end</code> (デフォルトは <code>buffer.length</code>)\nまでをデコードした文字列を返します。\n\n</p>\n<!--\nSee `buffer.write()` example, above.\n-->\n\n<p>上の <code>buffer.write()</code> の例を参照してください。\n\n\n</p>\n"
            },
            {
              "textRaw": "buf.toJSON()",
              "type": "method",
              "name": "toJSON",
              "desc": "<!--\nReturns a JSON-representation of the Buffer instance, which is identical to the\noutput for JSON Arrays. `JSON.stringify` implicitly calls this function when\nstringifying a Buffer instance.\n-->\n\n<p>バッファインスタンスの JSON 表現を返します。\nそれは配列の JSON 出力と同じです。\n<code>JSON.stringify()</code> は Buffer のインスタンスを文字列化する際に、\nこの関数を暗黙的に呼び出します。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer('test');\nvar json = JSON.stringify(buf);\n\nconsole.log(json);\n// '[116,101,115,116]'\n\nvar copy = new Buffer(JSON.parse(json));\n\nconsole.log(copy);\n// <Buffer 74 65 73 74></code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])",
              "type": "method",
              "name": "copy",
              "desc": "<!--\n* `targetBuffer` Buffer object - Buffer to copy into\n* `targetStart` Number, Optional, Default: 0\n* `sourceStart` Number, Optional, Default: 0\n* `sourceEnd` Number, Optional, Default: `buffer.length`\n-->\n\n<ul>\n<li><code>targetBuffer</code> Buffer object - コピー先の Buffer</li>\n<li><code>targetStart</code> Number, Optional, Default: 0</li>\n<li><code>sourceStart</code> Number, Optional, Default: 0</li>\n<li><code>sourceEnd</code> Number, Optional, Default: <code>buffer.length</code></li>\n</ul>\n<!--\nDoes copy between buffers. The source and target regions can be overlapped.\n`targetStart` and `sourceStart` default to `0`.\n`sourceEnd` defaults to `buffer.length`.\n-->\n\n<p>バッファ間でコピーします。\nソースとターゲットの領域は重なっていても構いません。\n<code>targetStart</code> と <code>sourceStart</code> のデフォルトは <code>0</code> です。\n<code>sourceEnd</code> のデフォルトは <code>buffer.length</code> です。\n\n</p>\n<!--\nAll values passed that are `undefined`/`NaN` or are out of bounds are set equal\nto their respective defaults.\n-->\n\n<p><code>undefined</code>/<code>NaN</code> またはその他の不正な値が渡された場合は、\nそれぞれのデフォルトが設定されます。\n\n</p>\n<!--\nExample: build two Buffers, then copy `buf1` from byte 16 through byte 19\ninto `buf2`, starting at the 8th byte in `buf2`.\n-->\n\n<p>例: バッファを2個作成し、<code>buf1</code> の 16 バイト目から 19 バイト目を、\n<code>buf2</code> の 8 バイト目から始まる位置へコピーします。\n\n</p>\n<pre><code>buf1 = new Buffer(26);\nbuf2 = new Buffer(26);\n\nfor (var i = 0 ; i < 26 ; i++) {\n  buf1[i] = i + 97; // 97 is ASCII a\n  buf2[i] = 33; // ASCII !\n}\n\nbuf1.copy(buf2, 8, 16, 20);\nconsole.log(buf2.toString('ascii', 0, 25));\n\n// !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "targetBuffer"
                    },
                    {
                      "name": "targetStart",
                      "optional": true
                    },
                    {
                      "name": "sourceStart",
                      "optional": true
                    },
                    {
                      "name": "sourceEnd",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "buf.slice([start], [end])",
              "type": "method",
              "name": "slice",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`start` Number, Optional, Default: 0 ",
                      "name": "start",
                      "desc": "Number, Optional, Default: 0",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` Number, Optional, Default: `buffer.length` ",
                      "name": "end",
                      "desc": "Number, Optional, Default: `buffer.length`",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "start",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nReturns a new buffer which references the same memory as the old, but offset\nand cropped by the `start` (defaults to `0`) and `end` (defaults to\n`buffer.length`) indexes.  Negative indexes start from the end of the buffer.\n-->\n\n<p>元のバッファと同じメモリを参照しますが、<code>start</code> (デフォルトは <code>0</code>) と\n<code>end</code> (デフォルトは <code>buffer.length</code>) で示されるオフセットと長さを持つ\n新しいバッファを返します。\n負のインデックスはバッファの末尾から開始します。\n\n</p>\n<!--\n**Modifying the new buffer slice will modify memory in the original buffer!**\n-->\n\n<p><strong>新しいバッファスライスの変更は、オリジナルバッファのメモリを変更することになります！</strong>\n\n</p>\n<!--\nExample: build a Buffer with the ASCII alphabet, take a slice, then modify one\nbyte from the original Buffer.\n-->\n\n<p>例: ASCII のアルファベットでバッファを構築してスライスし、元のバッファで 1 バイトを変更します。\n\n</p>\n<pre><code>var buf1 = new Buffer(26);\n\nfor (var i = 0 ; i < 26 ; i++) {\n  buf1[i] = i + 97; // 97 is ASCII a\n}\n\nvar buf2 = buf1.slice(0, 3);\nconsole.log(buf2.toString('ascii', 0, buf2.length));\nbuf1[0] = 33;\nconsole.log(buf2.toString('ascii', 0, buf2.length));\n\n// abc\n// !bc</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt8(offset, [noAssert])",
              "type": "method",
              "name": "readUInt8",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nReads an unsigned 8 bit integer from the buffer at the specified offset.\n\nSet `noAssert` to true to skip validation of `offset`. This means that `offset`\nmay be beyond the end of the buffer. Defaults to `false`.\n-->\n\n<p>バッファの指定された位置を符号無し 8bit 整数として読み込みます。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。\nこれは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x3;\nbuf[1] = 0x4;\nbuf[2] = 0x23;\nbuf[3] = 0x42;\n\nfor (ii = 0; ii < buf.length; ii++) {\n  console.log(buf.readUInt8(ii));\n}\n\n// 0x3\n// 0x4\n// 0x23\n// 0x42</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt16LE(offset, [noAssert])",
              "type": "method",
              "name": "readUInt16LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nReads an unsigned 16 bit integer from the buffer at the specified offset with\nspecified endian format.\n\nSet `noAssert` to true to skip validation of `offset`. This means that `offset`\nmay be beyond the end of the buffer. Defaults to `false`.\n-->\n\n<p>バッファの指定された位置を符号無し 16bit 整数として読み込みます。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。\nこれは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x3;\nbuf[1] = 0x4;\nbuf[2] = 0x23;\nbuf[3] = 0x42;\n\nconsole.log(buf.readUInt16BE(0));\nconsole.log(buf.readUInt16LE(0));\nconsole.log(buf.readUInt16BE(1));\nconsole.log(buf.readUInt16LE(1));\nconsole.log(buf.readUInt16BE(2));\nconsole.log(buf.readUInt16LE(2));\n\n// 0x0304\n// 0x0403\n// 0x0423\n// 0x2304\n// 0x2342\n// 0x4223</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt16BE(offset, [noAssert])",
              "type": "method",
              "name": "readUInt16BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nReads an unsigned 16 bit integer from the buffer at the specified offset with\nspecified endian format.\n\nSet `noAssert` to true to skip validation of `offset`. This means that `offset`\nmay be beyond the end of the buffer. Defaults to `false`.\n-->\n\n<p>バッファの指定された位置を符号無し 16bit 整数として読み込みます。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。\nこれは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x3;\nbuf[1] = 0x4;\nbuf[2] = 0x23;\nbuf[3] = 0x42;\n\nconsole.log(buf.readUInt16BE(0));\nconsole.log(buf.readUInt16LE(0));\nconsole.log(buf.readUInt16BE(1));\nconsole.log(buf.readUInt16LE(1));\nconsole.log(buf.readUInt16BE(2));\nconsole.log(buf.readUInt16LE(2));\n\n// 0x0304\n// 0x0403\n// 0x0423\n// 0x2304\n// 0x2342\n// 0x4223</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt32LE(offset, [noAssert])",
              "type": "method",
              "name": "readUInt32LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nReads an unsigned 32 bit integer from the buffer at the specified offset with\nspecified endian format.\n\nSet `noAssert` to true to skip validation of `offset`. This means that `offset`\nmay be beyond the end of the buffer. Defaults to `false`.\n-->\n\n<p>バッファの指定された位置を符号無し 32bit 整数として読み込みます。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。\nこれは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x3;\nbuf[1] = 0x4;\nbuf[2] = 0x23;\nbuf[3] = 0x42;\n\nconsole.log(buf.readUInt32BE(0));\nconsole.log(buf.readUInt32LE(0));\n\n// 0x03042342\n// 0x42230403</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt32BE(offset, [noAssert])",
              "type": "method",
              "name": "readUInt32BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nReads an unsigned 32 bit integer from the buffer at the specified offset with\nspecified endian format.\n\nSet `noAssert` to true to skip validation of `offset`. This means that `offset`\nmay be beyond the end of the buffer. Defaults to `false`.\n-->\n\n<p>バッファの指定された位置を符号無し 32bit 整数として読み込みます。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。\nこれは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x3;\nbuf[1] = 0x4;\nbuf[2] = 0x23;\nbuf[3] = 0x42;\n\nconsole.log(buf.readUInt32BE(0));\nconsole.log(buf.readUInt32LE(0));\n\n// 0x03042342\n// 0x42230403</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt8(offset, [noAssert])",
              "type": "method",
              "name": "readInt8",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nReads a signed 8 bit integer from the buffer at the specified offset.\n\nSet `noAssert` to true to skip validation of `offset`. This means that `offset`\nmay be beyond the end of the buffer. Defaults to `false`.\n\nWorks as `buffer.readUInt8`, except buffer contents are treated as two's\ncomplement signed values.\n-->\n\n<p>バッファの指定された位置を符号付き 8bit 整数として読み込みます。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。\nこれは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。\nデフォルトは <code>false</code> です。\n\n</p>\n<p>バッファの内容を 2 の補数による符号付き値として扱うこと以外は\n<code>buffer.readUInt8</code> と同じように動作します。\n\n</p>\n"
            },
            {
              "textRaw": "buf.readInt16LE(offset, [noAssert])",
              "type": "method",
              "name": "readInt16LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nReads a signed 16 bit integer from the buffer at the specified offset with\nspecified endian format.\n\nSet `noAssert` to true to skip validation of `offset`. This means that `offset`\nmay be beyond the end of the buffer. Defaults to `false`.\n\nWorks as `buffer.readUInt16*`, except buffer contents are treated as two's\ncomplement signed values.\n-->\n\n<p>バッファの指定された位置を符号付き 16bit 整数として読み込みます。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。\nこれは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。\nデフォルトは <code>false</code> です。\n\n</p>\n<p>バッファの内容を 2 の補数による符号付き値として扱うこと以外は\n<code>buffer.readUInt16</code> と同じように動作します。\n\n\n</p>\n"
            },
            {
              "textRaw": "buf.readInt16BE(offset, [noAssert])",
              "type": "method",
              "name": "readInt16BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nReads a signed 16 bit integer from the buffer at the specified offset with\nspecified endian format.\n\nSet `noAssert` to true to skip validation of `offset`. This means that `offset`\nmay be beyond the end of the buffer. Defaults to `false`.\n\nWorks as `buffer.readUInt16*`, except buffer contents are treated as two's\ncomplement signed values.\n-->\n\n<p>バッファの指定された位置を符号付き 16bit 整数として読み込みます。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。\nこれは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。\nデフォルトは <code>false</code> です。\n\n</p>\n<p>バッファの内容を 2 の補数による符号付き値として扱うこと以外は\n<code>buffer.readUInt16</code> と同じように動作します。\n\n\n</p>\n"
            },
            {
              "textRaw": "buf.readInt32LE(offset, [noAssert])",
              "type": "method",
              "name": "readInt32LE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nReads a signed 32 bit integer from the buffer at the specified offset with\nspecified endian format.\n\nSet `noAssert` to true to skip validation of `offset`. This means that `offset`\nmay be beyond the end of the buffer. Defaults to `false`.\n\nWorks as `buffer.readUInt32*`, except buffer contents are treated as two's\ncomplement signed values.\n-->\n\n<p>バッファの指定された位置を符号付き 32bit 整数として読み込みます。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。\nこれは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。\nデフォルトは <code>false</code> です。\n\n</p>\n<p>バッファの内容を 2 の補数による符号付き値として扱うこと以外は\n<code>buffer.readUInt32</code> と同じように動作します。\n\n\n</p>\n"
            },
            {
              "textRaw": "buf.readInt32BE(offset, [noAssert])",
              "type": "method",
              "name": "readInt32BE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nReads a signed 32 bit integer from the buffer at the specified offset with\nspecified endian format.\n\nSet `noAssert` to true to skip validation of `offset`. This means that `offset`\nmay be beyond the end of the buffer. Defaults to `false`.\n\nWorks as `buffer.readUInt32*`, except buffer contents are treated as two's\ncomplement signed values.\n-->\n\n<p>バッファの指定された位置を符号付き 32bit 整数として読み込みます。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。\nこれは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。\nデフォルトは <code>false</code> です。\n\n</p>\n<p>バッファの内容を 2 の補数による符号付き値として扱うこと以外は\n<code>buffer.readUInt32</code> と同じように動作します。\n\n\n</p>\n"
            },
            {
              "textRaw": "buf.readFloatLE(offset, [noAssert])",
              "type": "method",
              "name": "readFloatLE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nReads a 32 bit float from the buffer at the specified offset with specified\nendian format.\n\nSet `noAssert` to true to skip validation of `offset`. This means that `offset`\nmay be beyond the end of the buffer. Defaults to `false`.\n-->\n\n<p>バッファの指定された位置を 32bit 浮動小数点数として読み込みます。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。\nこれは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x00;\nbuf[1] = 0x00;\nbuf[2] = 0x80;\nbuf[3] = 0x3f;\n\nconsole.log(buf.readFloatLE(0));\n\n// 0x01</code></pre>\n"
            },
            {
              "textRaw": "buf.readFloatBE(offset, [noAssert])",
              "type": "method",
              "name": "readFloatBE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nReads a 32 bit float from the buffer at the specified offset with specified\nendian format.\n\nSet `noAssert` to true to skip validation of `offset`. This means that `offset`\nmay be beyond the end of the buffer. Defaults to `false`.\n-->\n\n<p>バッファの指定された位置を 32bit 浮動小数点数として読み込みます。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。\nこれは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(4);\n\nbuf[0] = 0x00;\nbuf[1] = 0x00;\nbuf[2] = 0x80;\nbuf[3] = 0x3f;\n\nconsole.log(buf.readFloatLE(0));\n\n// 0x01</code></pre>\n"
            },
            {
              "textRaw": "buf.readDoubleLE(offset, [noAssert])",
              "type": "method",
              "name": "readDoubleLE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nReads a 64 bit double from the buffer at the specified offset with specified\nendian format.\n\nSet `noAssert` to true to skip validation of `offset`. This means that `offset`\nmay be beyond the end of the buffer. Defaults to `false`.\n-->\n\n<p>バッファの指定された位置を 64bit 倍精度浮動小数点数として読み込みます。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。\nこれは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(8);\n\nbuf[0] = 0x55;\nbuf[1] = 0x55;\nbuf[2] = 0x55;\nbuf[3] = 0x55;\nbuf[4] = 0x55;\nbuf[5] = 0x55;\nbuf[6] = 0xd5;\nbuf[7] = 0x3f;\n\nconsole.log(buf.readDoubleLE(0));\n\n// 0.3333333333333333</code></pre>\n"
            },
            {
              "textRaw": "buf.readDoubleBE(offset, [noAssert])",
              "type": "method",
              "name": "readDoubleBE",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: Number ",
                    "name": "return",
                    "desc": "Number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nReads a 64 bit double from the buffer at the specified offset with specified\nendian format.\n\nSet `noAssert` to true to skip validation of `offset`. This means that `offset`\nmay be beyond the end of the buffer. Defaults to `false`.\n-->\n\n<p>バッファの指定された位置を 64bit 倍精度浮動小数点数として読み込みます。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら <code>offset</code> の検証をスキップします。\nこれは <code>offset</code> がバッファの終端を越えてしまう場合があることを意味します。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(8);\n\nbuf[0] = 0x55;\nbuf[1] = 0x55;\nbuf[2] = 0x55;\nbuf[3] = 0x55;\nbuf[4] = 0x55;\nbuf[5] = 0x55;\nbuf[6] = 0xd5;\nbuf[7] = 0x3f;\n\nconsole.log(buf.readDoubleLE(0));\n\n// 0.3333333333333333</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt8(value, offset, [noAssert])",
              "type": "method",
              "name": "writeUInt8",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nWrites `value` to the buffer at the specified offset. Note, `value` must be a\nvalid unsigned 8 bit integer.\n\nSet `noAssert` to true to skip validation of `value` and `offset`. This means\nthat `value` may be too large for the specific function and `offset` may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to `false`.\n-->\n\n<p><code>value</code> を符号無し 8bit 整数としてバッファの指定された位置に、\n指定されたエンディアンで書き込みます。\n<code>value</code> は妥当な 8bit 符号無し整数でなければならないことに注意してください。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。\nこれは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> \nがバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。\n正確性に確信がない限り、これらを使用すべきではありません。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeUInt8(0x3, 0);\nbuf.writeUInt8(0x4, 1);\nbuf.writeUInt8(0x23, 2);\nbuf.writeUInt8(0x42, 3);\n\nconsole.log(buf);\n\n// <Buffer 03 04 23 42></code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt16LE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeUInt16LE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nWrites `value` to the buffer at the specified offset with specified endian\nformat. Note, `value` must be a valid unsigned 16 bit integer.\n\nSet `noAssert` to true to skip validation of `value` and `offset`. This means\nthat `value` may be too large for the specific function and `offset` may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to `false`.\n-->\n\n<p><code>value</code> を符号無し 16bit 整数としてバッファの指定された位置に、\n指定されたエンディアンで書き込みます。\n<code>value</code> は妥当な 16bit 符号無し整数でなければならないことに注意してください。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。\nこれは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> \nがバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。\n正確性に確信がない限り、これらを使用すべきではありません。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n\n// <Buffer de ad be ef>\n// <Buffer ad de ef be></code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt16BE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeUInt16BE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nWrites `value` to the buffer at the specified offset with specified endian\nformat. Note, `value` must be a valid unsigned 16 bit integer.\n\nSet `noAssert` to true to skip validation of `value` and `offset`. This means\nthat `value` may be too large for the specific function and `offset` may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to `false`.\n-->\n\n<p><code>value</code> を符号無し 16bit 整数としてバッファの指定された位置に、\n指定されたエンディアンで書き込みます。\n<code>value</code> は妥当な 16bit 符号無し整数でなければならないことに注意してください。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。\nこれは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> \nがバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。\n正確性に確信がない限り、これらを使用すべきではありません。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n\n// <Buffer de ad be ef>\n// <Buffer ad de ef be></code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt32LE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeUInt32LE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nWrites `value` to the buffer at the specified offset with specified endian\nformat. Note, `value` must be a valid unsigned 32 bit integer.\n\nSet `noAssert` to true to skip validation of `value` and `offset`. This means\nthat `value` may be too large for the specific function and `offset` may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to `false`.\n-->\n\n<p><code>value</code> を符号無し 32bit 整数としてバッファの指定された位置に、\n指定されたエンディアンで書き込みます。\n<code>value</code> は妥当な 32bit 符号無し整数でなければならないことに注意してください。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。\nこれは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> \nがバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。\n正確性に確信がない限り、これらを使用すべきではありません。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n\n// <Buffer fe ed fa ce>\n// <Buffer ce fa ed fe></code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt32BE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeUInt32BE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nWrites `value` to the buffer at the specified offset with specified endian\nformat. Note, `value` must be a valid unsigned 32 bit integer.\n\nSet `noAssert` to true to skip validation of `value` and `offset`. This means\nthat `value` may be too large for the specific function and `offset` may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to `false`.\n-->\n\n<p><code>value</code> を符号無し 32bit 整数としてバッファの指定された位置に、\n指定されたエンディアンで書き込みます。\n<code>value</code> は妥当な 32bit 符号無し整数でなければならないことに注意してください。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。\nこれは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> \nがバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。\n正確性に確信がない限り、これらを使用すべきではありません。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n\n// <Buffer fe ed fa ce>\n// <Buffer ce fa ed fe></code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt8(value, offset, [noAssert])",
              "type": "method",
              "name": "writeInt8",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nWrites `value` to the buffer at the specified offset. Note, `value` must be a\nvalid signed 8 bit integer.\n\nSet `noAssert` to true to skip validation of `value` and `offset`. This means\nthat `value` may be too large for the specific function and `offset` may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to `false`.\n\nWorks as `buffer.writeUInt8`, except value is written out as a two's complement\nsigned integer into `buffer`.\n-->\n\n<p><code>value</code> を符号付き 8bit 整数としてバッファの指定された位置に、\n指定されたエンディアンで書き込みます。\n<code>value</code> は妥当な 8bit 符号付き整数でなければならないことに注意してください。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。\nこれは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> \nがバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。\n正確性に確信がない限り、これらを使用すべきではありません。\nデフォルトは <code>false</code> です。\n\n</p>\n<p><code>value</code> を 2 の補数による符号付き値として書き込むこと以外は \n<code>buffer.writeUInt8</code> と同じように動作します。\n\n</p>\n"
            },
            {
              "textRaw": "buf.writeInt16LE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeInt16LE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nWrites `value` to the buffer at the specified offset with specified endian\nformat. Note, `value` must be a valid signed 16 bit integer.\n\nSet `noAssert` to true to skip validation of `value` and `offset`. This means\nthat `value` may be too large for the specific function and `offset` may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to `false`.\n\nWorks as `buffer.writeUInt16*`, except value is written out as a two's\ncomplement signed integer into `buffer`.\n-->\n\n<p><code>value</code> を符号付き 16bit 整数としてバッファの指定された位置に、\n指定されたエンディアンで書き込みます。\n<code>value</code> は妥当な 16bit 符号付き整数でなければならないことに注意してください。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。\nこれは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> \nがバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。\n正確性に確信がない限り、これらを使用すべきではありません。\nデフォルトは <code>false</code> です。\n\n</p>\n<p><code>value</code> を 2 の補数による符号付き値として書き込むこと以外は \n<code>buffer.writeUInt16</code> と同じように動作します。\n\n</p>\n"
            },
            {
              "textRaw": "buf.writeInt16BE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeInt16BE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nWrites `value` to the buffer at the specified offset with specified endian\nformat. Note, `value` must be a valid signed 16 bit integer.\n\nSet `noAssert` to true to skip validation of `value` and `offset`. This means\nthat `value` may be too large for the specific function and `offset` may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to `false`.\n\nWorks as `buffer.writeUInt16*`, except value is written out as a two's\ncomplement signed integer into `buffer`.\n-->\n\n<p><code>value</code> を符号付き 16bit 整数としてバッファの指定された位置に、\n指定されたエンディアンで書き込みます。\n<code>value</code> は妥当な 16bit 符号付き整数でなければならないことに注意してください。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。\nこれは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> \nがバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。\n正確性に確信がない限り、これらを使用すべきではありません。\nデフォルトは <code>false</code> です。\n\n</p>\n<p><code>value</code> を 2 の補数による符号付き値として書き込むこと以外は \n<code>buffer.writeUInt16</code> と同じように動作します。\n\n</p>\n"
            },
            {
              "textRaw": "buf.writeInt32LE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeInt32LE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nWrites `value` to the buffer at the specified offset with specified endian\nformat. Note, `value` must be a valid signed 32 bit integer.\n\nSet `noAssert` to true to skip validation of `value` and `offset`. This means\nthat `value` may be too large for the specific function and `offset` may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to `false`.\n\nWorks as `buffer.writeUInt32*`, except value is written out as a two's\ncomplement signed integer into `buffer`.\n-->\n\n<p><code>value</code> を符号付き 32bit 整数としてバッファの指定された位置に、\n指定されたエンディアンで書き込みます。\n<code>value</code> は妥当な 32bit 符号付き整数でなければならないことに注意してください。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。\nこれは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> \nがバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。\n正確性に確信がない限り、これらを使用すべきではありません。\nデフォルトは <code>false</code> です。\n\n</p>\n<p><code>value</code> を 2 の補数による符号付き値として書き込むこと以外は \n<code>buffer.writeUInt32</code> と同じように動作します。\n\n</p>\n"
            },
            {
              "textRaw": "buf.writeInt32BE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeInt32BE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nWrites `value` to the buffer at the specified offset with specified endian\nformat. Note, `value` must be a valid signed 32 bit integer.\n\nSet `noAssert` to true to skip validation of `value` and `offset`. This means\nthat `value` may be too large for the specific function and `offset` may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to `false`.\n\nWorks as `buffer.writeUInt32*`, except value is written out as a two's\ncomplement signed integer into `buffer`.\n-->\n\n<p><code>value</code> を符号付き 32bit 整数としてバッファの指定された位置に、\n指定されたエンディアンで書き込みます。\n<code>value</code> は妥当な 32bit 符号付き整数でなければならないことに注意してください。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。\nこれは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> \nがバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。\n正確性に確信がない限り、これらを使用すべきではありません。\nデフォルトは <code>false</code> です。\n\n</p>\n<p><code>value</code> を 2 の補数による符号付き値として書き込むこと以外は \n<code>buffer.writeUInt32</code> と同じように動作します。\n\n</p>\n"
            },
            {
              "textRaw": "buf.writeFloatLE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeFloatLE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nWrites `value` to the buffer at the specified offset with specified endian\nformat. Note, behavior is unspecified if `value` is not a 32 bit float.\n\nSet `noAssert` to true to skip validation of `value` and `offset`. This means\nthat `value` may be too large for the specific function and `offset` may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to `false`.\n-->\n\n<p><code>value</code> を 32bit 浮動小数点数としてバッファの指定された位置に、\n指定されたエンディアンで書き込みます。\n<code>value</code> が 32bit 浮動小数点数でない場合の振る舞いは未定義であることに\n注意してください。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。\nこれは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> \nがバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。\n正確性に確信がない限り、これらを使用すべきではありません。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n\n// <Buffer 4f 4a fe bb>\n// <Buffer bb fe 4a 4f></code></pre>\n"
            },
            {
              "textRaw": "buf.writeFloatBE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeFloatBE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nWrites `value` to the buffer at the specified offset with specified endian\nformat. Note, behavior is unspecified if `value` is not a 32 bit float.\n\nSet `noAssert` to true to skip validation of `value` and `offset`. This means\nthat `value` may be too large for the specific function and `offset` may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to `false`.\n-->\n\n<p><code>value</code> を 32bit 浮動小数点数としてバッファの指定された位置に、\n指定されたエンディアンで書き込みます。\n<code>value</code> が 32bit 浮動小数点数でない場合の振る舞いは未定義であることに\n注意してください。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。\nこれは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> \nがバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。\n正確性に確信がない限り、これらを使用すべきではありません。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(4);\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n\n// <Buffer 4f 4a fe bb>\n// <Buffer bb fe 4a 4f></code></pre>\n"
            },
            {
              "textRaw": "buf.writeDoubleLE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeDoubleLE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nWrites `value` to the buffer at the specified offset with specified endian\nformat. Note, `value` must be a valid 64 bit double.\n\nSet `noAssert` to true to skip validation of `value` and `offset`. This means\nthat `value` may be too large for the specific function and `offset` may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to `false`.\n-->\n\n<p><code>value</code> を 64bit 倍精度浮動小数点数としてバッファの指定された位置に、\n指定されたエンディアンで書き込みます。\n<code>value</code> は妥当な 64bit 倍精度浮動小数点数でなければならないことに注意してください。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。\nこれは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> \nがバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。\n正確性に確信がない限り、これらを使用すべきではありません。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(8);\nbuf.writeDoubleBE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n\nbuf.writeDoubleLE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n\n// <Buffer 43 eb d5 b7 dd f9 5f d7>\n// <Buffer d7 5f f9 dd b7 d5 eb 43></code></pre>\n"
            },
            {
              "textRaw": "buf.writeDoubleBE(value, offset, [noAssert])",
              "type": "method",
              "name": "writeDoubleBE",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` Number ",
                      "name": "value",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`offset` Number ",
                      "name": "offset",
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`noAssert` Boolean, Optional, Default: false ",
                      "name": "noAssert",
                      "desc": "Boolean, Optional, Default: false",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "noAssert",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nWrites `value` to the buffer at the specified offset with specified endian\nformat. Note, `value` must be a valid 64 bit double.\n\nSet `noAssert` to true to skip validation of `value` and `offset`. This means\nthat `value` may be too large for the specific function and `offset` may be\nbeyond the end of the buffer leading to the values being silently dropped. This\nshould not be used unless you are certain of correctness. Defaults to `false`.\n-->\n\n<p><code>value</code> を 64bit 倍精度浮動小数点数としてバッファの指定された位置に、\n指定されたエンディアンで書き込みます。\n<code>value</code> は妥当な 64bit 倍精度浮動小数点数でなければならないことに注意してください。\n\n</p>\n<p>もし <code>noAssert</code> が <code>true</code> なら，<code>value</code> と <code>offset</code> の検証をスキップします。\nこれは、<code>value</code> がこの関数で扱えるより大きな場合や、<code>offset</code> \nがバッファの終端を越えてしまう場合は、静かに捨てられることを意味します。\n正確性に確信がない限り、これらを使用すべきではありません。\nデフォルトは <code>false</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var buf = new Buffer(8);\nbuf.writeDoubleBE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n\nbuf.writeDoubleLE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n\n// <Buffer 43 eb d5 b7 dd f9 5f d7>\n// <Buffer d7 5f f9 dd b7 d5 eb 43></code></pre>\n"
            },
            {
              "textRaw": "buf.fill(value, [offset], [end])",
              "type": "method",
              "name": "fill",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`value` ",
                      "name": "value"
                    },
                    {
                      "textRaw": "`offset` Number, Optional ",
                      "name": "offset",
                      "optional": true,
                      "desc": "Number"
                    },
                    {
                      "textRaw": "`end` Number, Optional ",
                      "name": "end",
                      "optional": true,
                      "desc": "Number"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nFills the buffer with the specified value. If the `offset` (defaults to `0`)\nand `end` (defaults to `buffer.length`) are not given it will fill the entire\nbuffer.\n-->\n\n<p>指定された値でバッファを埋めます。\n<code>offset</code> (デフォルトは <code>0</code>) と <code>end</code> (デフォルトは <code>buffer.length</code>)\nFが与えられなかった場合はバッファ全体を埋めます。\n\n</p>\n<pre><code>var b = new Buffer(50);\nb.fill("h");</code></pre>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "buf[index]",
              "name": "[index]",
              "desc": "<!--\nGet and set the octet at `index`. The values refer to individual bytes,\nso the legal range is between `0x00` and `0xFF` hex or `0` and `255`.\n-->\n\n<p><code>index</code> の位置のオクテットを取得および設定します。\nその値は個々のバイトを参照するので、妥当な範囲は 16 進の <code>0x00</code> から <code>0xFF</code>\nまたは <code>0</code> から<code>255</code>までの間です。\n\n</p>\n<!--\nExample: copy an ASCII string into a buffer, one byte at a time:\n-->\n\n<p>例: ASCII 文字列を 1 バイトずつバッファにコピーします\n\n</p>\n<pre><code>str = "node.js";\nbuf = new Buffer(str.length);\n\nfor (var i = 0; i < str.length ; i++) {\n  buf[i] = str.charCodeAt(i);\n}\n\nconsole.log(buf);\n\n// node.js</code></pre>\n"
            },
            {
              "textRaw": "`length` Number ",
              "name": "length",
              "desc": "<!--\nThe size of the buffer in bytes.  Note that this is not necessarily the size\nof the contents. `length` refers to the amount of memory allocated for the\nbuffer object.  It does not change when the contents of the buffer are changed.\n-->\n\n<p>バイト数によるバッファのサイズ。\nこれは実際の内容のサイズではないことに注意してください。\n<code>length</code> はバッファオブジェクトに割り当てられたメモリ全体を参照します。\n\n</p>\n<pre><code>buf = new Buffer(1234);\n\nconsole.log(buf.length);\nbuf.write("some string", 0, "ascii");\nconsole.log(buf.length);\n\n// 1234\n// 1234</code></pre>\n",
              "shortDesc": "Number"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`size` Number ",
                  "name": "size",
                  "desc": "Number"
                }
              ],
              "desc": "<!--\nAllocates a new buffer of `size` octets.\n-->\n\n<p><code>size</code> オクテットの新しいバッファを割り当てます。\n\n</p>\n"
            },
            {
              "params": [
                {
                  "name": "size"
                }
              ],
              "desc": "<!--\nAllocates a new buffer of `size` octets.\n-->\n\n<p><code>size</code> オクテットの新しいバッファを割り当てます。\n\n</p>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`array` Array ",
                  "name": "array",
                  "desc": "Array"
                }
              ],
              "desc": "<!--\nAllocates a new buffer using an `array` of octets.\n-->\n\n<p>オクテットの <code>array</code> を使用する新しいバッファを割り当てます。\n\n</p>\n"
            },
            {
              "params": [
                {
                  "name": "array"
                }
              ],
              "desc": "<!--\nAllocates a new buffer using an `array` of octets.\n-->\n\n<p>オクテットの <code>array</code> を使用する新しいバッファを割り当てます。\n\n</p>\n"
            },
            {
              "params": [
                {
                  "name": "str"
                },
                {
                  "name": "encoding",
                  "optional": true
                }
              ],
              "desc": "<!--\n* `str` String - string to encode.\n* `encoding` String - encoding to use, Optional.\n-->\n\n<ul>\n<li><code>str</code> String - エンコードされる文字列</li>\n<li><code>encoding</code> String - 使用するエンコード、Optional、Default: 'utf8'</li>\n</ul>\n<!--\nAllocates a new buffer containing the given `str`.\n`encoding` defaults to `'utf8'`.\n-->\n\n<p>与えられた <code>str</code> を内容とする新しいバッファを割り当てます。\n<code>encoding</code> のデフォルトは <code>'utf8'</code> です。\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: SlowBuffer",
          "type": "class",
          "name": "SlowBuffer",
          "desc": "<!--\nThis class is primarily for internal use.  JavaScript programs should\nuse Buffer instead of using SlowBuffer.\n\nIn order to avoid the overhead of allocating many C++ Buffer objects for\nsmall blocks of memory in the lifetime of a server, Node allocates memory\nin 8Kb (8192 byte) chunks.  If a buffer is smaller than this size, then it\nwill be backed by a parent SlowBuffer object.  If it is larger than this,\nthen Node will allocate a SlowBuffer slab for it directly.\n-->\n\n<p>このクラスは主に内部利用のためのものです。JavaScsript プログラムは SlowBuffer\nよりも Buffer を使用すべきです。\n\n</p>\n<p>サーバの動作中に、小さなメモリブロックのために多くの C++ バッファオブジェクトが\n割り当てられるオーバーヘッドを避けるため、Node はメモリを 8Kb (8192 バイト) の\nチャンク内に割り当てます。もしバッファがこのサイズより小さければ、それは\n親の SlowBuffer に支えられます。それより大きければ、Node は SlowBuffer を\n直接割り当てます。\n\n</p>\n"
        }
      ],
      "properties": [
        {
          "textRaw": "`INSPECT_MAX_BYTES` Number, Default: 50 ",
          "name": "INSPECT_MAX_BYTES",
          "desc": "<!--\nHow many bytes will be returned when `buffer.inspect()` is called. This can\nbe overridden by user modules.\n\nNote that this is a property on the buffer module returned by\n`require('buffer')`, not on the Buffer global, or a buffer instance.\n-->\n\n<p><code>buffer.inspect()</code> が呼び出された場合に返すバイト数です。\nこれはユーザモジュールによって上書きすることができます。\n\n</p>\n<p>これはグローバルの Buffer やそのインスタンスではなく、 <code>requrie('buffer')</code>\nによって返される buffer モジュールのプロパティであることに注意してください。\n\n</p>\n",
          "shortDesc": "Number, Default: 50"
        }
      ],
      "type": "module",
      "displayName": "Buffer"
    },
    {
      "textRaw": "Stream",
      "name": "stream",
      "stability": 2,
      "stabilityText": "Unstable",
      "desc": "<!--\nA stream is an abstract interface implemented by various objects in\nNode.  For example a [request to an HTTP\nserver](http.html#http_http_incomingmessage) is a stream, as is\n[stdout][]. Streams are readable, writable, or both. All streams are\ninstances of [EventEmitter][]\n-->\n\n<p>ストリームは Node の様々なオブジェクトで実装される抽象的なインタフェースです。\n例えば <a href="\"http.html#http_http_incomingmessage\"">HTTP サーバへのリクエスト</a>は\n[標準出力][]と同様にストリームです。\nストリームは読み込み可能、書き込み可能、またはその両方です。\n全てのストリームは [EventEmitter][] のインスタンスです。\n\n</p>\n<!--\nYou can load the Stream base classes by doing `require('stream')`.\nThere are base classes provided for [Readable][] streams, [Writable][]\nstreams, [Duplex][] streams, and [Transform][] streams.\n-->\n\n<p>Stream のベースクラスは <code>require('stream')</code> でロードすることができます。\n[Readable][] ストリーム、[Writable][] ストリーム、[Duplex][] ストリーム、\n[Transform][] ストリームのベースクラスが提供されます。\n\n</p>\n<!--\nThis document is split up into 3 sections.  The first explains the\nparts of the API that you need to be aware of to use streams in your\nprograms.  If you never implement a streaming API yourself, you can\nstop there.\n-->\n\n<p>このドキュメントは 3 つのセクションに分かれています。\n最初に、プログラムでストリームを利用するために知っておく必要がある\nAPI について説明します。\nもし独自のストリーミング API を実装しないのであれば、\nそこで終わりにすることができます。\n\n</p>\n<!--\nThe second section explains the parts of the API that you need to use\nif you implement your own custom streams yourself.  The API is\ndesigned to make this easy for you to do.\n-->\n\n<p>2番目のセクションでは、独自のストリームを実装する場合に必要となる\nAPI について説明します。\nこの API はそれが簡単にできるように設計されています。\n\n</p>\n<!--\nThe third section goes into more depth about how streams work,\nincluding some of the internal mechanisms and functions that you\nshould probably not modify unless you definitely know what you are\ndoing.\n-->\n\n<p>3番目のセクションは、理解することなく変更してはならない\n内部的なメカニズムや関数群を含めて、ストリームがどのように動作するかについて\nより詳しく説明します。\n\n\n</p>\n",
      "classes": [
        {
          "textRaw": "Class: stream.Readable",
          "type": "class",
          "name": "stream.Readable",
          "desc": "<!--\nThe Readable stream interface is the abstraction for a *source* of\ndata that you are reading from.  In other words, data comes *out* of a\nReadable stream.\n-->\n\n<p>Readable ストリームのインターフェースは、あなたが読み込むデータの抽象的な\n<em>発生源</em> です。言い換えると、データは Readable ストリームから <em>出て</em> きます。\n\n</p>\n<!--\nA Readable stream will not start emitting data until you indicate that\nyou are ready to receive it.\n-->\n\n<p>Readable ストリームは、あなたがデータを受け取る準備ができたと指示するまでは、\nデータの生成を開始しません。\n\n</p>\n<!--\nReadable streams have two \"modes\": a **flowing mode** and a **non-flowing\nmode**.  When in flowing mode, data is read from the underlying system\nand provided to your program as fast as possible.  In non-flowing\nmode, you must explicitly call `stream.read()` to get chunks of data\nout.\n-->\n\n<p>Readable ストリームは二つの "モード": <strong>flowing モード</strong> と\n<strong>non-flowing モード</strong> を持っています。\nflowing モードに入ると、データは下層のシステムから読み込まれると、\n可能な限り素早くあなたのプログラムに届けられます。\nnon-flowing モードでは、データの断片を取り出すために、明示的に\n<code>stream.read()</code> を呼び出す必要があります。\n\n</p>\n<!--\nExamples of readable streams include:\n-->\n\n<p>Readable ストリームを含む例:\n\n</p>\n<!--\n* [http responses, on the client](http.html#http_http_incomingmessage)\n* [http requests, on the server](http.html#http_http_incomingmessage)\n* [fs read streams](fs.html#fs_class_fs_readstream)\n* [zlib streams][]\n* [crypto streams][]\n* [tcp sockets][]\n* [child process stdout and stderr][]\n* [process.stdin][]\n-->\n\n<ul>\n<li><a href="\"http.html#http_http_incomingmessage\"">クライアントの http レスポンス</a></li>\n<li><a href="\"http.html#http_http_incomingmessage\"">サーバの http リクエスト</a></li>\n<li><a href="\"fs.html#fs_class_fs_readstream\"">fs の ReadStream</a></li>\n<li>[zlib のストリーム][]</li>\n<li>[crypto のストリーム][]</li>\n<li>[tcp のソケット][]</li>\n<li>[child_process の標準出力と標準エラー出力][]</li>\n<li>[process.stdin][]</li>\n</ul>\n",
          "events": [
            {
              "textRaw": "Event: 'readable'",
              "type": "event",
              "name": "readable",
              "desc": "<!--\nWhen a chunk of data can be read from the stream, it will emit a\n`'readable'` event.\n-->\n\n<p>ストリームからデータの断片を読み込むことが可能となった時、\n<code>'readable'</code> イベントが生成されます。\n\n</p>\n<!--\nIn some cases, listening for a `'readable'` event will cause some data\nto be read into the internal buffer from the underlying system, if it\nhadn't already.\n-->\n\n<p>あるケースでは、<code>'readable'</code> イベントを監視することは下層のシステムからデータを内部バッファへ読み込む原因となります (それがまだ行われていなかった場合)。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on('readable', function() {\n  // there is some data to read now\n})</code></pre>\n<!--\nOnce the internal buffer is drained, a `readable` event will fire\nagain when more data is available.\n-->\n\n<p>内部バッファが空になると、データが利用可能になった時に\n<code>'readable'</code> イベントは再び生成されます。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'data'",
              "type": "event",
              "name": "data",
              "desc": "<!--\n* `chunk` {Buffer | String} The chunk of data.\n-->\n\n<ul>\n<li><code>chunk</code> {Buffer | String} データの断片。</li>\n</ul>\n<!--\nIf you attach a `data` event listener, then it will switch the stream\ninto flowing mode, and data will be passed to your handler as soon as\nit is available.\n-->\n\n<p><code>'data'</code> イベントのリスナを追加すると、ストリームは flowing モードに切り替わり、\nデータは利用可能になるとすぐにあなたのハンドラに渡されます。\n\n</p>\n<!--\nIf you just want to get all the data out of the stream as fast as\npossible, this is the best way to do so.\n-->\n\n<p>ストリームから出てくる全てのデータをできるだけ素早く欲しいのなら、\nこれが最善の方法です。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on('data', function(chunk) {\n  console.log('got %d bytes of data', chunk.length);\n})</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'end'",
              "type": "event",
              "name": "end",
              "desc": "<!--\nThis event fires when no more data will be provided.\n-->\n\n<p>このイベントは、提供するデータがもう無くなった場合に生成されます。\n\n</p>\n<!--\nNote that the `end` event **will not fire** unless the data is\ncompletely consumed.  This can be done by switching into flowing mode,\nor by calling `read()` repeatedly until you get to the end.\n-->\n\n<p><code>'end'</code> イベントはデータが完全に消費されるまでは <strong>生成されない</strong>\nことに注意してください。\nそれは flowing モードに切り替えることによって、または終わりに達するまで\n<code>read()</code> を繰り返し呼び出すことによって達成することができます。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on('data', function(chunk) {\n  console.log('got %d bytes of data', chunk.length);\n})\nreadable.on('end', function() {\n  console.log('there will be no more data.');\n});</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<!--\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n-->\n\n<p>下層のリソース (例えば背後のファイル記述子) がクローズされた時に生成されます。\n全てのストリームがこのイベントを発生するわけではありません。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "desc": "<!--\nEmitted if there was an error receiving data.\n-->\n\n<p>データの受信でエラーがあると生成されます。\n\n</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "readable.read([size])",
              "type": "method",
              "name": "read",
              "desc": "<!--\n* `size` {Number} Optional argument to specify how much data to read.\n* Return {String | Buffer | null}\n-->\n\n<ul>\n<li><code>size</code> {Number} どれだけのデータを読み込むか指定するオプションの引数。</li>\n<li>Return {String | Buffer | null}</li>\n</ul>\n<!--\nThe `read()` method pulls some data out of the internal buffer and\nreturns it.  If there is no data available, then it will return\n`null`.\n-->\n\n<p><code>read()</code> メソッドは内部バッファからデータを取り出して返します。\nもし利用可能なデータが無ければ、<code>null</code> を返します。\n\n</p>\n<!--\nIf you pass in a `size` argument, then it will return that many\nbytes.  If `size` bytes are not available, then it will return `null`.\n-->\n\n<p><code>size</code> 引数を指定すると、その長さ (バイト数または文字数) のデータを返します。\nもし <code>size</code> で指定された長さのデータが揃っていない場合は <code>null</code> を返します。\n\n</p>\n<!--\nIf you do not specify a `size` argument, then it will return all the\ndata in the internal buffer.\n-->\n\n<p><code>size</code> 引数を指定しなかった場合は、内部バッファにある全てのデータが返されます。\n\n</p>\n<!--\nThis method should only be called in non-flowing mode.  In\nflowing-mode, this method is called automatically until the internal\nbuffer is drained.\n-->\n\n<p>このメソッドは non-flowing モードの場合に限って呼び出されるべきです。\nflowing モードでは、内部バッファが空になるまで\nこのメソッドは自動的に呼び出されます。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on('readable', function() {\n  var chunk;\n  while (null !== (chunk = readable.read())) {\n    console.log('got %d bytes of data', chunk.length);\n  }\n});</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "size",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "readable.setEncoding(encoding)",
              "type": "method",
              "name": "setEncoding",
              "desc": "<!--\n* `encoding` {String} The encoding to use.\n-->\n\n<ul>\n<li><code>encoding</code> {String} 使用するエンコーディング。</li>\n</ul>\n<!--\nCall this function to cause the stream to return strings of the\nspecified encoding instead of Buffer objects.  For example, if you do\n`readable.setEncoding('utf8')`, then the output data will be\ninterpreted as UTF-8 data, and returned as strings.  If you do\n`readable.setEncoding('hex')`, then the data will be encoded in\nhexadecimal string format.\n-->\n\n<p>この関数を呼び出すと、ストリームは Buffer オブジェクトの代わりに\n指定されたエンコーディングによる文字列を返すようになります。\n例えば、<code>readable.setEncoding('utf8')</code> とすると、得られるデータは\nUTF-8 のデータとして解釈され、文字列が返されます。\n<code>readable.setEncoding('hex')</code> とすると、データは 16 進フォーマットの\n文字列にエンコードされます。\n\n</p>\n<!--\nThis properly handles multi-byte characters that would otherwise be\npotentially mangled if you simply pulled the Buffers directly and\ncalled `buf.toString(encoding)` on them.  If you want to read the data\nas strings, always use this method.\n-->\n\n<p>これは、Buffer を直接取得して単純に <code>buf.toString(encoding)</code>\nを呼び出した場合は潜在的にめちゃくちゃになるのとは異なり、\nマルチバイト文字を正しく扱います。\nデータを文字列として読み込みたければ、常にこのメソッドを使用してください。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.setEncoding('utf8');\nreadable.on('data', function(chunk) {\n  assert.equal(typeof chunk, 'string');\n  console.log('got %d characters of string data', chunk.length);\n})</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "readable.resume()",
              "type": "method",
              "name": "resume",
              "desc": "<!--\nThis method will cause the readable stream to resume emitting `data`\nevents.\n-->\n\n<p>このメソッドは Readable ストリームが <code>'data'</code> イベントの生成を\n再開するようにします。\n\n</p>\n<!--\nThis method will switch the stream into flowing-mode.  If you do *not*\nwant to consume the data from a stream, but you *do* want to get to\nits `end` event, you can call `readable.resume()` to open the flow of\ndata.\n-->\n\n<p>このメソッドはストリームを flowing モードに切り替えます。\nもしストリームからのデータを消費する必要が <em>なく</em>、しかし <code>'end'</code> イベントを\n受け取る必要が <em>ある</em> なら、<code>readable.resume()</code> を呼び出してデータのフローを\n開くことができます。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.resume();\nreadable.on('end', function(chunk) {\n  console.log('got to the end, but did not read anything');\n})</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "readable.pause()",
              "type": "method",
              "name": "pause",
              "desc": "<!--\nThis method will cause a stream in flowing-mode to stop emitting\n`data` events.  Any data that becomes available will remain in the\ninternal buffer.\n-->\n\n<p>このメソッドはストリームを flowing モードに切り替えて、\n<code>'data'</code> イベントの生成を中断します。\n利用可能になったデータは内部バッファの中に残ります。\n\n</p>\n<!--\nThis method is only relevant in flowing mode.  When called on a\nnon-flowing stream, it will switch into flowing mode, but remain\npaused.\n-->\n\n<p>このメソッドは flowing モードにだけ関連します。\nnon-flowing モードのストリームで呼ばれた場合は、flowing モードに切り替わり、\n残りのデータは休止します。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on('data', function(chunk) {\n  console.log('got %d bytes of data', chunk.length);\n  readable.pause();\n  console.log('there will be no more data for 1 second');\n  setTimeout(function() {\n    console.log('now data will start flowing again');\n    readable.resume();\n  }, 1000);\n})</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "readable.pipe(destination, [options])",
              "type": "method",
              "name": "pipe",
              "* `destination` {[Writable][] Stream} The destination for writing data\n* `options` {Object} Pipe options\n  * `end` {Boolean} End the writer when the reader ends. Default": "`true`",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`destination` {[Writable][] Stream} データの書き込み先。 ",
                      "name": "destination",
                      "type": "[Writable][] Stream",
                      "desc": "データの書き込み先。"
                    },
                    {
                      "textRaw": "`options` {Object} パイプオプション ",
                      "options": [
                        {
                          "textRaw": "`end` {Boolean} 読み込み元が終了すると書き込み先を終了します。 デフォルトは `true` ",
                          "name": "end",
                          "type": "Boolean",
                          "desc": "読み込み元が終了すると書き込み先を終了します。 デフォルトは `true`"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "desc": "パイプオプション",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "destination"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nThis method pulls all the data out of a readable stream, and writes it\nto the supplied destination, automatically managing the flow so that\nthe destination is not overwhelmed by a fast readable stream.\n-->\n\n<p>このメソッドは Readable ストリームから全てのデータを引き出し、\n与えられた行き先に書き込みます。\n高速な Readable ストリームによって出力先が圧迫されないように、\n自動的にフロー制御を行います。\n\n</p>\n<!--\nMultiple destinations can be piped to safely.\n-->\n\n<p>複数の出力先を安全に連結することができます。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nvar writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt'\nreadable.pipe(writable);</code></pre>\n<!--\nThis function returns the destination stream, so you can set up pipe\nchains like so:\n-->\n\n<p>この関数は出力先となるストリーム返すので、このようにパイプのチェーンを\n組み立てることができます。\n\n</p>\n<pre><code class="\"javascript\"">var r = fs.createReadStream('file.txt');\nvar z = zlib.createGzip();\nvar w = fs.createWriteStream('file.txt.gz');\nr.pipe(z).pipe(w);</code></pre>\n<!--\nFor example, emulating the Unix `cat` command:\n-->\n\n<p>Unix の <code>cat</code> コマンドをエミュレートする例:\n\n</p>\n<pre><code class="\"javascript\"">process.stdin.pipe(process.stdout);</code></pre>\n<!--\nBy default [`end()`][] is called on the destination when the source stream\nemits `end`, so that `destination` is no longer writable. Pass `{ end:\nfalse }` as `options` to keep the destination stream open.\n-->\n\n<p>デフォルトでは、出力先の [<code>end()</code>][] は入力元のストリームで\n<code>'end'</code> が生成された時に呼び出されます。そのため、<code>destination</code>\nはもう書き込み可能ではなくなります。\n<code>{end: false }</code> を <code>options</code> として渡すことにより、出力先ストリームを\nオープンしたままにしておくことができます。\n\n</p>\n<!--\nThis keeps `writer` open so that \"Goodbye\" can be written at the\nend.\n-->\n\n<p>これは <code>writer</code> をオープンしたままにすることにより、最後に\n<code>"Goodbye"</code> と書き込むことができます。\n\n</p>\n<pre><code class="\"javascript\"">reader.pipe(writer, { end: false });\nreader.on('end', function() {\n  writer.end('Goodbye\\n');\n});</code></pre>\n<!--\nNote that `process.stderr` and `process.stdout` are never closed until\nthe process exits, regardless of the specified options.\n-->\n\n<p><code>process.stderr</code> および <code>process.stdout</code> は、オプションの指定に関係なく、\nプロセスが終了するまで決してクローズされないことに注意してください。\n\n</p>\n"
            },
            {
              "textRaw": "readable.unpipe([destination])",
              "type": "method",
              "name": "unpipe",
              "desc": "<!--\n* `destination` {[Writable][] Stream} Optional specific stream to unpipe\n-->\n\n<ul>\n<li><code>destination</code> {[Writable][] Stream} オプションのパイプを解除するストリーム</li>\n</ul>\n<!--\nThis method will remove the hooks set up for a previous `pipe()` call.\n-->\n\n<p>このメソッドは以前の <code>pipe()</code> 呼び出しで設定されたフックを取り除きます。\n\n</p>\n<!--\nIf the destination is not specified, then all pipes are removed.\n-->\n\n<p><code>destination</code> が指定されなかった場合は、全てのパイプが取り除かれます。\n\n</p>\n<!--\nIf the destination is specified, but no pipe is set up for it, then\nthis is a no-op.\n-->\n\n<p><code>destination</code> が指定されたものの、それがパイプされていなかった場合、\nこれは何もしません。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nvar writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second\nreadable.pipe(writable);\nsetTimeout(function() {\n  console.log('stop writing to file.txt');\n  readable.unpipe(writable);\n  console.log('manually close the file stream');\n  writable.end();\n}, 1000);</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "destination",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "readable.unshift(chunk)",
              "type": "method",
              "name": "unshift",
              "desc": "<!--\n* `chunk` {Buffer | String} Chunk of data to unshift onto the read queue\n-->\n\n<ul>\n<li><code>chunk</code> {Buffer | String} 読み込みキューの先頭に戻されるデータの断片</li>\n</ul>\n<!--\nThis is useful in certain cases where a stream is being consumed by a\nparser, which needs to \"un-consume\" some data that it has\noptimistically pulled out of the source, so that the stream can be\npassed on to some other party.\n-->\n\n<p>これはストリームがパーサによって消費されるケースにおいて有用です。\nそれはソースから楽観的に取り出したデータを「消費しなかった」ことにして、\nストリームが他のところにデータを渡せるようにする場合に必要です。\n\n</p>\n<!--\nIf you find that you must often call `stream.unshift(chunk)` in your\nprograms, consider implementing a [Transform][] stream instead.  (See API\nfor Stream Implementors, below.)\n-->\n\n<p><code>stream.unshift(chunk)</code> を頻繁に呼び出さなくてはならないとしたら、\n代わりに [Transform][] ストリームを実装することを検討してください\n(後述する [ストリーム実装者向けの API][] を参照してください)。\n\n</p>\n<pre><code class="\"javascript\"">// Pull off a header delimited by \\n\\n\n// use unshift() if we get too much\n// Call the callback with (error, header, stream)\nvar StringDecoder = require('string_decoder').StringDecoder;\nfunction parseHeader(stream, callback) {\n  stream.on('error', callback);\n  stream.on('readable', onReadable);\n  var decoder = new StringDecoder('utf8');\n  var header = '';\n  function onReadable() {\n    var chunk;\n    while (null !== (chunk = stream.read())) {\n      var str = decoder.write(chunk);\n      if (str.match(/\\n\\n/)) {\n        // found the header boundary\n        var split = str.split(/\\n\\n/);\n        header += split.shift();\n        var remaining = split.join('\\n\\n');\n        var buf = new Buffer(remaining, 'utf8');\n        if (buf.length)\n          stream.unshift(buf);\n        stream.removeListener('error', callback);\n        stream.removeListener('readable', onReadable);\n        // now the body of the message can be read from the stream.\n        callback(null, header, stream);\n      } else {\n        // still reading the header.\n        header += str;\n      }\n    }\n  }\n}</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "readable.wrap(stream)",
              "type": "method",
              "name": "wrap",
              "desc": "<!--\n* `stream` {Stream} An \"old style\" readable stream\n-->\n\n<ul>\n<li><code>stream</code> {Stream} 「古いスタイル」の Readable ストリーム</li>\n</ul>\n<!--\nVersions of Node prior to v0.10 had streams that did not implement the\nentire Streams API as it is today.  (See \"Compatibility\" below for\nmore information.)\n-->\n\n<p>v0.10 より前のバージョンの Node には、今日の全ストリーム API を実装していない\nストリームがありました (より詳細は後述する「[互換性][]」を参照してください)。\n\n</p>\n<!--\nIf you are using an older Node library that emits `'data'` events and\nhas a `pause()` method that is advisory only, then you can use the\n`wrap()` method to create a [Readable][] stream that uses the old stream\nas its data source.\n-->\n\n<p>もし、<code>'data'</code> イベントを生成し、アドバイスだけを行う <code>pause()</code>\nメソッドを持つ、古い Node ライブラリを使っているなら、\n<code>wrap()</code> メソッドは古いストリームをデータソースとして使用する\n[Readable][] ストリームを作成します。\n\n</p>\n<!--\nYou will very rarely ever need to call this function, but it exists\nas a convenience for interacting with old Node programs and libraries.\n-->\n\n<p>この関数を呼び出す必要は滅多にありませんが、これは古い Node\nプログラム及びライブラリと相互作用するための利便性のために存在します。\n\n</p>\n<!--\nFor example:\n-->\n\n<p>例:\n\n</p>\n<pre><code class="\"javascript\"">var OldReader = require('./old-api-module.js').OldReader;\nvar oreader = new OldReader;\nvar Readable = require('stream').Readable;\nvar myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', function() {\n  myReader.read(); // etc.\n});</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "stream"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: stream.Writable",
          "type": "class",
          "name": "stream.Writable",
          "desc": "<!--\nThe Writable stream interface is an abstraction for a *destination*\nthat you are writing data *to*.\n-->\n\n<p>Writable ストリームのインターフェースは、あなたがデータを書き込む抽象的な\n<em>行き先</em> です。\n\n</p>\n<!--\nExamples of writable streams include:\n-->\n\n<p>Writable ストリームを含む例:\n\n</p>\n<!--\n* [http requests, on the client](http.html#http_class_http_clientrequest)\n* [http responses, on the server](http.html#http_class_http_serverresponse)\n* [fs write streams](fs.html#fs_class_fs_writestream)\n* [zlib streams][]\n* [crypto streams][]\n* [tcp sockets][]\n* [child process stdin](child_process.html#child_process_child_stdin)\n* [process.stdout][], [process.stderr][]\n-->\n\n<ul>\n<li><a href="\"http.html#http_class_http_clientrequest\"">クライアントの http リクエスト</a></li>\n<li><a href="\"http.html#http_class_http_serverresponse\"">サーバの http レスポンス</a></li>\n<li><a href="\"fs.html#fs_class_fs_writestream\"">fs の WriteStream</a></li>\n<li>[zlib のストリーム][]</li>\n<li>[crypto のストリーム][]</li>\n<li>[tcp のソケット][]</li>\n<li><a href="\"child_process.html#child_process_child_stdin\"">child_process の標準入力</a></li>\n<li>[process.stdout][], [process.stderr][]</li>\n</ul>\n",
          "methods": [
            {
              "textRaw": "writable.write(chunk, [encoding], [callback])",
              "type": "method",
              "name": "write",
              "desc": "<!--\n* `chunk` {String | Buffer} The data to write\n* `encoding` {String} The encoding, if `chunk` is a String\n* `callback` {Function} Callback for when this chunk of data is flushed\n* Returns: {Boolean} True if the data was handled completely.\n-->\n\n<ul>\n<li><code>chunk</code> {String | Buffer} 書き込まれるデータ</li>\n<li><code>encoding</code> {String} もし <code>chunk</code> が文字列なら、そのエンコーディング</li>\n<li><code>callback</code> {Function} データが掃き出された時に呼び出されるコールバック</li>\n<li>Returns: {Boolean} データが完全に処理された場合は <code>true</code>。</li>\n</ul>\n<!--\nThis method writes some data to the underlying system, and calls the\nsupplied callback once the data has been fully handled.\n-->\n\n<p>このメソッドはデータを下層のシステムに書き込み、データが完全に処理されると\n与えられたコールバックを一度だけ呼び出します。\n\n</p>\n<!--\nThe return value indicates if you should continue writing right now.\nIf the data had to be buffered internally, then it will return\n`false`.  Otherwise, it will return `true`.\n-->\n\n<p>戻り値は書き込みをすぐに続けていいかどうかを示します。\nもしデータが内部にバッファリングされなければならないなら <code>false</code> を返します。\nそうでなければ <code>true</code> を返します。\n\n</p>\n<!--\nThis return value is strictly advisory.  You MAY continue to write,\neven if it returns `false`.  However, writes will be buffered in\nmemory, so it is best not to do this excessively.  Instead, wait for\nthe `drain` event before writing more data.\n-->\n\n<p>この戻り値は完全にアドバイス的です。\nもしこれが <code>false</code> を返しても、あなたは書き込みを続けることが「できます」。\nしかしながら、書き込まれたデータはメモリにバッファリングされるため、\nこれを過剰にしないことが最善です。\n代わりに、より多くのデータを書く前に <code>'drain'</code> イベントを待機してください。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "writable.end([chunk], [encoding], [callback])",
              "type": "method",
              "name": "end",
              "desc": "<!--\n* `chunk` {String | Buffer} Optional data to write\n* `encoding` {String} The encoding, if `chunk` is a String\n* `callback` {Function} Optional callback for when the stream is finished\n-->\n\n<ul>\n<li><code>chunk</code> {String | Buffer} オプションの書き込まれるデータ</li>\n<li><code>encoding</code> {String} もし <code>chunk</code> が文字列なら、そのエンコーディング</li>\n<li><code>callback</code> {Function} ストリームが終了時に呼び出される、\nオプションのコールバック</li>\n</ul>\n<!--\nCall this method when no more data will be written to the stream.  If\nsupplied, the callback is attached as a listener on the `finish` event.\n-->\n\n<p>これ以上データをストリームに書き込まない場合に呼び出してください。\nコールバックが与えられた場合、それは <code>'finish'</code> イベントのリスナとして\nアタッチされます。\n\n</p>\n<!--\nCalling [`write()`][] after calling [`end()`][] will raise an error.\n-->\n\n<p>[<code>end()</code>][] を呼び出した後で [<code>write()</code>][] を呼び出すとエラーになります。\n\n</p>\n<pre><code class="\"javascript\"">// write 'hello, ' and then end with 'world!'\nhttp.createServer(function (req, res) {\n  res.write('hello, ');\n  res.end('world!');\n  // writing more now is not allowed!\n});</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'drain'",
              "type": "event",
              "name": "drain",
              "desc": "<!--\nIf a [`writable.write(chunk)`][] call returns false, then the `drain`\nevent will indicate when it is appropriate to begin writing more data\nto the stream.\n-->\n\n<p>[<code>write(chunk, encoding, callback)</code>][] の呼び出しが <code>false</code> を返した場合、\nより多くのデータをいつストリームに書き始めるのが適切かを\n<code>'drain'</code> イベントによって示します。\n\n</p>\n<pre><code class="\"javascript\"">// Write the data to the supplied writable stream 1MM times.\n// Be attentive to back-pressure.\nfunction writeOneMillionTimes(writer, data, encoding, callback) {\n  var i = 1000000;\n  write();\n  function write() {\n    var ok = true;\n    do {\n      i -= 1;\n      if (i === 0) {\n        // last time!\n        writer.write(data, encoding, callback);\n      } else {\n        // see if we should continue, or wait\n        // don't pass the callback, because we're not done yet.\n        ok = writer.write(data, encoding);\n      }\n    } while (i > 0 && ok);\n    if (i > 0) {\n      // had to stop early!\n      // write some more once it drains\n      writer.once('drain', write);\n    }\n  }\n}</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'finish'",
              "type": "event",
              "name": "finish",
              "desc": "<!--\nWhen the [`end()`][] method has been called, and all data has been flushed\nto the underlying system, this event is emitted.\n-->\n\n<p>[<code>end()</code>][] メソッドが呼び出されて、全てのデータが下層のシステムに\n掃き出されると、このイベントが生成されます。\n\n</p>\n<pre><code class="\"javascript\"">var writer = getWritableStreamSomehow();\nfor (var i = 0; i < 100; i ++) {\n  writer.write('hello, #' + i + '!\\n');\n}\nwriter.end('this is the end\\n');\nwriter.on('finish', function() {\n  console.error('all writes are now complete.');\n});</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'pipe'",
              "type": "event",
              "name": "pipe",
              "desc": "<!--\n* `src` {[Readable][] Stream} source stream that is piping to this writable\n-->\n\n<ul>\n<li><code>src</code> {[Readable][] Stream} この Writable ストリームにつながれた\n入力元のストリーム</li>\n</ul>\n<!--\nThis is emitted whenever the `pipe()` method is called on a readable\nstream, adding this writable to its set of destinations.\n-->\n\n<p>これは、Readable ストリームの <code>pipe()</code> メソッドが呼び出されて、\nこの Writable ストリームが出力先として加えられた時に生成されます。\n\n</p>\n<pre><code class="\"javascript\"">var writer = getWritableStreamSomehow();\nvar reader = getReadableStreamSomehow();\nwriter.on('pipe', function(src) {\n  console.error('something is piping into the writer');\n  assert.equal(src, reader);\n});\nreader.pipe(writer);</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'unpipe'",
              "type": "event",
              "name": "unpipe",
              "desc": "<!--\n* `src` {[Readable][] Stream} The source stream that [unpiped][] this writable\n-->\n\n<ul>\n<li><code>src</code> {[Readable][] Stream} この Writable ストリームと[切り離された][]\n入力元の Readable ストリーム</li>\n</ul>\n<!--\nThis is emitted whenever the [`unpipe()`][] method is called on a\nreadable stream, removing this writable from its set of destinations.\n-->\n\n<p>これは、Readable ストリームで [<code>unpipe()</code>][] メソッドが呼び出され、\nこの Writable ストリームが出力先から取り除かれた時に生成されます。\n\n</p>\n<pre><code class="\"javascript\"">var writer = getWritableStreamSomehow();\nvar reader = getReadableStreamSomehow();\nwriter.on('unpipe', function(src) {\n  console.error('something has stopped piping into the writer');\n  assert.equal(src, reader);\n});\nreader.pipe(writer);\nreader.unpipe(writer);</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "desc": "<!--\nEmitted if there was an error when writing or piping data.\n-->\n\n<p>データの書き込み中またはパイプ中にエラーが発生した場合に生成されます。\n\n</p>\n",
              "params": []
            }
          ]
        },
        {
          "textRaw": "Class: stream.Duplex",
          "type": "class",
          "name": "stream.Duplex",
          "desc": "<!--\nDuplex streams are streams that implement both the [Readable][] and\n[Writable][] interfaces.  See above for usage.\n-->\n\n<p>Duplex ストリームは [Readable][] と [Writable][] 両方のインターフェースを\n実装したストリームです。使い方は上記を参照してください。\n\n</p>\n<!--\nExamples of Duplex streams include:\n-->\n\n<p>Duplex ストリームを含む例:\n\n</p>\n<!--\n* [tcp sockets][]\n* [zlib streams][]\n* [crypto streams][]\n-->\n\n<ul>\n<li>[tcp のソケット][]</li>\n<li>[zlib のストリーム][]</li>\n<li>[crypto のストリーム][]</li>\n</ul>\n"
        },
        {
          "textRaw": "Class: stream.Transform",
          "type": "class",
          "name": "stream.Transform",
          "desc": "<!--\nTransform streams are [Duplex][] streams where the output is in some way\ncomputed from the input.  They implement both the [Readable][] and\n[Writable][] interfaces.  See above for usage.\n-->\n\n<p>Transform ストリームは、入力から何らかの方法で出力が計算される [Duplex][]\nストリームです。\nそれらは [Readable][] と [Writable][] 両方のインターフェースを実装します。\n使い方は上記を参照してください。\n\n</p>\n<!--\nExamples of Transform streams include:\n-->\n\n<p>Transform ストリームを含む例:\n\n</p>\n<!--\n* [zlib streams][]\n* [crypto streams][]\n-->\n\n<ul>\n<li>[zlib のストリーム][]</li>\n<li>[crypto のストリーム][]</li>\n</ul>\n"
        }
      ],
      "miscs": [
        {
          "textRaw": "API for Stream Consumers",
          "name": "API for Stream Consumers",
          "type": "misc",
          "desc": "<!--\nStreams can be either [Readable][], [Writable][], or both ([Duplex][]).\n-->\n\n<p>ストリームは、[Readable][]、[Writable][]、またはその両方 ([Duplex][])\nのいずれかになることができます。\n\n</p>\n<!--\nAll streams are EventEmitters, but they also have other custom methods\nand properties depending on whether they are Readable, Writable, or\nDuplex.\n-->\n\n<p>全てのストリームは EventEmitter ですが、Readable、Writable、または Duplex\nのいずれであるかによって、独自のメソッドやプロパティを持ちます。\n\n</p>\n<!--\nIf a stream is both Readable and Writable, then it implements all of\nthe methods and events below.  So, a [Duplex][] or [Transform][] stream is\nfully described by this API, though their implementation may be\nsomewhat different.\n-->\n\n<p>もしストリームが [Readable][] と[Writable][] の両方であるなら、\nそれは以下の全てのメソッドとイベントを実装します。\n[Duplex][] または [Transform][] ストリームの実装は多少異なる場合がありますが、\nこの API によって詳細に説明されます。\n\n</p>\n<!--\nIt is not necessary to implement Stream interfaces in order to consume\nstreams in your programs.  If you **are** implementing streaming\ninterfaces in your own program, please also refer to\n[API for Stream Implementors][] below.\n-->\n\n<p>プログラムの中でストリームからのデータを消費するために、\nストリームのインターフェースを実装する必要はありません。\nもしプログラムの中でストリーミングインターフェースを実装 <strong>する</strong> なら、\n以下の [ストリーム実装者向けの API][] を参照してください。\n\n</p>\n<!--\nAlmost all Node programs, no matter how simple, use Streams in some\nway.  Here is an example of using Streams in a Node program:\n-->\n\n<p>ほとんど全ての Node プログラムは、どんなに単純であっても、\n何らかの方法でストリームを利用します。\nこれはストリームを利用する Node プログラムの例です:\n\n</p>\n<pre><code class="\"javascript\"">var http = require('http');\n\nvar server = http.createServer(function (req, res) {\n  // req is an http.IncomingMessage, which is a Readable Stream\n  // res is an http.ServerResponse, which is a Writable Stream\n\n  var body = '';\n  // we want to get the data as utf8 strings\n  // If you don't set an encoding, then you'll get Buffer objects\n  req.setEncoding('utf8');\n\n  // Readable streams emit 'data' events once a listener is added\n  req.on('data', function (chunk) {\n    body += chunk;\n  })\n\n  // the end event tells you that you have entire body\n  req.on('end', function () {\n    try {\n      var data = JSON.parse(body);\n    } catch (er) {\n      // uh oh!  bad json!\n      res.statusCode = 400;\n      return res.end('error: ' + er.message);\n    }\n\n    // write back something interesting to the user:\n    res.write(typeof data);\n    res.end();\n  })\n})\n\nserver.listen(1337);\n\n// $ curl localhost:1337 -d '{}'\n// object\n// $ curl localhost:1337 -d '"foo"'\n// string\n// $ curl localhost:1337 -d 'not json'\n// error: Unexpected token o</code></pre>\n",
          "classes": [
            {
              "textRaw": "Class: stream.Readable",
              "type": "class",
              "name": "stream.Readable",
              "desc": "<!--\nThe Readable stream interface is the abstraction for a *source* of\ndata that you are reading from.  In other words, data comes *out* of a\nReadable stream.\n-->\n\n<p>Readable ストリームのインターフェースは、あなたが読み込むデータの抽象的な\n<em>発生源</em> です。言い換えると、データは Readable ストリームから <em>出て</em> きます。\n\n</p>\n<!--\nA Readable stream will not start emitting data until you indicate that\nyou are ready to receive it.\n-->\n\n<p>Readable ストリームは、あなたがデータを受け取る準備ができたと指示するまでは、\nデータの生成を開始しません。\n\n</p>\n<!--\nReadable streams have two \"modes\": a **flowing mode** and a **non-flowing\nmode**.  When in flowing mode, data is read from the underlying system\nand provided to your program as fast as possible.  In non-flowing\nmode, you must explicitly call `stream.read()` to get chunks of data\nout.\n-->\n\n<p>Readable ストリームは二つの "モード": <strong>flowing モード</strong> と\n<strong>non-flowing モード</strong> を持っています。\nflowing モードに入ると、データは下層のシステムから読み込まれると、\n可能な限り素早くあなたのプログラムに届けられます。\nnon-flowing モードでは、データの断片を取り出すために、明示的に\n<code>stream.read()</code> を呼び出す必要があります。\n\n</p>\n<!--\nExamples of readable streams include:\n-->\n\n<p>Readable ストリームを含む例:\n\n</p>\n<!--\n* [http responses, on the client](http.html#http_http_incomingmessage)\n* [http requests, on the server](http.html#http_http_incomingmessage)\n* [fs read streams](fs.html#fs_class_fs_readstream)\n* [zlib streams][]\n* [crypto streams][]\n* [tcp sockets][]\n* [child process stdout and stderr][]\n* [process.stdin][]\n-->\n\n<ul>\n<li><a href="\"http.html#http_http_incomingmessage\"">クライアントの http レスポンス</a></li>\n<li><a href="\"http.html#http_http_incomingmessage\"">サーバの http リクエスト</a></li>\n<li><a href="\"fs.html#fs_class_fs_readstream\"">fs の ReadStream</a></li>\n<li>[zlib のストリーム][]</li>\n<li>[crypto のストリーム][]</li>\n<li>[tcp のソケット][]</li>\n<li>[child_process の標準出力と標準エラー出力][]</li>\n<li>[process.stdin][]</li>\n</ul>\n",
              "events": [
                {
                  "textRaw": "Event: 'readable'",
                  "type": "event",
                  "name": "readable",
                  "desc": "<!--\nWhen a chunk of data can be read from the stream, it will emit a\n`'readable'` event.\n-->\n\n<p>ストリームからデータの断片を読み込むことが可能となった時、\n<code>'readable'</code> イベントが生成されます。\n\n</p>\n<!--\nIn some cases, listening for a `'readable'` event will cause some data\nto be read into the internal buffer from the underlying system, if it\nhadn't already.\n-->\n\n<p>あるケースでは、<code>'readable'</code> イベントを監視することは下層のシステムからデータを内部バッファへ読み込む原因となります (それがまだ行われていなかった場合)。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on('readable', function() {\n  // there is some data to read now\n})</code></pre>\n<!--\nOnce the internal buffer is drained, a `readable` event will fire\nagain when more data is available.\n-->\n\n<p>内部バッファが空になると、データが利用可能になった時に\n<code>'readable'</code> イベントは再び生成されます。\n\n</p>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'data'",
                  "type": "event",
                  "name": "data",
                  "desc": "<!--\n* `chunk` {Buffer | String} The chunk of data.\n-->\n\n<ul>\n<li><code>chunk</code> {Buffer | String} データの断片。</li>\n</ul>\n<!--\nIf you attach a `data` event listener, then it will switch the stream\ninto flowing mode, and data will be passed to your handler as soon as\nit is available.\n-->\n\n<p><code>'data'</code> イベントのリスナを追加すると、ストリームは flowing モードに切り替わり、\nデータは利用可能になるとすぐにあなたのハンドラに渡されます。\n\n</p>\n<!--\nIf you just want to get all the data out of the stream as fast as\npossible, this is the best way to do so.\n-->\n\n<p>ストリームから出てくる全てのデータをできるだけ素早く欲しいのなら、\nこれが最善の方法です。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on('data', function(chunk) {\n  console.log('got %d bytes of data', chunk.length);\n})</code></pre>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'end'",
                  "type": "event",
                  "name": "end",
                  "desc": "<!--\nThis event fires when no more data will be provided.\n-->\n\n<p>このイベントは、提供するデータがもう無くなった場合に生成されます。\n\n</p>\n<!--\nNote that the `end` event **will not fire** unless the data is\ncompletely consumed.  This can be done by switching into flowing mode,\nor by calling `read()` repeatedly until you get to the end.\n-->\n\n<p><code>'end'</code> イベントはデータが完全に消費されるまでは <strong>生成されない</strong>\nことに注意してください。\nそれは flowing モードに切り替えることによって、または終わりに達するまで\n<code>read()</code> を繰り返し呼び出すことによって達成することができます。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on('data', function(chunk) {\n  console.log('got %d bytes of data', chunk.length);\n})\nreadable.on('end', function() {\n  console.log('there will be no more data.');\n});</code></pre>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'close'",
                  "type": "event",
                  "name": "close",
                  "desc": "<!--\nEmitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n-->\n\n<p>下層のリソース (例えば背後のファイル記述子) がクローズされた時に生成されます。\n全てのストリームがこのイベントを発生するわけではありません。\n\n</p>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'error'",
                  "type": "event",
                  "name": "error",
                  "desc": "<!--\nEmitted if there was an error receiving data.\n-->\n\n<p>データの受信でエラーがあると生成されます。\n\n</p>\n",
                  "params": []
                }
              ],
              "methods": [
                {
                  "textRaw": "readable.read([size])",
                  "type": "method",
                  "name": "read",
                  "desc": "<!--\n* `size` {Number} Optional argument to specify how much data to read.\n* Return {String | Buffer | null}\n-->\n\n<ul>\n<li><code>size</code> {Number} どれだけのデータを読み込むか指定するオプションの引数。</li>\n<li>Return {String | Buffer | null}</li>\n</ul>\n<!--\nThe `read()` method pulls some data out of the internal buffer and\nreturns it.  If there is no data available, then it will return\n`null`.\n-->\n\n<p><code>read()</code> メソッドは内部バッファからデータを取り出して返します。\nもし利用可能なデータが無ければ、<code>null</code> を返します。\n\n</p>\n<!--\nIf you pass in a `size` argument, then it will return that many\nbytes.  If `size` bytes are not available, then it will return `null`.\n-->\n\n<p><code>size</code> 引数を指定すると、その長さ (バイト数または文字数) のデータを返します。\nもし <code>size</code> で指定された長さのデータが揃っていない場合は <code>null</code> を返します。\n\n</p>\n<!--\nIf you do not specify a `size` argument, then it will return all the\ndata in the internal buffer.\n-->\n\n<p><code>size</code> 引数を指定しなかった場合は、内部バッファにある全てのデータが返されます。\n\n</p>\n<!--\nThis method should only be called in non-flowing mode.  In\nflowing-mode, this method is called automatically until the internal\nbuffer is drained.\n-->\n\n<p>このメソッドは non-flowing モードの場合に限って呼び出されるべきです。\nflowing モードでは、内部バッファが空になるまで\nこのメソッドは自動的に呼び出されます。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on('readable', function() {\n  var chunk;\n  while (null !== (chunk = readable.read())) {\n    console.log('got %d bytes of data', chunk.length);\n  }\n});</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "size",
                          "optional": true
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "readable.setEncoding(encoding)",
                  "type": "method",
                  "name": "setEncoding",
                  "desc": "<!--\n* `encoding` {String} The encoding to use.\n-->\n\n<ul>\n<li><code>encoding</code> {String} 使用するエンコーディング。</li>\n</ul>\n<!--\nCall this function to cause the stream to return strings of the\nspecified encoding instead of Buffer objects.  For example, if you do\n`readable.setEncoding('utf8')`, then the output data will be\ninterpreted as UTF-8 data, and returned as strings.  If you do\n`readable.setEncoding('hex')`, then the data will be encoded in\nhexadecimal string format.\n-->\n\n<p>この関数を呼び出すと、ストリームは Buffer オブジェクトの代わりに\n指定されたエンコーディングによる文字列を返すようになります。\n例えば、<code>readable.setEncoding('utf8')</code> とすると、得られるデータは\nUTF-8 のデータとして解釈され、文字列が返されます。\n<code>readable.setEncoding('hex')</code> とすると、データは 16 進フォーマットの\n文字列にエンコードされます。\n\n</p>\n<!--\nThis properly handles multi-byte characters that would otherwise be\npotentially mangled if you simply pulled the Buffers directly and\ncalled `buf.toString(encoding)` on them.  If you want to read the data\nas strings, always use this method.\n-->\n\n<p>これは、Buffer を直接取得して単純に <code>buf.toString(encoding)</code>\nを呼び出した場合は潜在的にめちゃくちゃになるのとは異なり、\nマルチバイト文字を正しく扱います。\nデータを文字列として読み込みたければ、常にこのメソッドを使用してください。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.setEncoding('utf8');\nreadable.on('data', function(chunk) {\n  assert.equal(typeof chunk, 'string');\n  console.log('got %d characters of string data', chunk.length);\n})</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "encoding"
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "readable.resume()",
                  "type": "method",
                  "name": "resume",
                  "desc": "<!--\nThis method will cause the readable stream to resume emitting `data`\nevents.\n-->\n\n<p>このメソッドは Readable ストリームが <code>'data'</code> イベントの生成を\n再開するようにします。\n\n</p>\n<!--\nThis method will switch the stream into flowing-mode.  If you do *not*\nwant to consume the data from a stream, but you *do* want to get to\nits `end` event, you can call `readable.resume()` to open the flow of\ndata.\n-->\n\n<p>このメソッドはストリームを flowing モードに切り替えます。\nもしストリームからのデータを消費する必要が <em>なく</em>、しかし <code>'end'</code> イベントを\n受け取る必要が <em>ある</em> なら、<code>readable.resume()</code> を呼び出してデータのフローを\n開くことができます。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.resume();\nreadable.on('end', function(chunk) {\n  console.log('got to the end, but did not read anything');\n})</code></pre>\n",
                  "signatures": [
                    {
                      "params": []
                    }
                  ]
                },
                {
                  "textRaw": "readable.pause()",
                  "type": "method",
                  "name": "pause",
                  "desc": "<!--\nThis method will cause a stream in flowing-mode to stop emitting\n`data` events.  Any data that becomes available will remain in the\ninternal buffer.\n-->\n\n<p>このメソッドはストリームを flowing モードに切り替えて、\n<code>'data'</code> イベントの生成を中断します。\n利用可能になったデータは内部バッファの中に残ります。\n\n</p>\n<!--\nThis method is only relevant in flowing mode.  When called on a\nnon-flowing stream, it will switch into flowing mode, but remain\npaused.\n-->\n\n<p>このメソッドは flowing モードにだけ関連します。\nnon-flowing モードのストリームで呼ばれた場合は、flowing モードに切り替わり、\n残りのデータは休止します。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nreadable.on('data', function(chunk) {\n  console.log('got %d bytes of data', chunk.length);\n  readable.pause();\n  console.log('there will be no more data for 1 second');\n  setTimeout(function() {\n    console.log('now data will start flowing again');\n    readable.resume();\n  }, 1000);\n})</code></pre>\n",
                  "signatures": [
                    {
                      "params": []
                    }
                  ]
                },
                {
                  "textRaw": "readable.pipe(destination, [options])",
                  "type": "method",
                  "name": "pipe",
                  "* `destination` {[Writable][] Stream} The destination for writing data\n* `options` {Object} Pipe options\n  * `end` {Boolean} End the writer when the reader ends. Default": "`true`",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`destination` {[Writable][] Stream} データの書き込み先。 ",
                          "name": "destination",
                          "type": "[Writable][] Stream",
                          "desc": "データの書き込み先。"
                        },
                        {
                          "textRaw": "`options` {Object} パイプオプション ",
                          "options": [
                            {
                              "textRaw": "`end` {Boolean} 読み込み元が終了すると書き込み先を終了します。 デフォルトは `true` ",
                              "name": "end",
                              "type": "Boolean",
                              "desc": "読み込み元が終了すると書き込み先を終了します。 デフォルトは `true`"
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "desc": "パイプオプション",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "destination"
                        },
                        {
                          "name": "options",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<!--\nThis method pulls all the data out of a readable stream, and writes it\nto the supplied destination, automatically managing the flow so that\nthe destination is not overwhelmed by a fast readable stream.\n-->\n\n<p>このメソッドは Readable ストリームから全てのデータを引き出し、\n与えられた行き先に書き込みます。\n高速な Readable ストリームによって出力先が圧迫されないように、\n自動的にフロー制御を行います。\n\n</p>\n<!--\nMultiple destinations can be piped to safely.\n-->\n\n<p>複数の出力先を安全に連結することができます。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nvar writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt'\nreadable.pipe(writable);</code></pre>\n<!--\nThis function returns the destination stream, so you can set up pipe\nchains like so:\n-->\n\n<p>この関数は出力先となるストリーム返すので、このようにパイプのチェーンを\n組み立てることができます。\n\n</p>\n<pre><code class="\"javascript\"">var r = fs.createReadStream('file.txt');\nvar z = zlib.createGzip();\nvar w = fs.createWriteStream('file.txt.gz');\nr.pipe(z).pipe(w);</code></pre>\n<!--\nFor example, emulating the Unix `cat` command:\n-->\n\n<p>Unix の <code>cat</code> コマンドをエミュレートする例:\n\n</p>\n<pre><code class="\"javascript\"">process.stdin.pipe(process.stdout);</code></pre>\n<!--\nBy default [`end()`][] is called on the destination when the source stream\nemits `end`, so that `destination` is no longer writable. Pass `{ end:\nfalse }` as `options` to keep the destination stream open.\n-->\n\n<p>デフォルトでは、出力先の [<code>end()</code>][] は入力元のストリームで\n<code>'end'</code> が生成された時に呼び出されます。そのため、<code>destination</code>\nはもう書き込み可能ではなくなります。\n<code>{end: false }</code> を <code>options</code> として渡すことにより、出力先ストリームを\nオープンしたままにしておくことができます。\n\n</p>\n<!--\nThis keeps `writer` open so that \"Goodbye\" can be written at the\nend.\n-->\n\n<p>これは <code>writer</code> をオープンしたままにすることにより、最後に\n<code>"Goodbye"</code> と書き込むことができます。\n\n</p>\n<pre><code class="\"javascript\"">reader.pipe(writer, { end: false });\nreader.on('end', function() {\n  writer.end('Goodbye\\n');\n});</code></pre>\n<!--\nNote that `process.stderr` and `process.stdout` are never closed until\nthe process exits, regardless of the specified options.\n-->\n\n<p><code>process.stderr</code> および <code>process.stdout</code> は、オプションの指定に関係なく、\nプロセスが終了するまで決してクローズされないことに注意してください。\n\n</p>\n"
                },
                {
                  "textRaw": "readable.unpipe([destination])",
                  "type": "method",
                  "name": "unpipe",
                  "desc": "<!--\n* `destination` {[Writable][] Stream} Optional specific stream to unpipe\n-->\n\n<ul>\n<li><code>destination</code> {[Writable][] Stream} オプションのパイプを解除するストリーム</li>\n</ul>\n<!--\nThis method will remove the hooks set up for a previous `pipe()` call.\n-->\n\n<p>このメソッドは以前の <code>pipe()</code> 呼び出しで設定されたフックを取り除きます。\n\n</p>\n<!--\nIf the destination is not specified, then all pipes are removed.\n-->\n\n<p><code>destination</code> が指定されなかった場合は、全てのパイプが取り除かれます。\n\n</p>\n<!--\nIf the destination is specified, but no pipe is set up for it, then\nthis is a no-op.\n-->\n\n<p><code>destination</code> が指定されたものの、それがパイプされていなかった場合、\nこれは何もしません。\n\n</p>\n<pre><code class="\"javascript\"">var readable = getReadableStreamSomehow();\nvar writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second\nreadable.pipe(writable);\nsetTimeout(function() {\n  console.log('stop writing to file.txt');\n  readable.unpipe(writable);\n  console.log('manually close the file stream');\n  writable.end();\n}, 1000);</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "destination",
                          "optional": true
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "readable.unshift(chunk)",
                  "type": "method",
                  "name": "unshift",
                  "desc": "<!--\n* `chunk` {Buffer | String} Chunk of data to unshift onto the read queue\n-->\n\n<ul>\n<li><code>chunk</code> {Buffer | String} 読み込みキューの先頭に戻されるデータの断片</li>\n</ul>\n<!--\nThis is useful in certain cases where a stream is being consumed by a\nparser, which needs to \"un-consume\" some data that it has\noptimistically pulled out of the source, so that the stream can be\npassed on to some other party.\n-->\n\n<p>これはストリームがパーサによって消費されるケースにおいて有用です。\nそれはソースから楽観的に取り出したデータを「消費しなかった」ことにして、\nストリームが他のところにデータを渡せるようにする場合に必要です。\n\n</p>\n<!--\nIf you find that you must often call `stream.unshift(chunk)` in your\nprograms, consider implementing a [Transform][] stream instead.  (See API\nfor Stream Implementors, below.)\n-->\n\n<p><code>stream.unshift(chunk)</code> を頻繁に呼び出さなくてはならないとしたら、\n代わりに [Transform][] ストリームを実装することを検討してください\n(後述する [ストリーム実装者向けの API][] を参照してください)。\n\n</p>\n<pre><code class="\"javascript\"">// Pull off a header delimited by \\n\\n\n// use unshift() if we get too much\n// Call the callback with (error, header, stream)\nvar StringDecoder = require('string_decoder').StringDecoder;\nfunction parseHeader(stream, callback) {\n  stream.on('error', callback);\n  stream.on('readable', onReadable);\n  var decoder = new StringDecoder('utf8');\n  var header = '';\n  function onReadable() {\n    var chunk;\n    while (null !== (chunk = stream.read())) {\n      var str = decoder.write(chunk);\n      if (str.match(/\\n\\n/)) {\n        // found the header boundary\n        var split = str.split(/\\n\\n/);\n        header += split.shift();\n        var remaining = split.join('\\n\\n');\n        var buf = new Buffer(remaining, 'utf8');\n        if (buf.length)\n          stream.unshift(buf);\n        stream.removeListener('error', callback);\n        stream.removeListener('readable', onReadable);\n        // now the body of the message can be read from the stream.\n        callback(null, header, stream);\n      } else {\n        // still reading the header.\n        header += str;\n      }\n    }\n  }\n}</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "chunk"
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "readable.wrap(stream)",
                  "type": "method",
                  "name": "wrap",
                  "desc": "<!--\n* `stream` {Stream} An \"old style\" readable stream\n-->\n\n<ul>\n<li><code>stream</code> {Stream} 「古いスタイル」の Readable ストリーム</li>\n</ul>\n<!--\nVersions of Node prior to v0.10 had streams that did not implement the\nentire Streams API as it is today.  (See \"Compatibility\" below for\nmore information.)\n-->\n\n<p>v0.10 より前のバージョンの Node には、今日の全ストリーム API を実装していない\nストリームがありました (より詳細は後述する「[互換性][]」を参照してください)。\n\n</p>\n<!--\nIf you are using an older Node library that emits `'data'` events and\nhas a `pause()` method that is advisory only, then you can use the\n`wrap()` method to create a [Readable][] stream that uses the old stream\nas its data source.\n-->\n\n<p>もし、<code>'data'</code> イベントを生成し、アドバイスだけを行う <code>pause()</code>\nメソッドを持つ、古い Node ライブラリを使っているなら、\n<code>wrap()</code> メソッドは古いストリームをデータソースとして使用する\n[Readable][] ストリームを作成します。\n\n</p>\n<!--\nYou will very rarely ever need to call this function, but it exists\nas a convenience for interacting with old Node programs and libraries.\n-->\n\n<p>この関数を呼び出す必要は滅多にありませんが、これは古い Node\nプログラム及びライブラリと相互作用するための利便性のために存在します。\n\n</p>\n<!--\nFor example:\n-->\n\n<p>例:\n\n</p>\n<pre><code class="\"javascript\"">var OldReader = require('./old-api-module.js').OldReader;\nvar oreader = new OldReader;\nvar Readable = require('stream').Readable;\nvar myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', function() {\n  myReader.read(); // etc.\n});</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "stream"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Class: stream.Writable",
              "type": "class",
              "name": "stream.Writable",
              "desc": "<!--\nThe Writable stream interface is an abstraction for a *destination*\nthat you are writing data *to*.\n-->\n\n<p>Writable ストリームのインターフェースは、あなたがデータを書き込む抽象的な\n<em>行き先</em> です。\n\n</p>\n<!--\nExamples of writable streams include:\n-->\n\n<p>Writable ストリームを含む例:\n\n</p>\n<!--\n* [http requests, on the client](http.html#http_class_http_clientrequest)\n* [http responses, on the server](http.html#http_class_http_serverresponse)\n* [fs write streams](fs.html#fs_class_fs_writestream)\n* [zlib streams][]\n* [crypto streams][]\n* [tcp sockets][]\n* [child process stdin](child_process.html#child_process_child_stdin)\n* [process.stdout][], [process.stderr][]\n-->\n\n<ul>\n<li><a href="\"http.html#http_class_http_clientrequest\"">クライアントの http リクエスト</a></li>\n<li><a href="\"http.html#http_class_http_serverresponse\"">サーバの http レスポンス</a></li>\n<li><a href="\"fs.html#fs_class_fs_writestream\"">fs の WriteStream</a></li>\n<li>[zlib のストリーム][]</li>\n<li>[crypto のストリーム][]</li>\n<li>[tcp のソケット][]</li>\n<li><a href="\"child_process.html#child_process_child_stdin\"">child_process の標準入力</a></li>\n<li>[process.stdout][], [process.stderr][]</li>\n</ul>\n",
              "methods": [
                {
                  "textRaw": "writable.write(chunk, [encoding], [callback])",
                  "type": "method",
                  "name": "write",
                  "desc": "<!--\n* `chunk` {String | Buffer} The data to write\n* `encoding` {String} The encoding, if `chunk` is a String\n* `callback` {Function} Callback for when this chunk of data is flushed\n* Returns: {Boolean} True if the data was handled completely.\n-->\n\n<ul>\n<li><code>chunk</code> {String | Buffer} 書き込まれるデータ</li>\n<li><code>encoding</code> {String} もし <code>chunk</code> が文字列なら、そのエンコーディング</li>\n<li><code>callback</code> {Function} データが掃き出された時に呼び出されるコールバック</li>\n<li>Returns: {Boolean} データが完全に処理された場合は <code>true</code>。</li>\n</ul>\n<!--\nThis method writes some data to the underlying system, and calls the\nsupplied callback once the data has been fully handled.\n-->\n\n<p>このメソッドはデータを下層のシステムに書き込み、データが完全に処理されると\n与えられたコールバックを一度だけ呼び出します。\n\n</p>\n<!--\nThe return value indicates if you should continue writing right now.\nIf the data had to be buffered internally, then it will return\n`false`.  Otherwise, it will return `true`.\n-->\n\n<p>戻り値は書き込みをすぐに続けていいかどうかを示します。\nもしデータが内部にバッファリングされなければならないなら <code>false</code> を返します。\nそうでなければ <code>true</code> を返します。\n\n</p>\n<!--\nThis return value is strictly advisory.  You MAY continue to write,\neven if it returns `false`.  However, writes will be buffered in\nmemory, so it is best not to do this excessively.  Instead, wait for\nthe `drain` event before writing more data.\n-->\n\n<p>この戻り値は完全にアドバイス的です。\nもしこれが <code>false</code> を返しても、あなたは書き込みを続けることが「できます」。\nしかしながら、書き込まれたデータはメモリにバッファリングされるため、\nこれを過剰にしないことが最善です。\n代わりに、より多くのデータを書く前に <code>'drain'</code> イベントを待機してください。\n\n</p>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "chunk"
                        },
                        {
                          "name": "encoding",
                          "optional": true
                        },
                        {
                          "name": "callback",
                          "optional": true
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "writable.end([chunk], [encoding], [callback])",
                  "type": "method",
                  "name": "end",
                  "desc": "<!--\n* `chunk` {String | Buffer} Optional data to write\n* `encoding` {String} The encoding, if `chunk` is a String\n* `callback` {Function} Optional callback for when the stream is finished\n-->\n\n<ul>\n<li><code>chunk</code> {String | Buffer} オプションの書き込まれるデータ</li>\n<li><code>encoding</code> {String} もし <code>chunk</code> が文字列なら、そのエンコーディング</li>\n<li><code>callback</code> {Function} ストリームが終了時に呼び出される、\nオプションのコールバック</li>\n</ul>\n<!--\nCall this method when no more data will be written to the stream.  If\nsupplied, the callback is attached as a listener on the `finish` event.\n-->\n\n<p>これ以上データをストリームに書き込まない場合に呼び出してください。\nコールバックが与えられた場合、それは <code>'finish'</code> イベントのリスナとして\nアタッチされます。\n\n</p>\n<!--\nCalling [`write()`][] after calling [`end()`][] will raise an error.\n-->\n\n<p>[<code>end()</code>][] を呼び出した後で [<code>write()</code>][] を呼び出すとエラーになります。\n\n</p>\n<pre><code class="\"javascript\"">// write 'hello, ' and then end with 'world!'\nhttp.createServer(function (req, res) {\n  res.write('hello, ');\n  res.end('world!');\n  // writing more now is not allowed!\n});</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "chunk",
                          "optional": true
                        },
                        {
                          "name": "encoding",
                          "optional": true
                        },
                        {
                          "name": "callback",
                          "optional": true
                        }
                      ]
                    }
                  ]
                }
              ],
              "events": [
                {
                  "textRaw": "Event: 'drain'",
                  "type": "event",
                  "name": "drain",
                  "desc": "<!--\nIf a [`writable.write(chunk)`][] call returns false, then the `drain`\nevent will indicate when it is appropriate to begin writing more data\nto the stream.\n-->\n\n<p>[<code>write(chunk, encoding, callback)</code>][] の呼び出しが <code>false</code> を返した場合、\nより多くのデータをいつストリームに書き始めるのが適切かを\n<code>'drain'</code> イベントによって示します。\n\n</p>\n<pre><code class="\"javascript\"">// Write the data to the supplied writable stream 1MM times.\n// Be attentive to back-pressure.\nfunction writeOneMillionTimes(writer, data, encoding, callback) {\n  var i = 1000000;\n  write();\n  function write() {\n    var ok = true;\n    do {\n      i -= 1;\n      if (i === 0) {\n        // last time!\n        writer.write(data, encoding, callback);\n      } else {\n        // see if we should continue, or wait\n        // don't pass the callback, because we're not done yet.\n        ok = writer.write(data, encoding);\n      }\n    } while (i > 0 && ok);\n    if (i > 0) {\n      // had to stop early!\n      // write some more once it drains\n      writer.once('drain', write);\n    }\n  }\n}</code></pre>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'finish'",
                  "type": "event",
                  "name": "finish",
                  "desc": "<!--\nWhen the [`end()`][] method has been called, and all data has been flushed\nto the underlying system, this event is emitted.\n-->\n\n<p>[<code>end()</code>][] メソッドが呼び出されて、全てのデータが下層のシステムに\n掃き出されると、このイベントが生成されます。\n\n</p>\n<pre><code class="\"javascript\"">var writer = getWritableStreamSomehow();\nfor (var i = 0; i < 100; i ++) {\n  writer.write('hello, #' + i + '!\\n');\n}\nwriter.end('this is the end\\n');\nwriter.on('finish', function() {\n  console.error('all writes are now complete.');\n});</code></pre>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'pipe'",
                  "type": "event",
                  "name": "pipe",
                  "desc": "<!--\n* `src` {[Readable][] Stream} source stream that is piping to this writable\n-->\n\n<ul>\n<li><code>src</code> {[Readable][] Stream} この Writable ストリームにつながれた\n入力元のストリーム</li>\n</ul>\n<!--\nThis is emitted whenever the `pipe()` method is called on a readable\nstream, adding this writable to its set of destinations.\n-->\n\n<p>これは、Readable ストリームの <code>pipe()</code> メソッドが呼び出されて、\nこの Writable ストリームが出力先として加えられた時に生成されます。\n\n</p>\n<pre><code class="\"javascript\"">var writer = getWritableStreamSomehow();\nvar reader = getReadableStreamSomehow();\nwriter.on('pipe', function(src) {\n  console.error('something is piping into the writer');\n  assert.equal(src, reader);\n});\nreader.pipe(writer);</code></pre>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'unpipe'",
                  "type": "event",
                  "name": "unpipe",
                  "desc": "<!--\n* `src` {[Readable][] Stream} The source stream that [unpiped][] this writable\n-->\n\n<ul>\n<li><code>src</code> {[Readable][] Stream} この Writable ストリームと[切り離された][]\n入力元の Readable ストリーム</li>\n</ul>\n<!--\nThis is emitted whenever the [`unpipe()`][] method is called on a\nreadable stream, removing this writable from its set of destinations.\n-->\n\n<p>これは、Readable ストリームで [<code>unpipe()</code>][] メソッドが呼び出され、\nこの Writable ストリームが出力先から取り除かれた時に生成されます。\n\n</p>\n<pre><code class="\"javascript\"">var writer = getWritableStreamSomehow();\nvar reader = getReadableStreamSomehow();\nwriter.on('unpipe', function(src) {\n  console.error('something has stopped piping into the writer');\n  assert.equal(src, reader);\n});\nreader.pipe(writer);\nreader.unpipe(writer);</code></pre>\n",
                  "params": []
                },
                {
                  "textRaw": "Event: 'error'",
                  "type": "event",
                  "name": "error",
                  "desc": "<!--\nEmitted if there was an error when writing or piping data.\n-->\n\n<p>データの書き込み中またはパイプ中にエラーが発生した場合に生成されます。\n\n</p>\n",
                  "params": []
                }
              ]
            },
            {
              "textRaw": "Class: stream.Duplex",
              "type": "class",
              "name": "stream.Duplex",
              "desc": "<!--\nDuplex streams are streams that implement both the [Readable][] and\n[Writable][] interfaces.  See above for usage.\n-->\n\n<p>Duplex ストリームは [Readable][] と [Writable][] 両方のインターフェースを\n実装したストリームです。使い方は上記を参照してください。\n\n</p>\n<!--\nExamples of Duplex streams include:\n-->\n\n<p>Duplex ストリームを含む例:\n\n</p>\n<!--\n* [tcp sockets][]\n* [zlib streams][]\n* [crypto streams][]\n-->\n\n<ul>\n<li>[tcp のソケット][]</li>\n<li>[zlib のストリーム][]</li>\n<li>[crypto のストリーム][]</li>\n</ul>\n"
            },
            {
              "textRaw": "Class: stream.Transform",
              "type": "class",
              "name": "stream.Transform",
              "desc": "<!--\nTransform streams are [Duplex][] streams where the output is in some way\ncomputed from the input.  They implement both the [Readable][] and\n[Writable][] interfaces.  See above for usage.\n-->\n\n<p>Transform ストリームは、入力から何らかの方法で出力が計算される [Duplex][]\nストリームです。\nそれらは [Readable][] と [Writable][] 両方のインターフェースを実装します。\n使い方は上記を参照してください。\n\n</p>\n<!--\nExamples of Transform streams include:\n-->\n\n<p>Transform ストリームを含む例:\n\n</p>\n<!--\n* [zlib streams][]\n* [crypto streams][]\n-->\n\n<ul>\n<li>[zlib のストリーム][]</li>\n<li>[crypto のストリーム][]</li>\n</ul>\n"
            }
          ]
        },
        {
          "textRaw": "API for Stream Implementors",
          "name": "API for Stream Implementors",
          "type": "misc",
          "desc": "<!--\nTo implement any sort of stream, the pattern is the same:\n-->\n\n<p>どのストリームを実装する場合でも、パターンは同じです:\n\n</p>\n<!--\n1. Extend the appropriate parent class in your own subclass.  (The\n   [`util.inherits`][] method is particularly helpful for this.)\n2. Call the appropriate parent class constructor in your constructor,\n   to be sure that the internal mechanisms are set up properly.\n2. Implement one or more specific methods, as detailed below.\n-->\n\n<ol>\n<li>それぞれの親クラスを拡張して、独自のサブクラスを作成する\n(特に [<code>util.inherits</code>][] メソッドはそのために役立ちます)。</li>\n<li>内部のメカニズムがきちんとセットアップされることを確実にするために、\nサブクラスのコンストラクタの中から親クラスのコンストラクタを呼び出す。</li>\n<li>以下で詳述される、いくつかの特別なメソッドを実装する。</li>\n</ol>\n<!--\nThe class to extend and the method(s) to implement depend on the sort\nof stream class you are writing:\n-->\n\n<p>拡張するクラスと実装するメソッドは、あなたが書こうとしているストリームの種類に\n依存します。\n\n</p>\n<!--\n<table>\n  <thead>\n    <tr>\n      <th>\n        <p>Use-case</p>\n      </th>\n      <th>\n        <p>Class</p>\n      </th>\n      <th>\n        <p>Method(s) to implement</p>\n      </th>\n    </tr>\n  </thead>\n  <tr>\n    <td>\n      <p>Reading only</p>\n    </td>\n    <td>\n      <p>[Readable](#stream_class_stream_readable_1)</p>\n    </td>\n    <td>\n      <p><code>[_read][]</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>Writing only</p>\n    </td>\n    <td>\n      <p>[Writable](#stream_class_stream_writable_1)</p>\n    </td>\n    <td>\n      <p><code>[_write][]</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>Reading and writing</p>\n    </td>\n    <td>\n      <p>[Duplex](#stream_class_stream_duplex_1)</p>\n    </td>\n    <td>\n      <p><code>[_read][]</code>, <code>[_write][]</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>Operate on written data, then read the result</p>\n    </td>\n    <td>\n      <p>[Transform](#stream_class_stream_transform_1)</p>\n    </td>\n    <td>\n      <p><code>_transform</code>, <code>_flush</code></p>\n    </td>\n  </tr>\n</table>\n-->\n\n<table>\n  <thead>\n    <tr>\n      <th>\n        <p>ユースケース</p>\n      </th>\n      <th>\n        <p>クラス</p>\n      </th>\n      <th>\n        <p>実装するメソッド</p>\n      </th>\n    </tr>\n  </thead>\n  <tr>\n    <td>\n      <p>読み込みのみ</p>\n    </td>\n    <td>\n      <p><a href="\"#stream_class_stream_readable_1\"">Readable</a></p>\n    </td>\n    <td>\n      <p><code>[_read][]</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>書き込みのみ</p>\n    </td>\n    <td>\n      <p><a href="\"#stream_class_stream_writable_1\"">Writable</a></p>\n    </td>\n    <td>\n      <p><code>[_write][]</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>読み込みと書き込み</p>\n    </td>\n    <td>\n      <p><a href="\"#stream_class_stream_duplex_1\"">Duplex</a></p>\n    </td>\n    <td>\n      <p><code>[_read][]</code>, <code>[_write][]</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <p>書き込まれたデータを変換し、その結果を読み込む</p>\n    </td>\n    <td>\n      <p><a href="\"#stream_class_stream_transform_1\"">Transform</a></p>\n    </td>\n    <td>\n      <p><code>[_transform][]</code>, <code>[_flush][]</code></p>\n    </td>\n  </tr>\n</table>\n\n<!--\nIn your implementation code, it is very important to never call the\nmethods described in [API for Stream Consumers][] above.  Otherwise, you\ncan potentially cause adverse side effects in programs that consume\nyour streaming interfaces.\n-->\n\n<p>あなたの実装コードの中では、決して [ストリーム利用者のための API][]\nで説明されたメソッドを呼び出さないことがとても重要です。\nそうでなければ、あなたのストリーミングインターフェースを利用するプログラムに\n有害な副作用を引き起こす原因となり得ます。\n\n</p>\n",
          "examples": [
            {
              "textRaw": "Class: stream.Readable",
              "type": "example",
              "name": "stream.Readable",
              "desc": "<!--\n`stream.Readable` is an abstract class designed to be extended with an\nunderlying implementation of the [`_read(size)`][] method.\n-->\n\n<p><code>stream.Readable</code> は抽象クラスで、下層の実装として [<code>_read(size)</code>][]\nメソッドを実装することで拡張されるように設計されています。\n\n</p>\n<!--\nPlease see above under [API for Stream Consumers][] for how to consume\nstreams in your programs.  What follows is an explanation of how to\nimplement Readable streams in your programs.\n-->\n\n<p>プログラムの中で Readable ストリームを利用する方法については、\n前述の [ストリーム利用者のための API][] を参照してください。\nこの後に続くのは、あなたのプログラムの中で Readable ストリームを\n実装する方法の説明です。\n\n</p>\n<h4>Example: A Counting Stream</h4>\n<!--\nThis is a basic example of a Readable stream.  It emits the numerals\nfrom 1 to 1,000,000 in ascending order, and then ends.\n-->\n\n<p>これは Readable ストリームの基本的な例です。\nそれは 1 から 1,000,000 までの数を昇順で生成し、そして終了します。\n\n</p>\n<pre><code class="\"javascript\"">var Readable = require('stream').Readable;\nvar util = require('util');\nutil.inherits(Counter, Readable);\n\nfunction Counter(opt) {\n  Readable.call(this, opt);\n  this._max = 1000000;\n  this._index = 1;\n}\n\nCounter.prototype._read = function() {\n  var i = this._index++;\n  if (i > this._max)\n    this.push(null);\n  else {\n    var str = '' + i;\n    var buf = new Buffer(str, 'ascii');\n    this.push(buf);\n  }\n};</code></pre>\n<h4>Example: SimpleProtocol v1 (Sub-optimal)</h4>\n<!--\nThis is similar to the `parseHeader` function described above, but\nimplemented as a custom stream.  Also, note that this implementation\ndoes not convert the incoming data to a string.\n-->\n\n<p>これは前に説明した <code>parseHeader</code> 関数とよく似ていますが、\n独自のストリームとして実装されています。\nまた、この実装は入ってくるデータを文字列に変換しないことに注意してください。\n\n</p>\n<!--\nHowever, this would be better implemented as a [Transform][] stream.  See\nbelow for a better implementation.\n-->\n\n<p>しかしながら、これは [Transform][] ストリームを使うことでよりうまく実装できます。\n後述のよりよい実装を参照してください。\n\n</p>\n<pre><code class="\"javascript\"">// A parser for a simple data protocol.\n// The "header" is a JSON object, followed by 2 \\n characters, and\n// then a message body.\n//\n// NOTE: This can be done more simply as a Transform stream!\n// Using Readable directly for this is sub-optimal.  See the\n// alternative example below under the Transform section.\n\nvar Readable = require('stream').Readable;\nvar util = require('util');\n\nutil.inherits(SimpleProtocol, Readable);\n\nfunction SimpleProtocol(source, options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(source, options);\n\n  Readable.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n\n  // source is a readable stream, such as a socket or file\n  this._source = source;\n\n  var self = this;\n  source.on('end', function() {\n    self.push(null);\n  });\n\n  // give it a kick whenever the source is readable\n  // read(0) will not consume any bytes\n  source.on('readable', function() {\n    self.read(0);\n  });\n\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype._read = function(n) {\n  if (!this._inBody) {\n    var chunk = this._source.read();\n\n    // if the source doesn't have data, we don't have data yet.\n    if (chunk === null)\n      return this.push('');\n\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n      this.push('');\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // now, because we got some extra data, unshift the rest\n      // back into the read queue so that our consumer will see it.\n      var b = chunk.slice(split);\n      this.unshift(b);\n\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n    }\n  } else {\n    // from there on, just provide the data to our consumer.\n    // careful not to push(null), since that would indicate EOF.\n    var chunk = this._source.read();\n    if (chunk) this.push(chunk);\n  }\n};\n\n// Usage:\n// var parser = new SimpleProtocol(source);\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.</code></pre>\n",
              "methods": [
                {
                  "textRaw": "new stream.Readable([options])",
                  "type": "method",
                  "name": "Readable",
                  "* `options` {Object}\n  * `highWaterMark` {Number} The maximum number of bytes to store in\n    the internal buffer before ceasing to read from the underlying\n    resource.  Default": "16kb\n  * `encoding` {String} If specified, then buffers will be decoded to\n    strings using the specified encoding.  Default=null\n  * `objectMode` {Boolean} Whether this stream should behave\n    as a stream of objects. Meaning that stream.read(n) returns\n    a single value instead of a Buffer of size n.  Default=false",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`options` {Object} (任意) ",
                          "options": [
                            {
                              "textRaw": "`highWaterMark` {Number} 下層のリソースから読み込むのを中断するまで 内部バッファに貯めておくバイト数の最大値。デフォルトは 16kb。 ",
                              "name": "highWaterMark",
                              "type": "Number",
                              "desc": "下層のリソースから読み込むのを中断するまで 内部バッファに貯めておくバイト数の最大値。デフォルトは 16kb。"
                            },
                            {
                              "textRaw": "`encoding` {String} 指定されるとバッファは指定のエンコーディングで デコードされます。デフォルトは `null`。 ",
                              "name": "encoding",
                              "type": "String",
                              "desc": "指定されるとバッファは指定のエンコーディングで デコードされます。デフォルトは `null`。"
                            },
                            {
                              "textRaw": "`objectMode` {Boolean} このストリームがオブジェクトストリームとして 振る舞うべきかどうか。これは `stream.read(n)` がサイズ n のバッファではなく 一つの値を返すことを意味します。デフォルトは `false` です。 ",
                              "name": "objectMode",
                              "type": "Boolean",
                              "desc": "このストリームがオブジェクトストリームとして 振る舞うべきかどうか。これは `stream.read(n)` がサイズ n のバッファではなく 一つの値を返すことを意味します。デフォルトは `false` です。"
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "desc": "(任意)",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "options",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<!--\nIn classes that extend the Readable class, make sure to call the\nReadable constructor so that the buffering settings can be properly\ninitialized.\n-->\n\n<p><code>Readable</code> クラスを拡張するクラスでは、バッファリングの設定を確実に\n初期化することができるように、必ずコンストラクタを呼び出してください。\n\n</p>\n"
                },
                {
                  "textRaw": "readable.\\_read(size)",
                  "type": "method",
                  "name": "\\_read",
                  "desc": "<!--\n* `size` {Number} Number of bytes to read asynchronously\n-->\n\n<ul>\n<li><code>size</code> {Number} 非同期に読み込むバイト数</li>\n</ul>\n<!--\nNote: **Implement this function, but do NOT call it directly.**\n-->\n\n<p>注意: <strong>この関数を実装してください、しかし直接呼び出さないでください。</strong>\n\n</p>\n<!--\nThis function should NOT be called directly.  It should be implemented\nby child classes, and only called by the internal Readable class\nmethods.\n-->\n\n<p>この関数は直接呼び出すべきではありません。\nこれはサブクラスで実装されるべきであり、Readable クラスの内部から\n呼び出されるべきです。\n\n</p>\n<!--\nAll Readable stream implementations must provide a `_read` method to\nfetch data from the underlying resource.\n-->\n\n<p>全ての Readable ストリームは、下層のリソースからデータを\n取得するために <code>_read()</code> メソッドを提供しなければなりません。\n\n</p>\n<!--\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n-->\n\n<p>このメソッドはこれを定義するクラス内部のものであり、ユーザプログラムから\n直接呼び出されるべきものではないため、アンダースコアの接頭辞を持ちます。\nしかしながら、あなたの拡張クラスではこのメソッドをオーバーライドすることが\n<strong>求められて</strong>います。\n\n</p>\n<!--\nWhen data is available, put it into the read queue by calling\n`readable.push(chunk)`.  If `push` returns false, then you should stop\nreading.  When `_read` is called again, you should start pushing more\ndata.\n-->\n\n<p>データが利用可能になれば、<code>readable.push(chunk)</code> を呼び出すことで\nそれを読み込みキューに追加します。\n<code>push()</code> が false を返した場合は、読み込みを止めるべきです。\n<code>_read()</code> が再び呼び出された時が、さらに多くのデータを追加を開始すべき時です。\n\n</p>\n<!--\nThe `size` argument is advisory.  Implementations where a \"read\" is a\nsingle call that returns data can use this to know how much data to\nfetch.  Implementations where that is not relevant, such as TCP or\nTLS, may ignore this argument, and simply provide data whenever it\nbecomes available.  There is no need, for example to \"wait\" until\n`size` bytes are available before calling [`stream.push(chunk)`][].\n-->\n\n<p><code>size</code> 引数はアドバイス的です。\n"read()" が一回の呼び出しでデータを返す実装では、\nどれだけのデータを取得すべきか知るためにこれを使うことができます。\nTCPやTLSなど、それに関連しない実装ではこの引数は無視され、\n利用可能になったデータをシンプルに提供するかもしれません。\nたとえば [<code>stream.push(chunk)</code>][] が呼び出されるより前に、\n<code>size</code> バイトが利用可能になるまで「待つ」必要はありません。\n\n</p>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "size"
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "readable.push(chunk, [encoding])",
                  "type": "method",
                  "name": "push",
                  "desc": "<!--\n* `chunk` {Buffer | null | String} Chunk of data to push into the read queue\n* `encoding` {String} Encoding of String chunks.  Must be a valid\n  Buffer encoding, such as `'utf8'` or `'ascii'`\n* return {Boolean} Whether or not more pushes should be performed\n-->\n\n<ul>\n<li><code>chunk</code> {Buffer | null | String} 読み込みキューにプッシュされる、\nデータのチャンク</li>\n<li><code>encoding</code> {String} 文字列チャンクのエンコーディング。\n<code>'utf8'</code> や <code>'ascii'</code> など、Buffer の正しいエンコーディングの必要があります。</li>\n<li>return {Boolean} さらにプッシュしてもいいかどうか</li>\n</ul>\n<!--\nNote: **This function should be called by Readable implementors, NOT\nby consumers of Readable streams.**\n-->\n\n<p>注意: <strong>この関数は Readable の実装から呼び出されるべきものであり、\nReadable ストリームの利用者が呼び出すべきではありません。</strong>\n\n</p>\n<!--\nThe `_read()` function will not be called again until at least one\n`push(chunk)` call is made.\n-->\n\n<p>少なくとも一回は <code>push(chunk)</code> が呼び出されないと、<code>_read()</code> 関数が\n再び呼び出されることはありません。\n\n</p>\n<!--\nThe `Readable` class works by putting data into a read queue to be\npulled out later by calling the `read()` method when the `'readable'`\nevent fires.\n-->\n\n<p><code>Readable</code> クラスは、<code>read()</code> メソッドが呼び出されることで\n後から取り出されるデータを、<code>'readable'</code> イベントの生成時に\n読み込みキューに入れておくことによって機能します。\n\n</p>\n<!--\nThe `push()` method will explicitly insert some data into the read\nqueue.  If it is called with `null` then it will signal the end of the\ndata (EOF).\n-->\n\n<p><code>push()</code> メソッドはいくつかのデータを明示的に読み込みキューに挿入します。\nもし <code>null</code> と共に呼び出されると、それはデータが終了した (EOF) ことを伝えます。\n\n</p>\n<!--\nThis API is designed to be as flexible as possible.  For example,\nyou may be wrapping a lower-level source which has some sort of\npause/resume mechanism, and a data callback.  In those cases, you\ncould wrap the low-level source object by doing something like this:\n-->\n\n<p>この API は可能な限り柔軟に設計されています。\n例えば、ある種の中断／再開メカニズムとデータのコールバックを持つ、\nより低水準のデータソースをラップするかもしれません。\nそれらのケースでは、このように低水準のソースオブジェクトを\nラップすることができます。\n\n</p>\n<pre><code class="\"javascript\"">// source is an object with readStop() and readStart() methods,\n// and an `ondata` member that gets called when it has data, and\n// an `onend` member that gets called when the data is over.\n\nutil.inherits(SourceWrapper, Readable);\n\nfunction SourceWrapper(options) {\n  Readable.call(this, options);\n\n  this._source = getLowlevelSourceObject();\n  var self = this;\n\n  // Every time there's data, we push it into the internal buffer.\n  this._source.ondata = function(chunk) {\n    // if push() returns false, then we need to stop reading from source\n    if (!self.push(chunk))\n      self._source.readStop();\n  };\n\n  // When the source ends, we push the EOF-signalling `null` chunk\n  this._source.onend = function() {\n    self.push(null);\n  };\n}\n\n// _read will be called when the stream wants to pull more data in\n// the advisory size argument is ignored in this case.\nSourceWrapper.prototype._read = function(size) {\n  this._source.readStart();\n};</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "chunk"
                        },
                        {
                          "name": "encoding",
                          "optional": true
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "classes": [
            {
              "textRaw": "Class: stream.Writable",
              "type": "class",
              "name": "stream.Writable",
              "desc": "<!--\n`stream.Writable` is an abstract class designed to be extended with an\nunderlying implementation of the [`_write(chunk, encoding, callback)`][] method.\n-->\n\n<p><code>stream.Writable</code> は抽象クラスで、下層の実装として\n[<code>_write(chunk, encoding, callback)</code>][] メソッドを実装することで\n拡張されるように設計されています。\n\n</p>\n<!--\nPlease see above under [API for Stream Consumers][] for how to consume\nwritable streams in your programs.  What follows is an explanation of\nhow to implement Writable streams in your programs.\n-->\n\n<p>プログラムの中で Writable ストリームを利用する方法については、\n前述の [ストリーム利用者のための API][] を参照してください。\nこの後に続くのは、あなたのプログラムの中で Writable ストリームを\n実装する方法の説明です。\n\n</p>\n",
              "methods": [
                {
                  "textRaw": "new stream.Writable([options])",
                  "type": "method",
                  "name": "Writable",
                  "* `options` {Object}\n  * `highWaterMark` {Number} Buffer level when [`write()`][] starts\n    returning false. Default": "16kb\n  * `decodeStrings` {Boolean} Whether or not to decode strings into\n    Buffers before passing them to [`_write()`][].  Default=true\n  * `objectMode` {Boolean} Whether or not the `write(anyObj)` is\n    a valid operation. If set you can write arbitrary data instead\n    of only `Buffer` / `String` data.  Default=false",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`options` {Object} (任意) ",
                          "options": [
                            {
                              "textRaw": "`highWaterMark` {Number} [`write()`][] が `false` を返し始める バッファレベル。デフォルトは 16kb。 ",
                              "name": "highWaterMark",
                              "type": "Number",
                              "desc": "[`write()`][] が `false` を返し始める バッファレベル。デフォルトは 16kb。"
                            },
                            {
                              "textRaw": "`decodeStrings` {Boolean} 文字列が [`_write()`][] に渡される前に バッファにデコードするかどうか。デフォルトは `true`。 ",
                              "name": "decodeStrings",
                              "type": "Boolean",
                              "desc": "文字列が [`_write()`][] に渡される前に バッファにデコードするかどうか。デフォルトは `true`。"
                            },
                            {
                              "textRaw": "`objectMode` {Boolean} `write(anyObj)` が妥当な操作かどうか。 もし `true` を設定すると、`Buffer` / `String` データのみではなく、 任意のデータを書き込むことができるようになります。 デフォルトは `false`。 ",
                              "name": "objectMode",
                              "type": "Boolean",
                              "desc": "`write(anyObj)` が妥当な操作かどうか。 もし `true` を設定すると、`Buffer` / `String` データのみではなく、 任意のデータを書き込むことができるようになります。 デフォルトは `false`。"
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "desc": "(任意)",
                          "optional": true
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "options",
                          "optional": true
                        }
                      ]
                    }
                  ],
                  "desc": "<!--\nIn classes that extend the Writable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n-->\n\n<p><code>Writable</code> クラスを拡張するクラスでは、バッファリングの設定を確実に\n初期化することができるように、必ずコンストラクタを呼び出してください。\n\n</p>\n"
                },
                {
                  "textRaw": "writable.\\_write(chunk, encoding, callback)",
                  "type": "method",
                  "name": "\\_write",
                  "desc": "<!--\n* `chunk` {Buffer | String} The chunk to be written.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  Ignore chunk is a buffer.  Note that chunk will\n  **always** be a buffer unless the `decodeStrings` option is\n  explicitly set to `false`.\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n-->\n\n<ul>\n<li><code>chunk</code> {Buffer | Array} 書き込まれるデータ。\n<code>decodeStrings</code> オプションが <code>false</code> に設定されない限り常にバッファです。</li>\n<li><code>encoding</code> {String} チャンクが文字列の場合のエンコーディング方式。\nチャンクがバッファの場合は無視されます。\n<code>decodeStrings</code> オプションが明示的に <code>false</code> に設定されない限り、\nチャンクは <em>常に</em> バッファであるべき事に注意してください。</li>\n<li><code>callback</code> {Function} チャンクを提供する処理が終了した時に、\n(任意のエラー引数と共に) この関数を呼び出してください。</li>\n</ul>\n<!--\nAll Writable stream implementations must provide a [`_write()`][]\nmethod to send data to the underlying resource.\n-->\n\n<p>全ての Writable ストリームは、下層のリソースにデータを\n送るために [<code>_write()</code>][] メソッドを提供しなければなりません。\n\n</p>\n<!--\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Writable\nclass methods only.\n-->\n\n<p>注意: <strong>この関数は直接呼び出してはいけません。</strong>\nこれはサブクラスで実装されるべきであり、Writable クラスの内部からのみ\n呼び出されるべきです。\n\n</p>\n<!--\nCall the callback using the standard `callback(error)` pattern to\nsignal that the write completed successfully or with an error.\n-->\n\n<p>コールバックは出力が成功して完了したか、エラーが発生したかを伝えるために、\n標準的な <code>callback(error)</code> パターンを使って呼び出します。\n\n</p>\n<!--\nIf the `decodeStrings` flag is set in the constructor options, then\n`chunk` may be a string rather than a Buffer, and `encoding` will\nindicate the sort of string that it is.  This is to support\nimplementations that have an optimized handling for certain string\ndata encodings.  If you do not explicitly set the `decodeStrings`\noption to `false`, then you can safely ignore the `encoding` argument,\nand assume that `chunk` will always be a Buffer.\n-->\n\n<p>コンストラクタオプションの <code>decodeStrings</code> フラグがセットされると、\n<code>chunk</code> を Buffer ではなく文字列にし、<code>encoding</code> でその文字列の\n種類を示すことができます。\nこれは、実装が文字列データのエンコーディングを最適化できるようにするためです。\n<code>decodeStrings</code> オプションを明示的に <code>false</code> に設定しない場合、\n<code>endocing</code> 引数は安全に無視することができます。\nそして <code>chunk</code> は常に Buffer であると見なせます。\n\n</p>\n<!--\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n-->\n\n<p>このメソッドはこれを定義するクラス内部のものであり、ユーザプログラムから\n直接呼び出されるべきものではないため、アンダースコアの接頭辞を持ちます。\nしかしながら、あなたの拡張クラスではこのメソッドをオーバーライドすることが\n<strong>求められて</strong>います。\n\n\n</p>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "chunk"
                        },
                        {
                          "name": "encoding"
                        },
                        {
                          "name": "callback"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Class: stream.Duplex",
              "type": "class",
              "name": "stream.Duplex",
              "desc": "<!--\nA \"duplex\" stream is one that is both Readable and Writable, such as a\nTCP socket connection.\n-->\n\n<p>"duplex" ストリームは、TCP ソケットコネクションのように\nReadable であり Writable でもあるストリームの一種です。\n\n</p>\n<!--\nNote that `stream.Duplex` is an abstract class designed to be extended\nwith an underlying implementation of the `_read(size)` and\n[`_write(chunk, encoding, callback)`][] methods as you would with a\nReadable or Writable stream class.\n-->\n\n<p><code>stream.Duplex</code> は、Readable および Writable ストリームクラスと同様、\n下層の実装である [<code>_read(size)</code>][] および\n[<code>_write(chunk, encoding, callback)</code>][] メソッドによって拡張されるように\n設計された抽象クラスであることに注意してください。\n\n</p>\n<!--\nSince JavaScript doesn't have multiple prototypal inheritance, this\nclass prototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n`_read(n)` method as well as the lowlevel\n[`_write(chunk, encoding, callback)`][] method on extension duplex classes.\n-->\n\n<p>JavaScript は複数のプロトタイプ継承を持つことができないため、\nこのクラスは Readable からプロトタイプを継承したうえで、\nWritable から寄生的な方法 (プロトタイプメンバーのコピー) を行います。\n低水準の [<code>_read(size)</code>][] および [<code>_write(chunk, encoding, callback)</code>][]\nを実装することは、Duplex クラスを拡張するユーザの責務です。\n\n</p>\n",
              "methods": [
                {
                  "textRaw": "new stream.Duplex(options)",
                  "type": "method",
                  "name": "Duplex",
                  "* `options` {Object} Passed to both Writable and Readable\n  constructors. Also has the following fields:\n  * `allowHalfOpen` {Boolean} Default": "true.  If set to `false`, then\n    the stream will automatically end the readable side when the\n    writable side ends and vice versa.",
                  "signatures": [
                    {
                      "params": [
                        {
                          "textRaw": "`options` {Object} Writable および Readable のコンストラクタに渡されます。 以下のフィールドを持つこともできます: ",
                          "options": [
                            {
                              "textRaw": "`allowHalfOpen` {Boolean} デフォルトは `true`。 もし `false` に設定された場合、読み込み側が閉じられると 自動的に書き込み側も閉じられます。 ",
                              "name": "allowHalfOpen",
                              "type": "Boolean",
                              "desc": "デフォルトは `true`。 もし `false` に設定された場合、読み込み側が閉じられると 自動的に書き込み側も閉じられます。"
                            }
                          ],
                          "name": "options",
                          "type": "Object",
                          "desc": "Writable および Readable のコンストラクタに渡されます。 以下のフィールドを持つこともできます:"
                        }
                      ]
                    },
                    {
                      "params": [
                        {
                          "name": "options"
                        }
                      ]
                    }
                  ],
                  "desc": "<!--\nIn classes that extend the Duplex class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n-->\n\n<p><code>Duplex</code> クラスを拡張するクラスでは、バッファリングの設定を確実に\n初期化することができるように、必ずコンストラクタを呼び出してください。\n\n\n</p>\n"
                }
              ]
            },
            {
              "textRaw": "Class: stream.Transform",
              "type": "class",
              "name": "stream.Transform",
              "desc": "<!--\nA \"transform\" stream is a duplex stream where the output is causally\nconnected in some way to the input, such as a [zlib][] stream or a\n[crypto][] stream.\n-->\n\n<p>"Transform" ストリームは、[zlib][] ストリームや [crypto][] ストリームのように、\n入力が何らかの方法で出力の元となっているような Duplex ストリームです。\n\n</p>\n<!--\nThere is no requirement that the output be the same size as the input,\nthe same number of chunks, or arrive at the same time.  For example, a\nHash stream will only ever have a single chunk of output which is\nprovided when the input is ended.  A zlib stream will produce output\nthat is either much smaller or much larger than its input.\n-->\n\n<p>出力は、入力と同じサイズ、同じ数のチャンク、同時に到着することを\n要求されません。\nたとえば、Hash ストリームは入力が終了すると一つだけのチャンクを出力します。\nzlib ストリームは、入力より小さいか、またはより大きい出力を生成します。\n\n</p>\n<!--\nRather than implement the [`_read()`][] and [`_write()`][] methods, Transform\nclasses must implement the `_transform()` method, and may optionally\nalso implement the `_flush()` method.  (See below.)\n-->\n\n<p>[<code>_read()</code>][] および [<code>_write()</code>][] メソッドの代わりに、Transform クラスでは\n<code>_transform()</code> メソッドを実装しなければなりません。\nまた、任意で <code>_flush()</code> メソッドを実装することもできます (後述)。\n\n</p>\n",
              "methods": [
                {
                  "textRaw": "new stream.Transform([options])",
                  "type": "method",
                  "name": "Transform",
                  "desc": "<!--\n* `options` {Object} Passed to both Writable and Readable\n  constructors.\n-->\n\n<ul>\n<li><code>options</code> {Object} Writable および Readable のコンストラクタに渡されます。</li>\n</ul>\n<!--\nIn classes that extend the Transform class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n-->\n\n<p><code>Transform</code> クラスを拡張するクラスでは、バッファリングの設定を確実に\n初期化することができるように、必ずコンストラクタを呼び出してください。\n\n</p>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "options",
                          "optional": true
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "transform.\\_transform(chunk, encoding, callback)",
                  "type": "method",
                  "name": "\\_transform",
                  "desc": "<!--\n* `chunk` {Buffer | String} The chunk to be transformed.  Will always\n  be a buffer unless the `decodeStrings` option was set to `false`.\n* `encoding` {String} If the chunk is a string, then this is the\n  encoding type.  (Ignore if `decodeStrings` chunk is a buffer.)\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done processing the supplied chunk.\n-->\n\n<ul>\n<li><code>chunk</code> {Buffer | Array} 書き込まれるデータ。\n<code>decodeStrings</code> オプションが <code>false</code> に設定されない限り常にバッファです。</li>\n<li><code>encoding</code> {String} チャンクが文字列の場合のエンコーディング方式\n(チャンクがバッファの場合は無視されます)。</li>\n<li><code>callback</code> {Function} チャンクを提供する処理が終了した時に、\n(任意のエラー引数と共に) この関数を呼び出してください。</li>\n</ul>\n<!--\nNote: **This function MUST NOT be called directly.**  It should be\nimplemented by child classes, and called by the internal Transform\nclass methods only.\n-->\n\n<p>注意: <strong>この関数は直接呼び出してはいけません。</strong>\nこれはサブクラスで実装されるべきであり、Transform クラスの内部からのみ\n呼び出されるべきです。\n\n</p>\n<!--\nAll Transform stream implementations must provide a `_transform`\nmethod to accept input and produce output.\n-->\n\n<p>全ての Transform ストリームの実装は、入力を受け取って出力を提供するために\n<code>_transform()</code> メソッドを提供しなければなりません。\n\n</p>\n<!--\n`_transform` should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n-->\n\n<p>書き込まれるバイトを処理し、読み込み可能なインタフェースに渡すなど、\nTransform クラスでしなければならないことは全て <code>_transform()</code>\nで行わなければなりません。非同期 I/O、何かの処理、その他。\n\n</p>\n<!--\nCall `transform.push(outputChunk)` 0 or more times to generate output\nfrom this input chunk, depending on how much data you want to output\nas a result of this chunk.\n-->\n\n<p>この入力チャンクからの出力を生成するために、<code>transform.push(outputChunk)</code>\nを 0 回以上呼び出してください。\nそれはこのチャンクの結果としてどれだけのデータを出力したいのかに依存します。\n\n</p>\n<!--\nCall the callback function only when the current chunk is completely\nconsumed.  Note that there may or may not be output as a result of any\nparticular input chunk.\n-->\n\n<p>現在のチャンクの処理が完全に終了した場合のみ、コールバック関数を呼び出します。\n特定の入力チャンクからの結果として、出力があるかもしれないし、\n無いかもしれないことに注意してください。\n\n</p>\n<!--\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n-->\n\n<p>このメソッドはこれを定義するクラス内部のものであり、ユーザプログラムから\n直接呼び出されるべきものではないため、アンダースコアの接頭辞を持ちます。\nしかしながら、あなたの拡張クラスではこのメソッドをオーバーライドすることが\n<strong>求められて</strong>います。\n\n</p>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "chunk"
                        },
                        {
                          "name": "encoding"
                        },
                        {
                          "name": "callback"
                        }
                      ]
                    }
                  ]
                },
                {
                  "textRaw": "transform.\\_flush(callback)",
                  "type": "method",
                  "name": "\\_flush",
                  "desc": "<!--\n* `callback` {Function} Call this function (optionally with an error\n  argument) when you are done flushing any remaining data.\n-->\n\n<ul>\n<li><code>callback</code> {Function} 与えられたチャンクの処理が終了した場合に、\n(任意のエラー引数と共に) この関数を呼び出してください。</li>\n</ul>\n<!--\nNote: **This function MUST NOT be called directly.**  It MAY be implemented\nby child classes, and if so, will be called by the internal Transform\nclass methods only.\n-->\n\n<p>注意: <strong>この関数は直接呼び出してはいけません。</strong>\nこれはサブクラスで実装されるかもしれず、Transform クラスの内部からのみ\n呼び出されるべきです。\n\n</p>\n<!--\nIn some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a `Zlib` compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n-->\n\n<p>場合によっては、変換操作はストリームの終端でより多くのデータを\n生成する必要があります。\nたとえば、<code>Zlib</code> 圧縮ストリームは出力を最適に圧縮できるように、\nいくつかの内部状態を持ちます。\n一方、終端ではデータが完全なものになるように、\n残されたものに最善を尽くす必要があります。\n\n</p>\n<!--\nIn those cases, you can implement a `_flush` method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting `end` to signal the end of the readable side.  Just\nlike with `_transform`, call `transform.push(chunk)` zero or more\ntimes, as appropriate, and call `callback` when the flush operation is\ncomplete.\n-->\n\n<p>この場合、最後の最後 (書き込まれた全てのデータが消費された後、\nただし読み込み側の終了を知らせる <code>'end'</code> が生成される前) に呼び出される\n<code>_flush()</code> メソッドを実装することができます。\n<code>_transform()</code> と同様、<code>transform.push(chunk)</code> を何度 (0 回以上) でも\n適切に呼び出し、フラッシュ操作が完了した時に <code>callback</code> を呼び出します。\n\n</p>\n<!--\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n-->\n\n<p>このメソッドはこれを定義するクラス内部のものであり、ユーザプログラムから\n直接呼び出されるべきものではないため、アンダースコアの接頭辞を持ちます。\nしかしながら、あなたの拡張クラスではこのメソッドをオーバーライドすることが\n<strong>求められて</strong>います。\n\n</p>\n<h4>Example: <code>SimpleProtocol</code> parser v2</h4>\n<!--\nThe example above of a simple protocol parser can be implemented\nsimply by using the higher level [Transform][] stream class, similar to\nthe `parseHeader` and `SimpleProtocol v1` examples above.\n-->\n\n<p>前述した単純なプロトコルパーサの例は、より高水準な [Transform][] ストリームクラスを\n使うことで、さらにシンプルに実装することができます。\n前述の <code>parseHeader</code> および <code>SimpleProtocol v1</code> とよく似た例です。\n\n</p>\n<!--\nIn this example, rather than providing the input as an argument, it\nwould be piped into the parser, which is a more idiomatic Node stream\napproach.\n-->\n\n<p>この例では、入力を引数で与えるのではなく、Node のストームにおける\nより慣用的なアプローチとしてパーサにパイプで送られます。\n\n</p>\n<pre><code class="\"javascript\"">var util = require('util');\nvar Transform = require('stream').Transform;\nutil.inherits(SimpleProtocol, Transform);\n\nfunction SimpleProtocol(options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(options);\n\n  Transform.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype._transform = function(chunk, encoding, done) {\n  if (!this._inBody) {\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n\n      // now, because we got some extra data, emit this first.\n      this.push(chunk.slice(split));\n    }\n  } else {\n    // from there on, just provide the data to our consumer as-is.\n    this.push(chunk);\n  }\n  done();\n};\n\n// Usage:\n// var parser = new SimpleProtocol();\n// source.pipe(parser)\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.</code></pre>\n",
                  "signatures": [
                    {
                      "params": [
                        {
                          "name": "callback"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "Class: stream.PassThrough",
              "type": "class",
              "name": "stream.PassThrough",
              "desc": "<!--\nThis is a trivial implementation of a [Transform][] stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy as a building block for novel sorts of streams.\n-->\n\n<p>これは [Transform][] ストリームの取るに足らない実装で、\n入力したバイト列を出力に単純に渡すだけです。\nこれの主な目的はサンプル及びテストですが、新しい種類のストリームのための\nビルディングブロックとして、何かと便利となるユースケースが時折存在します。\n\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Streams: Under the Hood",
          "name": "Streams: Under the Hood",
          "type": "misc",
          "miscs": [
            {
              "textRaw": "Buffering",
              "name": "Buffering",
              "type": "misc",
              "desc": "<!--\nBoth Writable and Readable streams will buffer data on an internal\nobject called `_writableState.buffer` or `_readableState.buffer`,\nrespectively.\n-->\n\n<p>Readable 及び Writable ストリームはそれぞれ、<code>_writableState.buffer</code> または\n<code>_readableState.buffer</code> と呼ばれる内部オブジェクトにデータを\nバッファリングします。\n\n</p>\n<!--\nThe amount of data that will potentially be buffered depends on the\n`highWaterMark` option which is passed into the constructor.\n-->\n\n<p>バッファリングされるデータの量は、コンストラクタに渡される <code>highWaterMark</code>\nオプションに依存します。\n\n</p>\n<!--\nBuffering in Readable streams happens when the implementation calls\n[`stream.push(chunk)`][].  If the consumer of the Stream does not call\n`stream.read()`, then the data will sit in the internal queue until it\nis consumed.\n-->\n\n<p>Readable ストリームにおけるバッファリングは、実装が [<code>stream.push(chunk)</code>][]\nを呼び出した時に起こります。\nストリームの利用者が <code>stream.read()</code> を呼び出さないと、\nデータはそれが消費されるまで内部キューに留まります。\n\n</p>\n<!--\nBuffering in Writable streams happens when the user calls\n[`stream.write(chunk)`][] repeatedly, even when `write()` returns `false`.\n-->\n\n<p>Writable ストリームにおけるバッファリングは、利用者が [<code>stream.write(chunk)</code>][]\nを繰り返し呼び出すと、<code>write()</code> が <code>false</code> を返した場合でも起こります。\n\n</p>\n<!--\nThe purpose of streams, especially with the `pipe()` method, is to\nlimit the buffering of data to acceptable levels, so that sources and\ndestinations of varying speed will not overwhelm the available memory.\n-->\n\n<p>ストリーム、特に <code>pipe()</code> メソッドの目的は、データのバッファリングを\n許容できるレベルに制限することです。そのため、様々な速度の入力元と出力先で、\n利用可能なメモリを圧迫しません。\n\n</p>\n"
            },
            {
              "textRaw": "`stream.read(0)`",
              "name": "`stream.read(0)`",
              "desc": "<!--\nThere are some cases where you want to trigger a refresh of the\nunderlying readable stream mechanisms, without actually consuming any\ndata.  In that case, you can call `stream.read(0)`, which will always\nreturn null.\n-->\n\n<p>実際にデータを消費することなく、下層の Readable ストリームのメカニズムを\nリフレッシュするきっかけが欲しくなるケースがあります。\nそのケースでは、常に <code>null</code> を返す <code>stream.read(0)</code> を呼び出すことができます。\n\n</p>\n<!--\nIf the internal read buffer is below the `highWaterMark`, and the\nstream is not currently reading, then calling `read(0)` will trigger\na low-level `_read` call.\n-->\n\n<p>内部バッファが <code>highWaterMark</code> を下回っていて、\nストリームが現在読み込み中でなければ、<code>read(0)</code> の呼び出しは低水準の\n<code>_read()</code> を呼び出すきっかけとなります。\n\n</p>\n<!--\nThere is almost never a need to do this.  However, you will see some\ncases in Node's internals where this is done, particularly in the\nReadable stream class internals.\n-->\n\n<p>これをする必要はほとんどありません。\nしかしながら Node の内部、特に Readable ストリームクラスの内部で、\nこれが使われているケースを見ることができるでしょう。\n\n</p>\n",
              "type": "misc",
              "displayName": "`stream.read(0)`"
            },
            {
              "textRaw": "`stream.push('')`",
              "name": "`stream.push('')`",
              "desc": "<!--\nPushing a zero-byte string or Buffer (when not in [Object mode][]) has an\ninteresting side effect.  Because it *is* a call to\n[`stream.push()`][], it will end the `reading` process.  However, it\ndoes *not* add any data to the readable buffer, so there's nothing for\na user to consume.\n-->\n\n<p>ゼロバイトの長さの文字列またはバッファをプッシュすると、\n([オブジェクトモード][]の場合を除き) 面白い副作用が起こります。\nそれは [<code>stream.push()</code>][] を呼び出すので、<code>reading</code> プロセスを終了します。\nしかしながら、それは読み込みバッファにどんなデータも加え <em>ない</em> ので、\nユーザが消費するものは何もありません。\n\n</p>\n<!--\nVery rarely, there are cases where you have no data to provide now,\nbut the consumer of your stream (or, perhaps, another bit of your own\ncode) will know when to check again, by calling `stream.read(0)`.  In\nthose cases, you *may* call `stream.push('')`.\n-->\n\n<p>ごくまれに、今は提供するデータが無い場合があります。しかし、<code>stream.read(0)</code>\nを呼び出すことにより、ストリームの利用者 (あるいは、もしかするとあなたの\nコードの一部) は再びチェックすべきなのがいつかを知ることができます。\nこのケースでは、<code>stream.push('')</code> を呼び出すことが <em>できます</em> 。\n\n</p>\n<!--\nSo far, the only use case for this functionality is in the\n[tls.CryptoStream][] class, which is deprecated in Node v0.12.  If you\nfind that you have to use `stream.push('')`, please consider another\napproach, because it almost certainly indicates that something is\nhorribly wrong.\n-->\n\n<p>現在の所、この機能の唯一のユースケースは v0.12 で廃止予定の\n[tls.CryptoStream][] の中にあります。\nもし <code>stream.push('')</code> を使わなければならないことになったら、それはおそらく\n何かが恐ろしく間違っていることを示すので、他の方法を検討してください。\n\n</p>\n",
              "type": "misc",
              "displayName": "`stream.push('')`"
            },
            {
              "textRaw": "Compatibility with Older Node Versions",
              "name": "Compatibility with Older Node Versions",
              "type": "misc",
              "desc": "<!--\nIn versions of Node prior to v0.10, the Readable stream interface was\nsimpler, but also less powerful and less useful.\n-->\n\n<p>v0.10 より前のバージョンの Node では、Readable ストリームのインタフェースは\nよりシンプルでしたが、強力ではなく使いやすくもありませんでした。\n\n</p>\n<!--\n* Rather than waiting for you to call the `read()` method, `'data'`\n  events would start emitting immediately.  If you needed to do some\n  I/O to decide how to handle data, then you had to store the chunks\n  in some kind of buffer so that they would not be lost.\n* The `pause()` method was advisory, rather than guaranteed.  This\n  meant that you still had to be prepared to receive `'data'` events\n  even when the stream was in a paused state.\n-->\n\n<ul>\n<li><code>read()</code> メソッドが呼び出されるのを待つのではなく、\n<code>'data'</code> イベントがすぐに生成され始めます。\nもしデータを処理する方法を決定するためにいくらかの I/O をする\n必要がある場合、データが失われないようにするためには\nチャンクを何らかのバッファに保存しなければなりませんでした。</li>\n<li><code>pause()</code> は保証というよりはむしろ助言です。\nそれはストリームが中断された状態であったとしても、\n<code>'data'</code> イベントを受け取る準備が必要だということを意味します。</li>\n</ul>\n<!--\nIn Node v0.10, the Readable class described below was added.  For\nbackwards compatibility with older Node programs, Readable streams\nswitch into \"flowing mode\" when a `'data'` event handler is added, or\nwhen the `pause()` or `resume()` methods are called.  The effect is\nthat, even if you are not using the new `read()` method and\n`'readable'` event, you no longer have to worry about losing `'data'`\nchunks.\n-->\n\n<p>Node v0.10 から、上記で説明した Readable クラスが追加されました。\n古い Node プログラムとの後方互換性のために、Readable ストリームは\n<code>'data'</code> イベントのハンドラが加えられた場合や、<code>pause()</code> または\n<code>resume()</code> メソッドが読み出されると、「flowing モード」に切り替わります。\nその結果として、新しい <code>read()</code> メソッドや <code>'readable'</code> イベントを\n使用していなくても、もう <code>'data'</code> イベントのチャンクが失われることを\n心配する必要はありません。\n\n</p>\n<!--\nMost programs will continue to function normally.  However, this\nintroduces an edge case in the following conditions:\n-->\n\n<p>ほとんどのプログラムはこれまで通りに機能するでしょう。\nしかしながら、以下の条件でエッジケースが存在します。\n\n</p>\n<!--\n* No `'data'` event handler is added.\n* The `pause()` and `resume()` methods are never called.\n-->\n\n<ul>\n<li><code>'data'</code> イベントハンドラが登録されていない。</li>\n<li><code>pause()</code> および <code>resume()</code> メソッドが呼び出されていない。</li>\n</ul>\n<!--\nFor example, consider the following code:\n-->\n\n<p>例えば、以下のコードを考えてみてください:\n\n</p>\n<pre><code class="\"javascript\"">// WARNING!  BROKEN!\nnet.createServer(function(socket) {\n\n  // we add an 'end' method, but never consume the data\n  socket.on('end', function() {\n    // It will never get here.\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n}).listen(1337);</code></pre>\n<!--\nIn versions of node prior to v0.10, the incoming message data would be\nsimply discarded.  However, in Node v0.10 and beyond, the socket will\nremain paused forever.\n-->\n\n<p>v0.10 より前の Node では、入ってきたデータは単純に破棄されていました。\nしかしながら、Node v0.10 以降では、ソケットは中断したままとなります。\n\n</p>\n<!--\nThe workaround in this situation is to call the `resume()` method to\ntrigger \"old mode\" behavior:\n-->\n\n<p>この状況の回避策は、「flowwing モード」の振る舞いへのトリガーとして\n<code>resume()</code> メソッドを呼び出すことです。\n\n</p>\n<pre><code class="\"javascript\"">// Workaround\nnet.createServer(function(socket) {\n\n  socket.on('end', function() {\n    socket.end('I got your message (but didnt read it)\\n');\n  });\n\n  // start the flow of data, discarding it.\n  socket.resume();\n\n}).listen(1337);</code></pre>\n<!--\nIn addition to new Readable streams switching into flowing-mode, pre-v0.10\nstyle streams can be wrapped in a Readable class using the `wrap()`\nmethod.\n-->\n\n<p>新しい Readable ストリームを flowing モードに切り替えられることに加えて、\n<code>wrap()</code> メソッドを使って v0.10 より前のスタイルのストリームを\nReadable クラスでラップすることもできます。\n\n\n</p>\n"
            },
            {
              "textRaw": "Object Mode",
              "name": "Object Mode",
              "type": "misc",
              "desc": "<!--\nNormally, Streams operate on Strings and Buffers exclusively.\n-->\n\n<p>通常、ストリームは文字列またはバッファのみを扱います。\n\n</p>\n<!--\nStreams that are in **object mode** can emit generic JavaScript values\nother than Buffers and Strings.\n-->\n\n<p><strong>オブジェクトモード</strong> のストリームは、文字列及びバッファ以外の\n一般的なJavaScriptの値を扱うことができます。\n\n</p>\n<!--\nA Readable stream in object mode will always return a single item from\na call to `stream.read(size)`, regardless of what the size argument\nis.\n-->\n\n<p>オブジェクトモードの Readable ストリームは、<code>stream.read(size)</code> のサイズ引数が\nいくつであるかに関わらず、常に一つの項目を返します。\n\n</p>\n<!--\nA Writable stream in object mode will always ignore the `encoding`\nargument to `stream.write(data, encoding)`.\n-->\n\n<p>オブジェクトモードの Writable ストリームは、<code>stream.write(data, encoding)</code>\nの <code>encoding</code> 引数を常に無視します。\n\n</p>\n<!--\nThe special value `null` still retains its special value for object\nmode streams.  That is, for object mode readable streams, `null` as a\nreturn value from `stream.read()` indicates that there is no more\ndata, and [`stream.push(null)`][] will signal the end of stream data\n(`EOF`).\n-->\n\n<p>特別な値 <code>null</code> は、オブジェクトモードのストリームにおいても\n特別な値を持ちます。\nすなわち、オブジェクトモードの Readable ストリームでは、<code>stream.read()</code>\nの戻り値 <code>null</code> はもうデータが無いことを、[<code>stream.push(null)</code>][]\nはストリームデータの終端を示します (<code>EOF</code>)。\n\n</p>\n<!--\nNo streams in Node core are object mode streams.  This pattern is only\nused by userland streaming libraries.\n-->\n\n<p>Node のコアライブラリにはオブジェクトモードのストリームは存在しません。\nこのパターンはユーザランドのライブラリでのみ使われます。\n\n</p>\n<!--\nYou should set `objectMode` in your stream child class constructor on\nthe options object.  Setting `objectMode` mid-stream is not safe.\n-->\n\n<p>ストリームのサブクラスはコストラクタの <code>options</code> オブジェクトで <code>objectMode</code>\nを設定すべきです。\n<code>objectMode</code> をストリームの途中で設定することは安全ではありません。\n\n</p>\n"
            },
            {
              "textRaw": "State Objects",
              "name": "state_objects",
              "desc": "<!--\n[Readable][] streams have a member object called `_readableState`.\n[Writable][] streams have a member object called `_writableState`.\n[Duplex][] streams have both.\n-->\n\n<p>[Readable][] ストリームは <code>_readableState</code> と呼ばれるメンバを持っています。\n[Writable][] ストリームは <code>_writableState</code> と呼ばれるメンバを持っています。\n[Duplex][] ストリームは両方を持っています。\n\n</p>\n<!--\n**These objects should generally not be modified in child classes.**\nHowever, if you have a Duplex or Transform stream that should be in\n`objectMode` on the readable side, and not in `objectMode` on the\nwritable side, then you may do this in the constructor by setting the\nflag explicitly on the appropriate state object.\n-->\n\n<p><strong>通常、これらのオブジェクトはサブクラスで変更すべきではありません。</strong>\nしかしながら、もし Duplex または Transform ストリームの読み込み側が\n<code>objectMode</code> で、書き込み側が <code>objectMode</code> ではない場合、コンストラクタで\n適切なステートオブジェクトにフラグを明示的に設定することになるかもしれません。\n\n</p>\n<pre><code class="\"javascript\"">var util = require('util');\nvar StringDecoder = require('string_decoder').StringDecoder;\nvar Transform = require('stream').Transform;\nutil.inherits(JSONParseStream, Transform);\n\n// Gets \\n-delimited JSON string data, and emits the parsed objects\nfunction JSONParseStream(options) {\n  if (!(this instanceof JSONParseStream))\n    return new JSONParseStream(options);\n\n  Transform.call(this, options);\n  this._writableState.objectMode = false;\n  this._readableState.objectMode = true;\n  this._buffer = '';\n  this._decoder = new StringDecoder('utf8');\n}\n\nJSONParseStream.prototype._transform = function(chunk, encoding, cb) {\n  this._buffer += this._decoder.write(chunk);\n  // split on newlines\n  var lines = this._buffer.split(/\\r?\\n/);\n  // keep the last partial line buffered\n  this._buffer = lines.pop();\n  for (var l = 0; l < lines.length; l++) {\n    var line = lines[l];\n    try {\n      var obj = JSON.parse(line);\n    } catch (er) {\n      this.emit('error', er);\n      return;\n    }\n    // push the parsed object out to the readable consumer\n    this.push(obj);\n  }\n  cb();\n};\n\nJSONParseStream.prototype._flush = function(cb) {\n  // Just handle any leftover\n  var rem = this._buffer.trim();\n  if (rem) {\n    try {\n      var obj = JSON.parse(rem);\n    } catch (er) {\n      this.emit('error', er);\n      return;\n    }\n    // push the parsed object out to the readable consumer\n    this.push(obj);\n  }\n  cb();\n};</code></pre>\n<!--\nThe state objects contain other useful information for debugging the\nstate of streams in your programs.  It is safe to look at them, but\nbeyond setting option flags in the constructor, it is **not** safe to\nmodify them.\n-->\n\n<p>ステートオブジェクトは、デバッグで役に立つストリームの状態を\n情報として持ちます。それを見ることは安全ですが、しかしコンストラクタで設定した\nオプションフラグを変更することは安全では <strong>ありません</strong>。\n\n\n</p>\n<!--\n[EventEmitter]: events.html#events_class_events_eventemitter\n[Object mode]: #stream_object_mode\n[`stream.push(chunk)`]: #stream_readable_push_chunk_encoding\n[`stream.push(null)`]: #stream_readable_push_chunk_encoding\n[`stream.push()`]: #stream_readable_push_chunk_encoding\n[`unpipe()`]: #stream_readable_unpipe_destination\n[unpiped]: #stream_readable_unpipe_destination\n[tcp sockets]: net.html#net_class_net_socket\n[zlib streams]: zlib.html\n[zlib]: zlib.html\n[crypto streams]: crypto.html\n[crypto]: crypto.html\n[tls.CryptoStream]: tls.html#tls_class_cryptostream\n[process.stdin]: process.html#process_process_stdin\n[stdout]: process.html#process_process_stdout\n[process.stdout]: process.html#process_process_stdout\n[process.stderr]: process.html#process_process_stderr\n[child process stdout and stderr]: child_process.html#child_process_child_stdout\n[API for Stream Consumers]: #stream_api_for_stream_consumers\n[API for Stream Implementors]: #stream_api_for_stream_implementors\n[Readable]: #stream_class_stream_readable\n[Writable]: #stream_class_stream_writable\n[Duplex]: #stream_class_stream_duplex\n[Transform]: #stream_class_stream_transform\n[`_read(size)`]: #stream_readable_read_size_1\n[`_read()`]: #stream_readable_read_size_1\n[_read]: #stream_readable_read_size_1\n[`writable.write(chunk)`]: #stream_writable_write_chunk_encoding_callback\n[`write(chunk, encoding, callback)`]: #stream_writable_write_chunk_encoding_callback\n[`write()`]: #stream_writable_write_chunk_encoding_callback\n[`stream.write(chunk)`]: #stream_writable_write_chunk_encoding_callback\n[`_write(chunk, encoding, callback)`]: #stream_writable_write_chunk_encoding_callback_1\n[`_write()`]: #stream_writable_write_chunk_encoding_callback_1\n[_write]: #stream_writable_write_chunk_encoding_callback_1\n[`util.inherits`]: util.html#util_util_inherits_constructor_superconstructor\n[`end()`]: #stream_writable_end_chunk_encoding_callback\n-->\n\n",
              "type": "misc",
              "displayName": "State Objects"
            }
          ]
        }
      ],
      "examples": [
        {
          "textRaw": "Class: stream.Readable",
          "type": "example",
          "name": "stream.Readable",
          "desc": "<!--\n`stream.Readable` is an abstract class designed to be extended with an\nunderlying implementation of the [`_read(size)`][] method.\n-->\n\n<p><code>stream.Readable</code> は抽象クラスで、下層の実装として [<code>_read(size)</code>][]\nメソッドを実装することで拡張されるように設計されています。\n\n</p>\n<!--\nPlease see above under [API for Stream Consumers][] for how to consume\nstreams in your programs.  What follows is an explanation of how to\nimplement Readable streams in your programs.\n-->\n\n<p>プログラムの中で Readable ストリームを利用する方法については、\n前述の [ストリーム利用者のための API][] を参照してください。\nこの後に続くのは、あなたのプログラムの中で Readable ストリームを\n実装する方法の説明です。\n\n</p>\n<h4>Example: A Counting Stream</h4>\n<!--\nThis is a basic example of a Readable stream.  It emits the numerals\nfrom 1 to 1,000,000 in ascending order, and then ends.\n-->\n\n<p>これは Readable ストリームの基本的な例です。\nそれは 1 から 1,000,000 までの数を昇順で生成し、そして終了します。\n\n</p>\n<pre><code class="\"javascript\"">var Readable = require('stream').Readable;\nvar util = require('util');\nutil.inherits(Counter, Readable);\n\nfunction Counter(opt) {\n  Readable.call(this, opt);\n  this._max = 1000000;\n  this._index = 1;\n}\n\nCounter.prototype._read = function() {\n  var i = this._index++;\n  if (i > this._max)\n    this.push(null);\n  else {\n    var str = '' + i;\n    var buf = new Buffer(str, 'ascii');\n    this.push(buf);\n  }\n};</code></pre>\n<h4>Example: SimpleProtocol v1 (Sub-optimal)</h4>\n<!--\nThis is similar to the `parseHeader` function described above, but\nimplemented as a custom stream.  Also, note that this implementation\ndoes not convert the incoming data to a string.\n-->\n\n<p>これは前に説明した <code>parseHeader</code> 関数とよく似ていますが、\n独自のストリームとして実装されています。\nまた、この実装は入ってくるデータを文字列に変換しないことに注意してください。\n\n</p>\n<!--\nHowever, this would be better implemented as a [Transform][] stream.  See\nbelow for a better implementation.\n-->\n\n<p>しかしながら、これは [Transform][] ストリームを使うことでよりうまく実装できます。\n後述のよりよい実装を参照してください。\n\n</p>\n<pre><code class="\"javascript\"">// A parser for a simple data protocol.\n// The "header" is a JSON object, followed by 2 \\n characters, and\n// then a message body.\n//\n// NOTE: This can be done more simply as a Transform stream!\n// Using Readable directly for this is sub-optimal.  See the\n// alternative example below under the Transform section.\n\nvar Readable = require('stream').Readable;\nvar util = require('util');\n\nutil.inherits(SimpleProtocol, Readable);\n\nfunction SimpleProtocol(source, options) {\n  if (!(this instanceof SimpleProtocol))\n    return new SimpleProtocol(source, options);\n\n  Readable.call(this, options);\n  this._inBody = false;\n  this._sawFirstCr = false;\n\n  // source is a readable stream, such as a socket or file\n  this._source = source;\n\n  var self = this;\n  source.on('end', function() {\n    self.push(null);\n  });\n\n  // give it a kick whenever the source is readable\n  // read(0) will not consume any bytes\n  source.on('readable', function() {\n    self.read(0);\n  });\n\n  this._rawHeader = [];\n  this.header = null;\n}\n\nSimpleProtocol.prototype._read = function(n) {\n  if (!this._inBody) {\n    var chunk = this._source.read();\n\n    // if the source doesn't have data, we don't have data yet.\n    if (chunk === null)\n      return this.push('');\n\n    // check if the chunk has a \\n\\n\n    var split = -1;\n    for (var i = 0; i < chunk.length; i++) {\n      if (chunk[i] === 10) { // '\\n'\n        if (this._sawFirstCr) {\n          split = i;\n          break;\n        } else {\n          this._sawFirstCr = true;\n        }\n      } else {\n        this._sawFirstCr = false;\n      }\n    }\n\n    if (split === -1) {\n      // still waiting for the \\n\\n\n      // stash the chunk, and try again.\n      this._rawHeader.push(chunk);\n      this.push('');\n    } else {\n      this._inBody = true;\n      var h = chunk.slice(0, split);\n      this._rawHeader.push(h);\n      var header = Buffer.concat(this._rawHeader).toString();\n      try {\n        this.header = JSON.parse(header);\n      } catch (er) {\n        this.emit('error', new Error('invalid simple protocol data'));\n        return;\n      }\n      // now, because we got some extra data, unshift the rest\n      // back into the read queue so that our consumer will see it.\n      var b = chunk.slice(split);\n      this.unshift(b);\n\n      // and let them know that we are done parsing the header.\n      this.emit('header', this.header);\n    }\n  } else {\n    // from there on, just provide the data to our consumer.\n    // careful not to push(null), since that would indicate EOF.\n    var chunk = this._source.read();\n    if (chunk) this.push(chunk);\n  }\n};\n\n// Usage:\n// var parser = new SimpleProtocol(source);\n// Now parser is a readable stream that will emit 'header'\n// with the parsed header data.</code></pre>\n",
          "methods": [
            {
              "textRaw": "new stream.Readable([options])",
              "type": "method",
              "name": "Readable",
              "* `options` {Object}\n  * `highWaterMark` {Number} The maximum number of bytes to store in\n    the internal buffer before ceasing to read from the underlying\n    resource.  Default": "16kb\n  * `encoding` {String} If specified, then buffers will be decoded to\n    strings using the specified encoding.  Default=null\n  * `objectMode` {Boolean} Whether this stream should behave\n    as a stream of objects. Meaning that stream.read(n) returns\n    a single value instead of a Buffer of size n.  Default=false",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`options` {Object} (任意) ",
                      "options": [
                        {
                          "textRaw": "`highWaterMark` {Number} 下層のリソースから読み込むのを中断するまで 内部バッファに貯めておくバイト数の最大値。デフォルトは 16kb。 ",
                          "name": "highWaterMark",
                          "type": "Number",
                          "desc": "下層のリソースから読み込むのを中断するまで 内部バッファに貯めておくバイト数の最大値。デフォルトは 16kb。"
                        },
                        {
                          "textRaw": "`encoding` {String} 指定されるとバッファは指定のエンコーディングで デコードされます。デフォルトは `null`。 ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "指定されるとバッファは指定のエンコーディングで デコードされます。デフォルトは `null`。"
                        },
                        {
                          "textRaw": "`objectMode` {Boolean} このストリームがオブジェクトストリームとして 振る舞うべきかどうか。これは `stream.read(n)` がサイズ n のバッファではなく 一つの値を返すことを意味します。デフォルトは `false` です。 ",
                          "name": "objectMode",
                          "type": "Boolean",
                          "desc": "このストリームがオブジェクトストリームとして 振る舞うべきかどうか。これは `stream.read(n)` がサイズ n のバッファではなく 一つの値を返すことを意味します。デフォルトは `false` です。"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "desc": "(任意)",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nIn classes that extend the Readable class, make sure to call the\nReadable constructor so that the buffering settings can be properly\ninitialized.\n-->\n\n<p><code>Readable</code> クラスを拡張するクラスでは、バッファリングの設定を確実に\n初期化することができるように、必ずコンストラクタを呼び出してください。\n\n</p>\n"
            },
            {
              "textRaw": "readable.\\_read(size)",
              "type": "method",
              "name": "\\_read",
              "desc": "<!--\n* `size` {Number} Number of bytes to read asynchronously\n-->\n\n<ul>\n<li><code>size</code> {Number} 非同期に読み込むバイト数</li>\n</ul>\n<!--\nNote: **Implement this function, but do NOT call it directly.**\n-->\n\n<p>注意: <strong>この関数を実装してください、しかし直接呼び出さないでください。</strong>\n\n</p>\n<!--\nThis function should NOT be called directly.  It should be implemented\nby child classes, and only called by the internal Readable class\nmethods.\n-->\n\n<p>この関数は直接呼び出すべきではありません。\nこれはサブクラスで実装されるべきであり、Readable クラスの内部から\n呼び出されるべきです。\n\n</p>\n<!--\nAll Readable stream implementations must provide a `_read` method to\nfetch data from the underlying resource.\n-->\n\n<p>全ての Readable ストリームは、下層のリソースからデータを\n取得するために <code>_read()</code> メソッドを提供しなければなりません。\n\n</p>\n<!--\nThis method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you **are** expected to override this method in\nyour own extension classes.\n-->\n\n<p>このメソッドはこれを定義するクラス内部のものであり、ユーザプログラムから\n直接呼び出されるべきものではないため、アンダースコアの接頭辞を持ちます。\nしかしながら、あなたの拡張クラスではこのメソッドをオーバーライドすることが\n<strong>求められて</strong>います。\n\n</p>\n<!--\nWhen data is available, put it into the read queue by calling\n`readable.push(chunk)`.  If `push` returns false, then you should stop\nreading.  When `_read` is called again, you should start pushing more\ndata.\n-->\n\n<p>データが利用可能になれば、<code>readable.push(chunk)</code> を呼び出すことで\nそれを読み込みキューに追加します。\n<code>push()</code> が false を返した場合は、読み込みを止めるべきです。\n<code>_read()</code> が再び呼び出された時が、さらに多くのデータを追加を開始すべき時です。\n\n</p>\n<!--\nThe `size` argument is advisory.  Implementations where a \"read\" is a\nsingle call that returns data can use this to know how much data to\nfetch.  Implementations where that is not relevant, such as TCP or\nTLS, may ignore this argument, and simply provide data whenever it\nbecomes available.  There is no need, for example to \"wait\" until\n`size` bytes are available before calling [`stream.push(chunk)`][].\n-->\n\n<p><code>size</code> 引数はアドバイス的です。\n"read()" が一回の呼び出しでデータを返す実装では、\nどれだけのデータを取得すべきか知るためにこれを使うことができます。\nTCPやTLSなど、それに関連しない実装ではこの引数は無視され、\n利用可能になったデータをシンプルに提供するかもしれません。\nたとえば [<code>stream.push(chunk)</code>][] が呼び出されるより前に、\n<code>size</code> バイトが利用可能になるまで「待つ」必要はありません。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "size"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "readable.push(chunk, [encoding])",
              "type": "method",
              "name": "push",
              "desc": "<!--\n* `chunk` {Buffer | null | String} Chunk of data to push into the read queue\n* `encoding` {String} Encoding of String chunks.  Must be a valid\n  Buffer encoding, such as `'utf8'` or `'ascii'`\n* return {Boolean} Whether or not more pushes should be performed\n-->\n\n<ul>\n<li><code>chunk</code> {Buffer | null | String} 読み込みキューにプッシュされる、\nデータのチャンク</li>\n<li><code>encoding</code> {String} 文字列チャンクのエンコーディング。\n<code>'utf8'</code> や <code>'ascii'</code> など、Buffer の正しいエンコーディングの必要があります。</li>\n<li>return {Boolean} さらにプッシュしてもいいかどうか</li>\n</ul>\n<!--\nNote: **This function should be called by Readable implementors, NOT\nby consumers of Readable streams.**\n-->\n\n<p>注意: <strong>この関数は Readable の実装から呼び出されるべきものであり、\nReadable ストリームの利用者が呼び出すべきではありません。</strong>\n\n</p>\n<!--\nThe `_read()` function will not be called again until at least one\n`push(chunk)` call is made.\n-->\n\n<p>少なくとも一回は <code>push(chunk)</code> が呼び出されないと、<code>_read()</code> 関数が\n再び呼び出されることはありません。\n\n</p>\n<!--\nThe `Readable` class works by putting data into a read queue to be\npulled out later by calling the `read()` method when the `'readable'`\nevent fires.\n-->\n\n<p><code>Readable</code> クラスは、<code>read()</code> メソッドが呼び出されることで\n後から取り出されるデータを、<code>'readable'</code> イベントの生成時に\n読み込みキューに入れておくことによって機能します。\n\n</p>\n<!--\nThe `push()` method will explicitly insert some data into the read\nqueue.  If it is called with `null` then it will signal the end of the\ndata (EOF).\n-->\n\n<p><code>push()</code> メソッドはいくつかのデータを明示的に読み込みキューに挿入します。\nもし <code>null</code> と共に呼び出されると、それはデータが終了した (EOF) ことを伝えます。\n\n</p>\n<!--\nThis API is designed to be as flexible as possible.  For example,\nyou may be wrapping a lower-level source which has some sort of\npause/resume mechanism, and a data callback.  In those cases, you\ncould wrap the low-level source object by doing something like this:\n-->\n\n<p>この API は可能な限り柔軟に設計されています。\n例えば、ある種の中断／再開メカニズムとデータのコールバックを持つ、\nより低水準のデータソースをラップするかもしれません。\nそれらのケースでは、このように低水準のソースオブジェクトを\nラップすることができます。\n\n</p>\n<pre><code class="\"javascript\"">// source is an object with readStop() and readStart() methods,\n// and an `ondata` member that gets called when it has data, and\n// an `onend` member that gets called when the data is over.\n\nutil.inherits(SourceWrapper, Readable);\n\nfunction SourceWrapper(options) {\n  Readable.call(this, options);\n\n  this._source = getLowlevelSourceObject();\n  var self = this;\n\n  // Every time there's data, we push it into the internal buffer.\n  this._source.ondata = function(chunk) {\n    // if push() returns false, then we need to stop reading from source\n    if (!self.push(chunk))\n      self._source.readStop();\n  };\n\n  // When the source ends, we push the EOF-signalling `null` chunk\n  this._source.onend = function() {\n    self.push(null);\n  };\n}\n\n// _read will be called when the stream wants to pull more data in\n// the advisory size argument is ignored in this case.\nSourceWrapper.prototype._read = function(size) {\n  this._source.readStart();\n};</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Stream"
    },
    {
      "textRaw": "Crypto",
      "name": "crypto",
      "desc": "<!--\n    Stability: 2 - Unstable; API changes are being discussed for\n    future versions.  Breaking changes will be minimized.  See below.\n-->\n\n<pre><code>Stability: 2 - Unstable; 将来のバージョンにおいて API の変更が\n議論されています。互換性を損なう変更は最小限になる予定です。\n後述します。</code></pre>\n<!--\nUse `require('crypto')` to access this module.\n-->\n\n<p>このモジュールにアクセスするには <code>require('crypto')</code> を使用します。\n\n</p>\n<!--\nThe crypto module offers a way of encapsulating secure credentials to be\nused as part of a secure HTTPS net or http connection.\n-->\n\n<p>暗号化モジュールは安全な HTTPS ネットワークや http\nコネクションの一部として使われる、\n安全な認証情報をカプセル化する方法を提供します。\n\n</p>\n<!--\nIt also offers a set of wrappers for OpenSSL's hash, hmac, cipher,\ndecipher, sign and verify methods.\n-->\n\n<p>同時に OpenSSL のハッシュ、HMAC、暗号、復号、署名、そして検証へのラッパーを一式提供します。\n\n\n</p>\n",
      "methods": [
        {
          "textRaw": "crypto.getCiphers()",
          "type": "method",
          "name": "getCiphers",
          "desc": "<!--\nReturns an array with the names of the supported ciphers.\n-->\n\n<p>サポートされている暗号の名前からなる配列を返します。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var ciphers = crypto.getCiphers();\nconsole.log(ciphers); // ['AES-128-CBC', 'AES-128-CBC-HMAC-SHA1', ...]</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "crypto.getHashes()",
          "type": "method",
          "name": "getHashes",
          "desc": "<!--\nReturns an array with the names of the supported hash algorithms.\n-->\n\n<p>サポートされているハッシュアルゴリズムの名前からなる配列を返します。\n\n</p>\n<!--\nExample:\n-->\n\n<pre><code>var hashes = crypto.getHashes();\nconsole.log(hashes); // ['sha', 'sha1', 'sha1WithRSAEncryption', ...]</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "crypto.createCredentials(details)",
          "type": "method",
          "name": "createCredentials",
          "desc": "<!--\nCreates a credentials object, with the optional details being a\ndictionary with keys:\n-->\n\n<p>認証情報オブジェクトを作成します。オプションの <code>details</code>\nは以下のキーを持つ辞書です:\n\n</p>\n<!--\n* `pfx` : A string or buffer holding the PFX or PKCS12 encoded private\n  key, certificate and CA certificates\n* `key` : A string holding the PEM encoded private key\n* `passphrase` : A string of passphrase for the private key or pfx\n* `cert` : A string holding the PEM encoded certificate\n* `ca` : Either a string or list of strings of PEM encoded CA\n  certificates to trust.\n* `crl` : Either a string or list of strings of PEM encoded CRLs\n  (Certificate Revocation List)\n* `ciphers`: A string describing the ciphers to use or exclude.\n  Consult\n  <http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT>\n  for details on the format.\n-->\n\n<ul>\n<li><code>pfx</code> : PFX または PKCS12 でエンコードされた秘密鍵、証明書、および CA の\n証明書を含む文字列またはバッファ。</li>\n<li><code>key</code> : PEM でエンコードされた秘密鍵を保持する文字列。</li>\n<li><code>passphrase</code>: 秘密鍵または pfx のパスフレーズ。</li>\n<li><code>cert</code> : PEM でエンコードされた証明書を保持する文字列。</li>\n<li><code>ca</code> : 信頼できる認証局の証明書が PEM でエンコードされた文字列または\n文字列の配列。</li>\n<li><code>crl</code> : PEM でエンコードされた CRL (Certificate Revocation List、\n失効した証明書の一覧) の文字列または文字列の配列。</li>\n<li><code>ciphers</code>: 使用または除外する暗号を記述した文字列。\n詳細は <a href="\"http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT\"">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>\nを参照してください。</li>\n</ul>\n<!--\nIf no 'ca' details are given, then node.js will use the default\npublicly trusted list of CAs as given in\n<http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt>.\n-->\n\n<p>'ca' の詳細が与えられなかった場合、node.js はデフォルトとして\n</p>\n<p><a href="\"http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt\"">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>\nで与えられる、信頼できる認証局の公開されたリストを使用します。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "details"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createHash(algorithm)",
          "type": "method",
          "name": "createHash",
          "desc": "<!--\nCreates and returns a hash object, a cryptographic hash with the given\nalgorithm which can be used to generate hash digests.\n-->\n\n<p>ハッシュオブジェクトを生成して返します。\n与えられたアルゴリズムによる暗号ハッシュ関数はダイジェストの生成に使われます。\n\n</p>\n<!--\n`algorithm` is dependent on the available algorithms supported by the\nversion of OpenSSL on the platform. Examples are `'sha1'`, `'md5'`,\n`'sha256'`, `'sha512'`, etc.  On recent releases, `openssl\nlist-message-digest-algorithms` will display the available digest\nalgorithms.\n-->\n\n<p><code>algorithm</code> は、プラットフォーム上の OpenSSL \nのバージョンでサポートされている利用可能なアルゴリズムに依存します。\n例えば <code>'sha1'</code>、<code>'md5'</code>、<code>'sha256'</code>、<code>'sha512'</code>、などです。\n最近のリリースでは、<code>openssl list-message-digest-algorithms</code>\nで利用可能なダイジェストアルゴリズムが表示されます。\n\n</p>\n<!--\nExample: this program that takes the sha1 sum of a file\n-->\n\n<p>例: このプログラムはファイルのsha1ハッシュ値を求めます。\n\n</p>\n<pre><code>var filename = process.argv[2];\nvar crypto = require('crypto');\nvar fs = require('fs');\n\nvar shasum = crypto.createHash('sha1');\n\nvar s = fs.ReadStream(filename);\ns.on('data', function(d) {\n  shasum.update(d);\n});\n\ns.on('end', function() {\n  var d = shasum.digest('hex');\n  console.log(d + '  ' + filename);\n});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createHmac(algorithm, key)",
          "type": "method",
          "name": "createHmac",
          "desc": "<!--\nCreates and returns a hmac object, a cryptographic hmac with the given\nalgorithm and key.\n-->\n\n<p>与えられたアルゴリズムとキーで HMAC を計算する、HMAC オブジェクトを作成して返します。\n\n</p>\n<!--\nIt is a [stream](stream.html) that is both readable and writable.  The\nwritten data is used to compute the hmac.  Once the writable side of\nthe stream is ended, use the `read()` method to get the computed\ndigest.  The legacy `update` and `digest` methods are also supported.\n-->\n\n<p>これは読み込みと書き込みの両方が可能な <a href="\"stream.html\"">ストリーム</a> です。\n書き込まれたデータはハッシュを計算するために使われます。\n一度ストリームの書き込み側が閉じられると、計算されたハッシュダイジェストを\n読み出すために <code>read()</code> メソッドを使うことができます。\nレガシーな <code>update()</code> および <code>digest()</code> メソッドもサポートされます。\n\n</p>\n<!--\n`algorithm` is dependent on the available algorithms supported by\nOpenSSL - see createHash above.  `key` is the hmac key to be used.\n-->\n\n<p><code>algorithm</code> は OpenSSL でサポートされているアルゴリズムに依存します － \n前述の <code>createHash</code> を参照してください。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "key"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createCipher(algorithm, password)",
          "type": "method",
          "name": "createCipher",
          "desc": "<!--\nCreates and returns a cipher object, with the given algorithm and\npassword.\n-->\n\n<p>与えられたアルゴリズムとパスワードを使用する暗号オブジェクトを作成して返します。\n<!--\n`algorithm` is dependent on OpenSSL, examples are `'aes192'`, etc.  On\nrecent releases, `openssl list-cipher-algorithms` will display the\navailable cipher algorithms.  `password` is used to derive key and IV,\nwhich must be a `'binary'` encoded string or a [buffer](buffer.html).\n-->\n\n</p>\n<p><code>algorithm</code> は、OpenSSL に依存します。例えば <code>'aes192'</code> などです。\n最近のリリースでは、<code>openssl list-cipher-algorithms</code>\nで利用可能な暗号アルゴリズムが表示されます。\n<code>password</code> はキーと IV の生成に使用されます。\nこれは <code>'binary'</code> でエンコードされた文字列または <a href="\"buffer.html\"">buffer</a>\nでなければなりません\n\n</p>\n<!--\nIt is a [stream](stream.html) that is both readable and writable.  The\nwritten data is used to compute the hash.  Once the writable side of\nthe stream is ended, use the `read()` method to get the computed hash\ndigest.  The legacy `update` and `digest` methods are also supported.\n-->\n\n<p>これは読み込みと書き込みの両方が可能な <a href="\"stream.html\"">ストリーム</a> です。\n書き込まれたデータはハッシュを計算するために使われます。\n一度ストリームの書き込み側が閉じられると、計算されたハッシュダイジェストを\n読み出すために <code>read()</code> メソッドを使うことができます。\nレガシーな <code>update()</code> および <code>digest()</code> メソッドもサポートされます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "password"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createCipheriv(algorithm, key, iv)",
          "type": "method",
          "name": "createCipheriv",
          "desc": "<!--\nCreates and returns a cipher object, with the given algorithm, key and\niv.\n-->\n\n<p>与えられたアルゴリズムとキーおよび IV を使用する暗号オブジェクトを作成して\n返します。\n\n</p>\n<!--\n`algorithm` is the same as the argument to `createCipher()`.  `key` is\nthe raw key used by the algorithm.  `iv` is an [initialization\nvector](http://en.wikipedia.org/wiki/Initialization_vector).\n-->\n\n<p><code>algorithm</code> は <code>createCipher()</code> の引数と同じです。\n<code>key</code> はアルゴリズムで使用される生のキーです。\n<code>iv</code> は<a href="\"http://en.wikipedia.org/wiki/Initialization_vector\"">initialization\nvector</a> です。\n\n</p>\n<!--\n`key` and `iv` must be `'binary'` encoded strings or\n[buffers](buffer.html).\n-->\n\n<p><code>key</code> と <code>iv</code> は <code>'binary'</code> でエンコードされた文字列または\n<a href="\"buffer.html\"">buffers</a> でなければなりません\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "key"
                },
                {
                  "name": "iv"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDecipher(algorithm, password)",
          "type": "method",
          "name": "createDecipher",
          "desc": "<!--\nCreates and returns a decipher object, with the given algorithm and\nkey.  This is the mirror of the [createCipher()][] above.\n-->\n\n<p>与えられたアルゴリズムとパスワードを使用する復号オブジェクトを作成して返します。\nこれは前述の [createCipher()][] の鏡写しです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "password"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDecipheriv(algorithm, key, iv)",
          "type": "method",
          "name": "createDecipheriv",
          "desc": "<!--\nCreates and returns a decipher object, with the given algorithm, key\nand iv.  This is the mirror of the [createCipheriv()][] above.\n-->\n\n<p>与えられたアルゴリズムとキー、IV を使用する復号オブジェクトを作成して返します。\nこれは前述の [createCipheriv()][] の鏡写しです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "key"
                },
                {
                  "name": "iv"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createSign(algorithm)",
          "type": "method",
          "name": "createSign",
          "desc": "<!--\nCreates and returns a signing object, with the given algorithm.  On\nrecent OpenSSL releases, `openssl list-public-key-algorithms` will\ndisplay the available signing algorithms. Examples are `'RSA-SHA256'`.\n-->\n\n<p>与えられたアルゴリズムで署名オブジェクトを作成して返します。\n最近のOpenSSLのリリースでは、<code>openssl list-public-key-algorithms</code>\nで利用可能な署名アルゴリズムの一覧が表示されます。例えば 'RSA-SHA256'。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createVerify(algorithm)",
          "type": "method",
          "name": "createVerify",
          "desc": "<!--\nCreates and returns a verification object, with the given algorithm.\nThis is the mirror of the signing object above.\n-->\n\n<p>与えられたアルゴリズムで検証オブジェクトを作成して返します。これは前述の署名オブジェクトと鏡写しです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDiffieHellman(prime_length)",
          "type": "method",
          "name": "createDiffieHellman",
          "desc": "<!--\nCreates a Diffie-Hellman key exchange object and generates a prime of\nthe given bit length. The generator used is `2`.\n-->\n\n<p>ディフィー・ヘルマン鍵共有オブジェクトを作成し、\n与えられた長さの素数を生成します。生成元は <code>2</code> です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "prime_length"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDiffieHellman(prime, [encoding])",
          "type": "method",
          "name": "createDiffieHellman",
          "desc": "<!--\nCreates a Diffie-Hellman key exchange object using the supplied prime.\nThe generator used is `2`. Encoding can be `'binary'`, `'hex'`, or\n`'base64'`.  If no encoding is specified, then a buffer is expected.\n-->\n\n<p>与えられた素数からディフィー・ヘルマン鍵共有オブジェクトを作成します。\n生成元は <code>2</code> です。\nエンコーディングは <code>'binary'</code>、<code>'hex'</code>、または <code>'base64'</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "prime"
                },
                {
                  "name": "encoding",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.getDiffieHellman(group_name)",
          "type": "method",
          "name": "getDiffieHellman",
          "desc": "<!--\nCreates a predefined Diffie-Hellman key exchange object.  The\nsupported groups are: `'modp1'`, `'modp2'`, `'modp5'` (defined in [RFC\n2412][]) and `'modp14'`, `'modp15'`, `'modp16'`, `'modp17'`,\n`'modp18'` (defined in [RFC 3526][]).  The returned object mimics the\ninterface of objects created by [crypto.createDiffieHellman()][]\nabove, but will not allow to change the keys (with\n[diffieHellman.setPublicKey()][] for example).  The advantage of using\nthis routine is that the parties don't have to generate nor exchange\ngroup modulus beforehand, saving both processor and communication\ntime.\n-->\n\n<p>事前に定義された Diffie-Hellman 鍵交換オブジェクトを作成します。\nサポートされるグループは、<code>'modp1'</code>, <code>'modp2'</code>, <code>'modp5'</code>\n([RFC 2412][] で定義される)、\nおよび <code>'modp14'</code>, <code>'modp15'</code>, <code>'modp16'</code>, <code>'modp17'</code>, <code>'modp18'</code>\n([RFC 3526][] で定義される) です。\n返されるオブジェクトは、前述の\n[crypto.createDiffieHellman()][]\nによって作成されたオブジェクトのインタフェースを模倣します。\nしかし、\n(たとえば [diffieHellman.setPublicKey()][] で)\n鍵を交換することはできません。\nこのルーチンを使うことによるアドバンテージは、\n事前にグループ係数を生成することも交換する必要もないため、\n処理と通信の時間を共に節約できることです。\n\n</p>\n<!--\nExample (obtaining a shared secret):\n-->\n\n<p>例 (共有鍵を取得):\n\n</p>\n<pre><code>var crypto = require('crypto');\nvar alice = crypto.getDiffieHellman('modp5');\nvar bob = crypto.getDiffieHellman('modp5');\n\nalice.generateKeys();\nbob.generateKeys();\n\nvar alice_secret = alice.computeSecret(bob.getPublicKey(), null, 'hex');\nvar bob_secret = bob.computeSecret(alice.getPublicKey(), null, 'hex');\n\n/* alice_secret and bob_secret should be the same */\nconsole.log(alice_secret == bob_secret);</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "group_name"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.pbkdf2(password, salt, iterations, keylen, callback)",
          "type": "method",
          "name": "pbkdf2",
          "desc": "<!--\nAsynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive\na key of given length from the given password, salt and iterations.\nThe callback gets two arguments `(err, derivedKey)`.\n-->\n\n<p>疑似乱数を HMAC-SHA1 関数に適用して、与えられたパスワードと salt \n(ランダムなバイト値)、および繰り返しから、指定された長さの鍵を生成する、\n非同期の PBKDF2 です。\nコールバック関数は二つの引数を受け取る <code>(err, derivedKey)</code> です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "password"
                },
                {
                  "name": "salt"
                },
                {
                  "name": "iterations"
                },
                {
                  "name": "keylen"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.pbkdf2Sync(password, salt, iterations, keylen)",
          "type": "method",
          "name": "pbkdf2Sync",
          "desc": "<!--\nSynchronous PBKDF2 function.  Returns derivedKey or throws error.\n-->\n\n<p>同期版の PBKDF2 関数。\n生成された鍵を返すか、例外をスローします。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "password"
                },
                {
                  "name": "salt"
                },
                {
                  "name": "iterations"
                },
                {
                  "name": "keylen"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.randomBytes(size, [callback])",
          "type": "method",
          "name": "randomBytes",
          "desc": "<!--\nGenerates cryptographically strong pseudo-random data. Usage:\n-->\n\n<p>暗号学的で、強い疑似乱数データを生成します。使用法:\n\n</p>\n<pre><code>// async\ncrypto.randomBytes(256, function(ex, buf) {\n  if (ex) throw ex;\n  console.log('Have %d bytes of random data: %s', buf.length, buf);\n});\n\n// sync\ntry {\n  var buf = crypto.randomBytes(256);\n  console.log('Have %d bytes of random data: %s', buf.length, buf);\n} catch (ex) {\n  // handle error\n  // most likely, entropy sources are drained\n}</code></pre>\n<!--\nNOTE: Will throw error or invoke callback with error, if there is not enough\naccumulated entropy to generate cryptographically strong data. In other words,\n`crypto.randomBytes` without callback will not block even if all entropy sources\nare drained.\n-->\n\n<p>注意: もし暗号理論的に強いデータを生成するために十分な累積エントロピーが\nなければ、エラーがスローされるか、エラーと共にコールバックが呼ばれます。\n言い換えると、コールバックを渡さずに <code>crypto.randomBytes()</code> を呼び出しても、\n全てのエントロピー源が枯渇するまでブロックするわけではありません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "size"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.pseudoRandomBytes(size, [callback])",
          "type": "method",
          "name": "pseudoRandomBytes",
          "desc": "<!--\nGenerates *non*-cryptographically strong pseudo-random data. The data\nreturned will be unique if it is sufficiently long, but is not\nnecessarily unpredictable. For this reason, the output of this\nfunction should never be used where unpredictability is important,\nsuch as in the generation of encryption keys.\n-->\n\n<p>暗号学的では <em>ない</em>、強い疑似乱数データを生成します。\n返されるデータは十分に長ければユニークですが、\n必ずしも予測不可能ではありません。\nこの理由のため、この関数の出力を暗号化キーの生成など、予測不可能であることが\n重要なところでは決して使用しないでください。\n\n</p>\n<!--\nUsage is otherwise identical to `crypto.randomBytes`.\n-->\n\n<p>他の使い方は <code>crypto.randomBytes</code> と同じです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "size"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Hash",
          "type": "class",
          "name": "Hash",
          "desc": "<!--\nThe class for creating hash digests of data.\n-->\n\n<p>データのハッシュダイジェストを作成するためのクラスです。\n\n</p>\n<!--\nIt is a [stream](stream.html) that is both readable and writable.  The\nwritten data is used to compute the hash.  Once the writable side of\nthe stream is ended, use the `read()` method to get the computed hash\ndigest.  The legacy `update` and `digest` methods are also supported.\n-->\n\n<p>これは読み込みと書き込みの両方が可能な <a href="\"stream.html\"">ストリーム</a> です。\n書き込まれたデータはハッシュを計算するために使われます。\n一度ストリームの書き込み側が閉じられると、計算されたハッシュダイジェストを\n読み出すために <code>read()</code> メソッドを使うことができます。\nレガシーな <code>update()</code> および <code>digest()</code> メソッドもサポートされます。\n\n</p>\n<!--\nReturned by `crypto.createHash`.\n-->\n\n<p><code>crypto.createHash()</code> から返されます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "hash.update(data, [input_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdates the hash content with the given `data`, the encoding of which\nis given in `input_encoding` and can be `'utf8'`, `'ascii'` or\n`'binary'`.  If no encoding is provided and the input is a string an\nencoding of `'binary'` is enforced. If `data` is a `Buffer` then\n`input_encoding` is ignored.\n-->\n\n<p>与えられた <code>data</code> でハッシュの内容を更新します。\nそのエンコーディングは <code>input_encoding</code> で与えられ、<code>'utf8'</code>、<code>'ascii'</code>、\nまたは <code>'binary'</code> を指定することができます。\n<code>data</code> が文字列でエンコーディングが与えられなかった場合は、エンコーディングは\n<code>'binary'</code> が強制されます。\nもし <code>data</code> が <code>Buffer</code> なら、<code>input_encoding</code> は無視されます。\n\n</p>\n<!--\nThis can be called many times with new data as it is streamed.\n-->\n\n<p>これは新しいデータがストリームに流される際に何度も呼び出されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "hash.digest([encoding])",
              "type": "method",
              "name": "digest",
              "desc": "<!--\nCalculates the digest of all of the passed data to be hashed.  The\n`encoding` can be `'hex'`, `'binary'` or `'base64'`.  If no encoding\nis provided, then a buffer is returned.\n-->\n\n<p>渡された全てのデータがハッシュ化されたダイジェストを計算します。\n<code>encoding</code> は <code>'hex'</code>、<code>'binary'</code>、または <code>'base64'</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n<!--\nNote: `hash` object can not be used after `digest()` method has been\ncalled.\n-->\n\n<p>注意: <code>digest()</code> メソッドが呼び出された後で <code>hash</code> \nオブジェクトを使うことはできません。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Hmac",
          "type": "class",
          "name": "Hmac",
          "desc": "<!--\nClass for creating cryptographic hmac content.\n\nReturned by `crypto.createHmac`.\n-->\n\n<p>hmac を作成するためのクラスです。\n\n</p>\n<p><code>crypto.createHamc</code> から返されます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "hmac.update(data)",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdate the hmac content with the given `data`.  This can be called\nmany times with new data as it is streamed.\n-->\n\n<p>与えられた <code>data</code> で HMAC の内容を更新します。\nこれは新しいデータがストリームに流される際に何度も呼び出されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "hmac.digest([encoding])",
              "type": "method",
              "name": "digest",
              "desc": "<!--\nCalculates the digest of all of the passed data to the hmac.  The\n`encoding` can be `'hex'`, `'binary'` or `'base64'`.  If no encoding\nis provided, then a buffer is returned.\n-->\n\n<p>渡された全てのデータが HMAC 化されたダイジェストを計算します。\n<code>encoding</code> は <code>'hex'</code>、<code>'binary'</code>、または <code>'base64'</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n<!--\nNote: `hmac` object can not be used after `digest()` method has been\ncalled.\n-->\n\n<p>注意: <code>digest()</code> メソッドが呼び出された後で <code>hmac</code> \nオブジェクトを使うことはできません。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Cipher",
          "type": "class",
          "name": "Cipher",
          "desc": "<!--\nClass for encrypting data.\n-->\n\n<p>データを暗号化するためのクラスです。\n\n</p>\n<!--\nReturned by `crypto.createCipher` and `crypto.createCipheriv`.\n-->\n\n<p><code>crypto.createCipher</code> および <code>crypto.createCipheriv</code> から返されます。\n\n</p>\n<!--\nCipher objects are [streams](stream.html) that are both readable and\nwritable.  The written plain text data is used to produce the\nencrypted data on the readable side.  The legacy `update` and `final`\nmethods are also supported.\n-->\n\n<p>暗号化オブジェクトは読み込みと書き込みの両方が可能な\n<a href="\"stream.html\"">ストリーム</a> です。\n書き込まれたプレーンテキストデータは、読み込み側に暗号化されたデータを\n生成するために使われます。\nレガシーな <code>update()</code> および <code>final()</code> メソッドもサポートされます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "cipher.update(data, [input_encoding], [output_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdates the cipher with `data`, the encoding of which is given in\n`input_encoding` and can be `'utf8'`, `'ascii'` or `'binary'`.  If no\nencoding is provided, then a buffer is expected.\nIf `data` is a `Buffer` then `input_encoding` is ignored.\n-->\n\n<p><code>data</code> で暗号を更新します。\n<code>input_encoding</code> で与えられるエンコーディングは <code>'utf8'</code>、<code>'ascii'</code>、<code>'binary'</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが期待されます。\nもし <code>data</code> が <code>Buffer</code> なら、<code>input_encoding</code> は無視されます。\n\n</p>\n<!--\nThe `output_encoding` specifies the output format of the enciphered\ndata, and can be `'binary'`, `'base64'` or `'hex'`.  If no encoding is\nprovided, then a buffer is returned.\n-->\n\n<p><code>output_encoding</code> は暗号化されたデータの出力フォーマットを指定するもので、\n<code>'utf8'</code>、<code>'ascii'</code> または <code>'binary'</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n<!--\nReturns the enciphered contents, and can be called many times with new\ndata as it is streamed.\n-->\n\n<p>暗号化されたコンテンツが返されます。これは新しいデータがストリームに流される際に何度も呼び出されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "cipher.final([output_encoding])",
              "type": "method",
              "name": "final",
              "desc": "<!--\nReturns any remaining enciphered contents, with `output_encoding`\nbeing one of: `'binary'`, `'base64'` or `'hex'`.  If no encoding is\nprovided, then a buffer is returned.\n-->\n\n<p>暗号化されたコンテンツの残りを返します。\n<code>output_encoding</code> は次のいずれかです: <code>'binary'</code>、<code>'base64'</code> または <code>'hex'</code>。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n<!--\nNote: `cipher` object can not be used after `final()` method has been\ncalled.\n-->\n\n<p>注意: <code>final()</code> メソッドが呼び出された後で <code>cipher</code> \nオブジェクトを使うことはできません。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "cipher.setAutoPadding(auto_padding=true)",
              "type": "method",
              "name": "setAutoPadding",
              "desc": "<!--\nYou can disable automatic padding of the input data to block size. If\n`auto_padding` is false, the length of the entire input data must be a\nmultiple of the cipher's block size or `final` will fail.  Useful for\nnon-standard padding, e.g. using `0x0` instead of PKCS padding. You\nmust call this before `cipher.final`.\n-->\n\n<p>入力データが自動的にブロックサイズにパディングされることを\n抑止することができます。\n<code>auto_padding</code> が <code>false</code> の場合、入力データ全体の長さは\n暗号ブロックサイズの倍数でなければなりません。\nでなければ、<code>final()</code> は失敗します。\nこれは非標準のパディング、たとえば PKCS パディングの代わりに\n<code>0x0</code> を使う場合に便利です。\n<code>cipher.final()</code> の前に呼び出す必要があります。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "auto_padding",
                      "default": "true"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Decipher",
          "type": "class",
          "name": "Decipher",
          "desc": "<!--\nClass for decrypting data.\n\nReturned by `crypto.createDecipher` and `crypto.createDecipheriv`.\n-->\n\n<p>復号化のためのクラスです。\n\n</p>\n<p><code>crypto.createDecipher</code> および <code>crypto.createDecipheriv</code> から返されます。\n\n</p>\n<!--\nDecipher objects are [streams](stream.html) that are both readable and\nwritable.  The written enciphered data is used to produce the\nplain-text data on the the readable side.  The legacy `update` and\n`final` methods are also supported.\n-->\n\n<p>復号化オブジェクトは読み込みと書き込みの両方が可能な\n<a href="\"stream.html\"">ストリーム</a> です。\n書き込まれた暗号化データは、読み込み側にプレーンテキストデータを\n生成するために使われます。\nレガシーな <code>update()</code> および <code>final()</code> メソッドもサポートされます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "decipher.update(data, [input_encoding], [output_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdates the decipher with `data`, which is encoded in `'binary'`,\n`'base64'` or `'hex'`.  If no encoding is provided, then a buffer is\nexpected.\nIf `data` is a `Buffer` then `input_encoding` is ignored.\n-->\n\n<p><code>'binary'</code>、<code>'base64'</code> または <code>'hex'</code> のいずれかでエンコードされた復号を\n<code>data</code> で更新します。\nエンコーディングが与えられなかった場合はバッファが期待されます。\nもし <code>data</code> が <code>Buffer</code> なら、<code>input_encoding</code> は無視されます。\n\n</p>\n<!--\nThe `output_decoding` specifies in what format to return the\ndeciphered plaintext: `'binary'`, `'ascii'` or `'utf8'`.  If no\nencoding is provided, then a buffer is returned.\n-->\n\n<p><code>output_decoding</code> は復号化されたプレーンテキストのフォーマットを指定するもので、\n<code>'binary'</code>、<code>'ascii'</code> あるいは <code>'utf8'</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.final([output_encoding])",
              "type": "method",
              "name": "final",
              "desc": "<!--\nReturns any remaining plaintext which is deciphered, with\n`output_encoding` being one of: `'binary'`, `'ascii'` or `'utf8'`.  If\nno encoding is provided, then a buffer is returned.\n-->\n\n<p>復号化されたプレーンテキストの残りを返します。\n<code>output_decoding</code> は <code>'binary'</code>、<code>'ascii'</code> あるいは <code>'utf8'</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n<!--\nNote: `decipher` object can not be used after `final()` method has been\ncalled.\n-->\n\n<p>注意: <code>final()</code> メソッドが呼び出された後で <code>decipher</code> \nオブジェクトを使うことはできません。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.setAutoPadding(auto_padding=true)",
              "type": "method",
              "name": "setAutoPadding",
              "desc": "<!--\nYou can disable auto padding if the data has been encrypted without\nstandard block padding to prevent `decipher.final` from checking and\nremoving it. Can only work if the input data's length is a multiple of\nthe ciphers block size. You must call this before streaming data to\n`decipher.update`.\n-->\n\n<p>データブロックが非標準のパディングで暗号化されている場合、\n<code>decipher.final()</code> によるチェックを無効にすることができます。\n入力データの長さが暗号ブロックサイズの倍数の場合のみ動作します。\n<code>decipher.update()</code> の前に呼び出す必要があります。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "auto_padding",
                      "default": "true"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Sign",
          "type": "class",
          "name": "Sign",
          "desc": "<!--\nClass for generating signatures.\n\nReturned by `crypto.createSign`.\n-->\n\n<p>署名を作成するためのクラスです。\n\n</p>\n<p><code>crypto.createSign</code> から返されます。\n\n</p>\n<!--\nSign objects are writable [streams](stream.html).  The written data is\nused to generate the signature.  Once all of the data has been\nwritten, the `sign` method will return the signature.  The legacy\n`update` method is also supported.\n-->\n\n<p>署名オブジェクトは書き込み可能な <a href="\"stream.html\"">ストリーム</a> です。\n書き込まれたデータは署名を生成するために使われます。\n全てのデータが書き込まれると、<code>sign()</code> メソッドはその署名を返します。\nレガシーな <code>update()</code> メソッドもサポートされます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "sign.update(data)",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdates the sign object with data.  This can be called many times\nwith new data as it is streamed.\n-->\n\n<p>署名オブジェクトをデータで更新します。\nこれは新しいデータがストリームに流される際に何度も呼び出されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "sign.sign(private_key, [output_format])",
              "type": "method",
              "name": "sign",
              "desc": "<!--\nCalculates the signature on all the updated data passed through the\nsign.  `private_key` is a string containing the PEM encoded private\nkey for signing.\n-->\n\n<p>署名オブジェクトに渡された全ての更新データで署名を計算します。\n<code>private_key</code> は PEM でエンコードされた秘密鍵を内容とする文字列です。\n\n</p>\n<!--\nReturns the signature in `output_format` which can be `'binary'`,\n`'hex'` or `'base64'`. If no encoding is provided, then a buffer is\nreturned.\n-->\n\n<p><code>'binary'</code>、<code>'hex'</code>、あるいは <code>'base64'</code> のいずれかを指定した <code>output_format</code>\nによる署名を返します。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n<!--\nNote: `sign` object can not be used after `sign()` method has been\ncalled.\n-->\n\n<p>注意: <code>sign()</code> メソッドが呼び出された後で <code>sign</code> \nオブジェクトを使うことはできません。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "output_format",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Verify",
          "type": "class",
          "name": "Verify",
          "desc": "<!--\nClass for verifying signatures.\n\nReturned by `crypto.createVerify`.\n-->\n\n<p>署名を検証するためのクラスです。\n\n</p>\n<p><code>crypto.createVerify</code> から返されます。\n\n</p>\n<!--\nVerify objects are writable [streams](stream.html).  The written data\nis used to validate against the supplied signature.  Once all of the\ndata has been written, the `verify` method will return true if the\nsupplied signature is valid.  The legacy `update` method is also\nsupported.\n-->\n\n<p>検証オブジェクトは書き込み可能な <a href="\"stream.html\"">ストリーム</a> です。\n書き込まれたデータは与えられた署名を検証するために使われます。\n全てのデータが書き込まれると、<code>verify()</code> メソッドは与えられた署名が正しければ\n<code>true</code> を返します。\nレガシーな <code>update()</code> メソッドもサポートされます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "verifier.update(data)",
              "type": "method",
              "name": "update",
              "desc": "<!--\nUpdates the verifier object with data.  This can be called many times\nwith new data as it is streamed.\n-->\n\n<p>検証オブジェクトをデータで更新します。\nこれは新しいデータがストリームに流される際に何度も呼び出されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "verifier.verify(object, signature, [signature_format])",
              "type": "method",
              "name": "verify",
              "desc": "<!--\nVerifies the signed data by using the `object` and `signature`.\n`object` is  a string containing a PEM encoded object, which can be\none of RSA public key, DSA public key, or X.509 certificate.\n`signature` is the previously calculated signature for the data, in\nthe `signature_format` which can be `'binary'`, `'hex'` or `'base64'`.\nIf no encoding is specified, then a buffer is expected.\n-->\n\n<p>署名されたデータを <code>object</code> と <code>signature</code> で検証します。\n<code>object</code> は RSA 公開鍵、DSA 公開鍵、X.509証明書のいずれかを\nPEM でエンコードしたオブジェクトです。\n<code>signature</code> は先に計算したデータの署名で、\nその <code>signature_format</code> は <code>'binary'</code>、<code>'hex'</code>、または <code>'base64'</code>\nのいずれかです。\nエンコーディングが与えられなかった場合はバッファが期待されます。\n\n</p>\n<!--\nReturns true or false depending on the validity of the signature for\nthe data and public key.\n-->\n\n<p>署名されたデータと公開鍵による検証の結果によって true または false を返します。\n\n</p>\n<!--\nNote: `verifier` object can not be used after `verify()` method has been\ncalled.\n-->\n\n<p>注意: <code>verify()</code> メソッドを呼び出した後で <code>verifier</code> \nオブジェクトを使うことはできません。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "object"
                    },
                    {
                      "name": "signature"
                    },
                    {
                      "name": "signature_format",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: DiffieHellman",
          "type": "class",
          "name": "DiffieHellman",
          "desc": "<!--\nThe class for creating Diffie-Hellman key exchanges.\n\nReturned by `crypto.createDiffieHellman`.\n-->\n\n<p>ディフィー・ヘルマン鍵共有のためのクラスです。\n\n</p>\n<p><code>crypto.creaateDiffieHellman</code> から返されます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "diffieHellman.generateKeys([encoding])",
              "type": "method",
              "name": "generateKeys",
              "desc": "<!--\nGenerates private and public Diffie-Hellman key values, and returns\nthe public key in the specified encoding. This key should be\ntransferred to the other party. Encoding can be `'binary'`, `'hex'`,\nor `'base64'`.  If no encoding is provided, then a buffer is returned.\n-->\n\n<p>ディフィー・ヘルマン法で秘密および公開鍵を作成し、\n指定の方法でエンコーディングされた公開鍵を返します。\nこの鍵は相手側に渡されるものです。\nエンコーディングは <code>'binary'</code>、<code>'hex'</code>、または <code>'base64'</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])",
              "type": "method",
              "name": "computeSecret",
              "desc": "<!--\nComputes the shared secret using `other_public_key` as the other\nparty's public key and returns the computed shared secret. Supplied\nkey is interpreted using specified `input_encoding`, and secret is\nencoded using specified `output_encoding`. Encodings can be\n`'binary'`, `'hex'`, or `'base64'`. If the input encoding is not\nprovided, then a buffer is expected.\n-->\n\n<p><code>other_public_key</code> を相手側の公開鍵として共有の秘密鍵を計算して返します。\n与えられた公開鍵は指定の <code>input_encoding</code> を使って解釈され、\n秘密鍵は <code>output_encoding</code> で指定された方法でエンコードされます。\nエンコーディングは <code>'binary'</code>、<code>'hex'</code>、または <code>'base64'</code> のいずれかです。\n入力のエンコーディングが与えられなかった場合はバッファが期待されます。\n\n</p>\n<!--\nIf no output encoding is given, then a buffer is returned.\n-->\n\n<p>出力のエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "other_public_key"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPrime([encoding])",
              "type": "method",
              "name": "getPrime",
              "desc": "<!--\nReturns the Diffie-Hellman prime in the specified encoding, which can\nbe `'binary'`, `'hex'`, or `'base64'`. If no encoding is provided,\nthen a buffer is returned.\n-->\n\n<p>ディフィー・ヘルマン法の素数を指定のエンコーディングで返します。\nエンコーディングは <code>'binary'</code>、<code>'hex'</code>、または <code>'base64'</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getGenerator([encoding])",
              "type": "method",
              "name": "getGenerator",
              "desc": "<!--\nReturns the Diffie-Hellman generator in the specified encoding, which can\nbe `'binary'`, `'hex'`, or `'base64'`. If no encoding is provided,\nthen a buffer is returned.\n-->\n\n<p>ディフィー・ヘルマン法の生成元を指定のエンコーディングで返します。\nエンコーディングは <code>'binary'</code>、<code>'hex'</code>、または <code>'base64'</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPublicKey([encoding])",
              "type": "method",
              "name": "getPublicKey",
              "desc": "<!--\nReturns the Diffie-Hellman public key in the specified encoding, which\ncan be `'binary'`, `'hex'`, or `'base64'`. If no encoding is provided,\nthen a buffer is returned.\n-->\n\n<p>ディフィー・ヘルマン法による公開鍵を指定のエンコーディングで返します。\nエンコーディングは <code>'binary'</code>、<code>'hex'</code>、または <code>'base64'</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPrivateKey([encoding])",
              "type": "method",
              "name": "getPrivateKey",
              "desc": "<!--\nReturns the Diffie-Hellman private key in the specified encoding,\nwhich can be `'binary'`, `'hex'`, or `'base64'`. If no encoding is\nprovided, then a buffer is returned.\n-->\n\n<p>ディフィー・ヘルマン法による秘密鍵を指定のエンコーディングで返します。\nエンコーディングは <code>'binary'</code>、<code>'hex'</code>、または <code>'base64'</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが返されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.setPublicKey(public_key, [encoding])",
              "type": "method",
              "name": "setPublicKey",
              "desc": "<!--\nSets the Diffie-Hellman public key. Key encoding can be `'binary'`,\n`'hex'` or `'base64'`. If no encoding is provided, then a buffer is\nexpected.\n-->\n\n<p>ディフィー・ヘルマン法による公開鍵を設定します。\n鍵のエンコーディングは <code>'binary'</code>、<code>'hex'</code>、または <code>'base64'</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが期待されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "public_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.setPrivateKey(private_key, [encoding])",
              "type": "method",
              "name": "setPrivateKey",
              "desc": "<!--\nSets the Diffie-Hellman private key. Key encoding can be `'binary'`,\n`'hex'` or `'base64'`. If no encoding is provided, then a buffer is\nexpected.\n-->\n\n<p>ディフィー・ヘルマン法による秘密鍵を設定します。\n鍵のエンコーディングは <code>'binary'</code>、<code>'hex'</code>、または <code>'base64'</code> のいずれかです。\nエンコーディングが与えられなかった場合はバッファが期待されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "crypto.DEFAULT_ENCODING",
          "name": "DEFAULT_ENCODING",
          "desc": "<!--\nThe default encoding to use for functions that can take either strings\nor buffers.  The default value is `'buffer'`, which makes it default\nto using Buffer objects.  This is here to make the crypto module more\neasily compatible with legacy programs that expected `'binary'` to be\nthe default encoding.\n-->\n\n<p>関数が使用するエンコーディングのデフォルトは、文字列かバッファの\nいずれかにすることができます。\n\n</p>\n<!--\nNote that new programs will probably expect buffers, so only use this\nas a temporary measure.\n-->\n\n<p>新しいプログラムはおそらくバッファを期待することに注意してください。\nこれは一時的な手段としてのみ使用してください。\n\n</p>\n"
        }
      ],
      "modules": [
        {
          "textRaw": "Recent API Changes",
          "name": "recent_api_changes",
          "desc": "<!--\nThe Crypto module was added to Node before there was the concept of a\nunified Stream API, and before there were Buffer objects for handling\nbinary data.\n-->\n\n<p>Crypto モジュールは、統合されたストリーム API やバイトデータを扱う Buffer\nオブジェクトよりも先に Node に追加されました。\n\n</p>\n<!--\nAs such, the streaming classes don't have the typical methods found on\nother Node classes, and many methods accepted and returned\nBinary-encoded strings by default rather than Buffers.  This was\nchanged to use Buffers by default instead.\n-->\n\n<p>そのため、このストリーミングなクラスは他の Node のクラスに見られる\n典型的なメソッドを持たず、多くのメソッドは引数や戻り値に\nBuffer ではなくバイナリエンコードされた文字列を使います。\n\n</p>\n<!--\nThis is a breaking change for some use cases, but not all.\n-->\n\n<p>これはあるユースケースにおいては互換性を損ないますが、\n全てのケースではありません。\n\n</p>\n<!--\nFor example, if you currently use the default arguments to the Sign\nclass, and then pass the results to the Verify class, without ever\ninspecting the data, then it will continue to work as before.  Where\nyou once got a binary string and then presented the binary string to\nthe Verify object, you'll now get a Buffer, and present the Buffer to\nthe Verify object.\n-->\n\n<p>たとえば、Sign クラスをデフォルト引数で使っていて、\nその結果を全く調べずに Verify クラスに渡している場合、\nそれは以前と同じように動くでしょう。\nそれは、現時点ではバイナリ文字列を受け取ってそのバイナリ文字列を\nVeriy オブジェクトに渡しますが、将来は Buffer を受け取ってその\nBuffer を Verify オブジェクトに渡すようになります。\n\n</p>\n<!--\nHowever, if you were doing things with the string data that will not\nwork properly on Buffers (such as, concatenating them, storing in\ndatabases, etc.), or you are passing binary strings to the crypto\nfunctions without an encoding argument, then you will need to start\nproviding encoding arguments to specify which encoding you'd like to\nuse.  To switch to the previous style of using binary strings by\ndefault, set the `crypto.DEFAULT_ENCODING` field to 'binary'.  Note\nthat new programs will probably expect buffers, so only use this as a\ntemporary measure.\n-->\n\n<p>しかしながら、Buffer が文字列と正確に同じようには動かない何かをしている場合\n(例えば、それらを連結したり、データベースに保存したりするなど)、\nあるいはバイナリ文字列を Crypto の関数にエンコーディング引数無しで\n渡している場合、エンコーディング引数を与えてどのエンコーディングを\n使用しているかを指定する必要があります。\n以前のようにデフォルトでバイナリ文字列を使うように切り替えるには、\n<code>crypto.DEFAULT_ENCODING</code> フィールドに <code>binary</code> を設定します。\n新しいプログラムはおそらくバッファを期待することに注意してください。\nこれは一時的な手段としてのみ使用してください。\n\n\n</p>\n",
          "type": "module",
          "displayName": "Recent API Changes"
        }
      ],
      "type": "module",
      "displayName": "Crypto"
    },
    {
      "textRaw": "TLS (SSL)",
      "name": "tls_(ssl)",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<!--\nUse `require('tls')` to access this module.\n-->\n\n<p><code>require('tls')</code> でこのモジュールにアクセスします。\n\n</p>\n<!--\nThe `tls` module uses OpenSSL to provide Transport Layer Security and/or\nSecure Socket Layer: encrypted stream communication.\n-->\n\n<p><code>tls</code> モジュールは OpenSSL を使用することで Transport Layer Security および\nSecure Socket Layer: 暗号化されたストリーム通信を提供します。\n\n</p>\n<!--\nTLS/SSL is a public/private key infrastructure. Each client and each\nserver must have a private key. A private key is created like this\n-->\n\n<p>TLS/SSL は公開／秘密鍵を基礎とします。\nどのクライアントとサーバも秘密鍵が必要です。\n秘密鍵は次のように作成します\n\n</p>\n<pre><code>openssl genrsa -out ryans-key.pem 1024</code></pre>\n<!--\nAll severs and some clients need to have a certificate. Certificates are public\nkeys signed by a Certificate Authority or self-signed. The first step to\ngetting a certificate is to create a \"Certificate Signing Request\" (CSR)\nfile. This is done with:\n-->\n\n<p>全てのサーバと一部のクライアントは証明書を必要とします。\n証明書は認証局の公開鍵または自身によって署名されます。\n証明書を作成する最初のステップは「証明書署名要求 (CSR)」ファイルです。\n次のようにします:\n\n</p>\n<pre><code>openssl req -new -key ryans-key.pem -out ryans-csr.pem</code></pre>\n<!--\nTo create a self-signed certificate with the CSR, do this:\n-->\n\n<p>CSR から自己署名証明書を作成するには次のようにします:\n\n</p>\n<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre>\n<!--\nAlternatively you can send the CSR to a Certificate Authority for signing.\n-->\n\n<p>他に CSR を認証局に送って署名してもらうこともできます。\n\n</p>\n<!--\n(TODO: docs on creating a CA, for now interested users should just look at\n`test/fixtures/keys/Makefile` in the Node source code)\n-->\n\n<p>(TODO: CA を作るドキュメント、現在は興味あるユーザは Node のソースコードから\n<code>test/fixtures/keys/Makefile</code> を見る必要がある)\n\n</p>\n<!--\nTo create .pfx or .p12, do this:\n-->\n\n<p>.pfx または .p12 を作成するには次のようにします:\n\n</p>\n<pre><code>openssl pkcs12 -export -in agent5-cert.pem -inkey agent5-key.pem \\\n    -certfile ca-cert.pem -out agent5.pfx</code></pre>\n<ul>\n<li><code>in</code>:  certificate</li>\n<li><code>inkey</code>: private key</li>\n<li><code>certfile</code>: all CA certs concatenated in one file like\n<code>cat ca1-cert.pem ca2-cert.pem > ca-cert.pem</code></li>\n</ul>\n",
      "miscs": [
        {
          "textRaw": "Client-initiated renegotiation attack mitigation",
          "name": "Client-initiated renegotiation attack mitigation",
          "type": "misc",
          "desc": "<!--\nThe TLS protocol lets the client renegotiate certain aspects of the TLS session.\nUnfortunately, session renegotiation requires a disproportional amount of\nserver-side resources, which makes it a potential vector for denial-of-service\nattacks.\n\nTo mitigate this, renegotiations are limited to three times every 10 minutes. An\nerror is emitted on the [CleartextStream][] instance when the threshold is\nexceeded. The limits are configurable:\n\n  - `tls.CLIENT_RENEG_LIMIT`: renegotiation limit, default is 3.\n\n  - `tls.CLIENT_RENEG_WINDOW`: renegotiation window in seconds, default is\n    10 minutes.\n\nDon't change the defaults unless you know what you are doing.\n\nTo test your server, connect to it with `openssl s_client -connect address:port`\nand tap `R<CR>` (that's the letter `R` followed by a carriage return) a few\ntimes.\n-->\n\n<p>TLS プロトコルでは、クライアントに TLS セッションの再ネゴシエーションを\n許します。\n\n</p>\n<p>残念ながら、セッション再ネゴシエーション要求はサーバサイドに過度なリソースを\n要求するため、それは潜在的なサーバ強制停止攻撃となります。\n\n</p>\n<p>これを軽減するために、再ネゴシエーションは 10 分当たり 3 回までに\n制限されています。この制限を超えると、[CleartextStream][]\nのインスタンス上でエラーが生成されます。この制限は変更可能です:\n\n</p>\n<ul>\n<li><p><code>tls.CLIENT_RENEG_LIMIT</code>: 再ネゴシエーションの上限、デフォルトは 3 です。</p>\n</li>\n<li><p><code>tls.CLIENT_RENEG_WINDOW</code>: 秒単位の再ネゴシエーションウィンドウ、\nデフォルトは 10 分です。</p>\n</li>\n</ul>\n<p>あなたが何をしようとしているか十分に理解していない限り、\nデフォルトを変更しないでください。\n\n</p>\n<p>サーバをテストするために、<code>openssl s_client -connect address:port</code>\nおよび <code>R<CR></code> (<code>R</code> キーの後に続けてリターンキー) を\n数回繰り返します。\n\n\n</p>\n"
        },
        {
          "textRaw": "NPN and SNI",
          "name": "NPN and SNI",
          "type": "misc",
          "desc": "<!--\nNPN (Next Protocol Negotiation) and SNI (Server Name Indication) are TLS\nhandshake extensions allowing you:\n\n  * NPN - to use one TLS server for multiple protocols (HTTP, SPDY)\n  * SNI - to use one TLS server for multiple hostnames with different SSL\n    certificates.\n-->\n\n<p>NPN (Next Protocol Negotitation) と SNI (Server Name Indication) は\nTLS の拡張で、以下を可能にします。\n\n</p>\n<ul>\n<li>NPN - 一つの TLS サーバで複数のプロトコル (HTTP、SPDY) を使用。</li>\n<li>SNI - 一つの TLS サーバでホスト名の異なる複数の証明書を使用。</li>\n</ul>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "tls.getCiphers()",
          "type": "method",
          "name": "getCiphers",
          "desc": "<!--\nReturns an array with the names of the supported SSL ciphers.\n-->\n\n<p>サポートされている SSL 暗号名の配列を返します。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var ciphers = tls.getCiphers();\nconsole.log(ciphers); // ['AES128-SHA', 'AES256-SHA', ...]</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "tls.createServer(options, [secureConnectionListener])",
          "type": "method",
          "name": "createServer",
          "desc": "<!--\nCreates a new [tls.Server][].  The `connectionListener` argument is\nautomatically set as a listener for the [secureConnection][] event.  The\n`options` object has these possibilities:\n-->\n\n<p>新しい [tls.Server][] を作成します。\n<code>connectionListener</code> は [secureConnection][] イベントのリスナとして\n自動的に登録されます。\n<code>options</code> は以下を持つことができます:\n\n\n</p>\n<!--\n  - `pfx`: A string or `Buffer` containing the private key, certificate and\n    CA certs of the server in PFX or PKCS12 format. (Mutually exclusive with\n    the `key`, `cert` and `ca` options.)\n\n  - `key`: A string or `Buffer` containing the private key of the server in\n    PEM format. (Required)\n\n  - `passphrase`: A string of passphrase for the private key or pfx.\n\n  - `cert`: A string or `Buffer` containing the certificate key of the server in\n    PEM format. (Required)\n\n  - `ca`: An array of strings or `Buffer`s of trusted certificates in PEM\n    format. If this is omitted several well known \"root\" CAs will be used,\n    like VeriSign. These are used to authorize connections.\n\n  - `crl` : Either a string or list of strings of PEM encoded CRLs (Certificate\n    Revocation List)\n\n  - `ciphers`: A string describing the ciphers to use or exclude.\n\n    To mitigate [BEAST attacks] it is recommended that you use this option in\n    conjunction with the `honorCipherOrder` option described below to\n    prioritize the non-CBC cipher.\n\n    Defaults to `AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH`.\n    Consult the [OpenSSL cipher list format documentation] for details on the\n    format. ECDH (Elliptic Curve Diffie-Hellman) ciphers are not yet supported.\n\n\n    `AES128-GCM-SHA256` is used when node.js is linked against OpenSSL 1.0.1\n    or newer and the client speaks TLS 1.2, RC4 is used as a secure fallback.\n\n    **NOTE**: Previous revisions of this section suggested `AES256-SHA` as an\n    acceptable cipher. Unfortunately, `AES256-SHA` is a CBC cipher and therefore\n    susceptible to BEAST attacks. Do *not* use it.\n\n  - `handshakeTimeout`: Abort the connection if the SSL/TLS handshake does not\n    finish in this many milliseconds. The default is 120 seconds.\n\n    A `'clientError'` is emitted on the `tls.Server` object whenever a handshake\n    times out.\n\n  - `honorCipherOrder` : When choosing a cipher, use the server's preferences\n    instead of the client preferences.\n\n    Note that if SSLv2 is used, the server will send its list of preferences\n    to the client, and the client chooses the cipher.\n\n    Although, this option is disabled by default, it is *recommended* that you\n    use this option in conjunction with the `ciphers` option to mitigate\n    BEAST attacks.\n\n  - `requestCert`: If `true` the server will request a certificate from\n    clients that connect and attempt to verify that certificate. Default:\n    `false`.\n\n  - `rejectUnauthorized`: If `true` the server will reject any connection\n    which is not authorized with the list of supplied CAs. This option only\n    has an effect if `requestCert` is `true`. Default: `false`.\n\n  - `NPNProtocols`: An array or `Buffer` of possible NPN protocols. (Protocols\n    should be ordered by their priority).\n\n  - `SNICallback`: A function that will be called if client supports SNI TLS\n    extension. Only one argument will be passed to it: `servername`. And\n    `SNICallback` should return SecureContext instance.\n    (You can use `crypto.createCredentials(...).context` to get proper\n    SecureContext). If `SNICallback` wasn't provided - default callback with\n    high-level API will be used (see below).\n\n  - `sessionIdContext`: A string containing a opaque identifier for session\n    resumption. If `requestCert` is `true`, the default is MD5 hash value\n    generated from command-line. Otherwise, the default is not provided.\n\n  - `secureProtocol`: The SSL method to use, e.g. `SSLv3_method` to force\n    SSL version 3. The possible values depend on your installation of\n    OpenSSL and are defined in the constant [SSL_METHODS][].\n-->\n\n<ul>\n<li><p><code>pfx</code> : PFX または PKCS12 でエンコードされた秘密鍵、証明書、および CA の\n証明書を含む文字列またはバッファ\n(<code>key</code>、<code>cert</code>、および <code>ca</code> オプションとは相互に排他的です)。</p>\n</li>\n<li><p><code>key</code>: PEM フォーマットによるサーバの秘密鍵を持つ文字列または <code>Buffer</code> です\n(必須)。</p>\n</li>\n<li><p><code>passphrase</code>: 秘密鍵または pfx のパスフレーズを表す文字列です。</p>\n</li>\n<li><p><code>cert</code>: PEM フォーマットによる証明書の鍵を持つ文字列または <code>Buffer</code> です\n(必須)。</p>\n</li>\n<li><p><code>ca</code>: PEMフォーマットによる信頼できる証明書の文字列または\n<code>Buffer</code> の配列です。\n省略された場合、ベリサインなどのよく知られた「ルート」認証局が使われます。\nこれらはコネクションの認証に使われます。</p>\n</li>\n<li><p><code>crl</code> : PEM でエンコードされた CRL (Certificate Revocation List、\n失効した証明書の一覧) の文字列または文字列の配列。</p>\n</li>\n<li><p><code>ciphers</code>: 使用または除外する暗号を記述した文字列です。</p>\n<p>[BEAST 攻撃]を抑制するために、このオプションと以下に示す <code>honorCipherOrder</code>\nを共に使って、非 CBC 暗号を優先することを推奨します。</p>\n<p>デフォルトは <code>AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL:!EDH</code> です。\n詳細は [OpenSSL 暗号リストフォーマットのドキュメント] を参照してください。\nECDH (Elliptic Curve Diffie-Hellman) 暗号はまだサポートされていません。</p>\n<p><code>AES128-GCM-SHA256</code> は、Node.js が OpenSSL 1.0.1 以降とリンクされていて、\nクライアントが TLS 1.2 をサポートしている場合に使われます。\nRC4 は安全なフォールバックとして使われます。</p>\n<p><strong>注意</strong>: 以前のバージョンのこのセクションは <code>AES256-SHA</code> を\n受け入れ可能な暗号であるかのように示していました。\n残念ながら、<code>AES256-SHA</code> は CBC 暗号であり、したがって BEAST\n攻撃には弱いです。</p>\n</li>\n<li><p><code>handshakeTimeout</code>: SSL/TLS ハンドシェークがこの時間 (ミリ秒)\n以内に終了しなかった場合は接続をアボートします。\nデフォルトは 120 秒です。</p>\n<p>ハンドシェークがタイムアウトすると、<code>tls.Server</code> オブジェクトで\n<code>'clientError'</code> イベントが生成されます。</p>\n</li>\n<li><p><code>honorCipherOrder</code> :\n暗号を選択する際に、クライアントではなくサーバの設定を使用します。</p>\n<p>SSLv2 が使われる場合は、サーバは設定のリストをクライアントに送信し、\nクライアントが暗号を選択することに注意してください。</p>\n<p>このオプションはデフォルトでは無効ですが、BEAST 攻撃を抑制するために\n<code>ciphers</code> オプションと共に使用することを <em>推奨</em> します。</p>\n</li>\n<li><p><code>requestCert</code>: <code>true</code> の場合、サーバは接続しようとするクライアントからの\n証明書を要求します。デフォルトは <code>false</code> です。</p>\n</li>\n<li><p><code>rejectUnauthorized</code>: <code>true</code> の場合、サーバは提供された認証局の\nリストによって認証されていないコネクションを破棄します．\nこのオプションは <code>requestCert</code> が <code>true</code> の場合だけ効果があります。\nデフォルトは <code>false</code> です。</p>\n</li>\n<li><p><code>NPNProtocols</code>: NPN プロトコルで使用可能な文字列または <code>Buffer</code> の配列\n(プロトコルはその優先度に応じて並んでいる必要があります)。</p>\n</li>\n<li><p><code>SNICallback</code>: クライアントが TLS 拡張の SNI をサポートしている場合に\n呼び出される関数です。\n<code>servername</code> が唯一の引数として渡されます。\n<code>SNICallback</code> は SecureContext のインスタンスを返す必要があります\n(SecureContext を取得するために <code>crypto.createCredentials(...).context</code>\nを使用することができます)。\n<code>SNICallback</code> が渡されなかった場合は、デフォルトのコールバックとして\n後述する高水準 API が使用されます。</p>\n</li>\n<li><p><code>sessionIdContext</code>: セッション再開のための識別子となる文字列です。\n<code>requestCedrt</code> が <code>true</code> の場合、デフォルトはコマンドライン引数から\n生成された MD5 ハッシュ値となります。\nそうでない場合はデフォルトは提供されません。</p>\n</li>\n<li><p><code>secureProtocol</code>: 使用する SSL メソッド、たとえば <code>SSLv3_method</code> は\nSSL version 3 の使用を強制します。可能な値は使用する OpenSSL によって\n定義される [SSL_METHODS][] 定数に依存します。</p>\n</li>\n</ul>\n<!--\nHere is a simple example echo server:\n-->\n\n<p>これはシンプルはエコーサーバの例です:\n\n</p>\n<pre><code>var tls = require('tls');\nvar fs = require('fs');\n\nvar options = {\n  key: fs.readFileSync('server-key.pem'),\n  cert: fs.readFileSync('server-cert.pem'),\n\n  // This is necessary only if using the client certificate authentication.\n  requestCert: true,\n\n  // This is necessary only if the client uses the self-signed certificate.\n  ca: [ fs.readFileSync('client-cert.pem') ]\n};\n\nvar server = tls.createServer(options, function(cleartextStream) {\n  console.log('server connected',\n              cleartextStream.authorized ? 'authorized' : 'unauthorized');\n  cleartextStream.write("welcome!\\n");\n  cleartextStream.setEncoding('utf8');\n  cleartextStream.pipe(cleartextStream);\n});\nserver.listen(8000, function() {\n  console.log('server bound');\n});</code></pre>\n<!--\nOr\n-->\n\n<p>あるいは:\n\n</p>\n<pre><code>var tls = require('tls');\nvar fs = require('fs');\n\nvar options = {\n  pfx: fs.readFileSync('server.pfx'),\n\n  // This is necessary only if using the client certificate authentication.\n  requestCert: true,\n\n};\n\nvar server = tls.createServer(options, function(cleartextStream) {\n  console.log('server connected',\n              cleartextStream.authorized ? 'authorized' : 'unauthorized');\n  cleartextStream.write("welcome!\\n");\n  cleartextStream.setEncoding('utf8');\n  cleartextStream.pipe(cleartextStream);\n});\nserver.listen(8000, function() {\n  console.log('server bound');\n});</code></pre>\n<!--\nYou can test this server by connecting to it with `openssl s_client`:\n-->\n\n<p><code>openssl s_client</code> を使用してこのサーバに接続するテストを行うことができます。\n\n</p>\n<pre><code>openssl s_client -connect 127.0.0.1:8000</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "secureConnectionListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "tls.connect(options, [callback])",
          "type": "method",
          "name": "connect",
          "desc": "<!--\nCreates a new client connection to the given `port` and `host` (old API) or\n`options.port` and `options.host`. (If `host` is omitted, it defaults to\n`localhost`.) `options` should be an object which specifies:\n-->\n\n<p>与えられた <code>port</code> と <code>host</code> (旧 API) または <code>options.port</code> と <code>options.host</code>\nで新しいクライアントコネクションを作成します\n(<code>host</code> が省略された場合、デフォルトは <code>localhost</code> です)。\n<code>options</code> は以下を指定したオブジェクトです:\n\n</p>\n<!--\n  - `host`: Host the client should connect to\n\n  - `port`: Port the client should connect to\n\n  - `socket`: Establish secure connection on a given socket rather than\n    creating a new socket. If this option is specified, `host` and `port`\n    are ignored.\n\n  - `pfx`: A string or `Buffer` containing the private key, certificate and\n    CA certs of the server in PFX or PKCS12 format.\n\n  - `key`: A string or `Buffer` containing the private key of the client in\n    PEM format.\n\n  - `passphrase`: A string of passphrase for the private key or pfx.\n\n  - `cert`: A string or `Buffer` containing the certificate key of the client in\n    PEM format.\n\n  - `ca`: An array of strings or `Buffer`s of trusted certificates in PEM\n    format. If this is omitted several well known \"root\" CAs will be used,\n    like VeriSign. These are used to authorize connections.\n\n  - `rejectUnauthorized`: If `true`, the server certificate is verified against\n    the list of supplied CAs. An `'error'` event is emitted if verification\n    fails. Default: `true`.\n\n  - `NPNProtocols`: An array of strings or `Buffer`s containing supported NPN\n    protocols. `Buffer`s should have following format: `0x05hello0x05world`,\n    where first byte is next protocol name's length. (Passing array should\n    usually be much simpler: `['hello', 'world']`.)\n\n  - `servername`: Servername for SNI (Server Name Indication) TLS extension.\n\n  - `secureProtocol`: The SSL method to use, e.g. `SSLv3_method` to force\n    SSL version 3. The possible values depend on your installation of\n    OpenSSL and are defined in the constant [SSL_METHODS][].\n-->\n\n<ul>\n<li><p><code>host</code>: クライアントが接続するホスト。</p>\n</li>\n<li><p><code>port</code>: クライアントが接続するポート番号。</p>\n</li>\n<li><p><code>socket</code>: 新しいソケットを生成するのではなく、与えられたソケット上で\nセキュアな接続を確立します。\nこのオプションが指定された場合、<code>host</code> および <code>port</code> は無視されます。</p>\n</li>\n<li><p><code>pfx</code> : PFX または PKCS12 でエンコードされた秘密鍵、証明書、\nおよびサーバに対する CA の証明書を含む文字列またはバッファ。</p>\n</li>\n<li><p><code>key</code>: PEM フォーマットによるサーバの秘密鍵を持つ文字列または\n<code>Buffer</code> です。</p>\n</li>\n<li><p><code>passphrase</code>: 秘密鍵または pfx のパスフレーズを表す文字列です。</p>\n</li>\n<li><p><code>cert</code>: PEM フォーマットによる証明書の鍵を持つ文字列または <code>Buffer</code> です。</p>\n</li>\n<li><p><code>ca</code>: PEMフォーマットによる信頼できる証明書の文字列または\n<code>Buffer</code> の配列です。\n省略された場合、ベリサインなどのよく知られた「ルート」認証局が使われます。\nこれらはコネクションの認証に使われます。</p>\n</li>\n<li><p><code>rejectUnauthorized</code>: <code>true</code> の場合、サーバ証明書は提供された認証局の\nリストによって検証されます。\n認証されなかった場合は <code>'error'</code> イベントが生成されます。\n認証は HTTP リクエストが送信される <em>前</em> にコネクションレベルで行われます。\nデフォルトは true です。</p>\n</li>\n<li><p><code>NPNProtocols</code>: サポートする NPN プロトコルの文字列または <code>Buffer</code> \nの配列です。\n<code>Buffer</code> は次のような形式です: <code>0x05hello0x5world</code>\n最初のバイトは次のプロトコル名の長さです\n(通常、配列を渡す方がシンプルです: <code>['hello', 'world']</code>)。</p>\n</li>\n<li><p><code>servername</code>: TLS 拡張である SNI (Server Name Indication) のサーバ名です。</p>\n</li>\n<li><p><code>secureProtocol</code>: 使用する SSL 方式、たとえば <code>SSLv3_method</code> は\nSSL バージョン 3 を強制します。可能な値はインストールされている OpenSSL\nと、その定数 [SSL_METHODS][] の定義に依存します。</p>\n</li>\n</ul>\n<!--\nThe `callback` parameter will be added as a listener for the\n['secureConnect'][] event.\n\n`tls.connect()` returns a [CleartextStream][] object.\n\nHere is an example of a client of echo server as described previously:\n-->\n\n<p><code>callback</code> 引数は ['secureConnect'][] イベントのリスナとして\n加えられます。\n\n</p>\n<p><code>tls.connect()</code> は [CleartextStream][] オブジェクトを返します。\n\n</p>\n<p>これは前述のエコーサーバに接続するクライアントの例です:\n\n</p>\n<pre><code>var tls = require('tls');\nvar fs = require('fs');\n\nvar options = {\n  // These are necessary only if using the client certificate authentication\n  key: fs.readFileSync('client-key.pem'),\n  cert: fs.readFileSync('client-cert.pem'),\n\n  // This is necessary only if the server uses the self-signed certificate\n  ca: [ fs.readFileSync('server-cert.pem') ]\n};\n\nvar cleartextStream = tls.connect(8000, options, function() {\n  console.log('client connected',\n              cleartextStream.authorized ? 'authorized' : 'unauthorized');\n  process.stdin.pipe(cleartextStream);\n  process.stdin.resume();\n});\ncleartextStream.setEncoding('utf8');\ncleartextStream.on('data', function(data) {\n  console.log(data);\n});\ncleartextStream.on('end', function() {\n  server.close();\n});</code></pre>\n<!--\nOr\n-->\n\n<p>または:\n\n</p>\n<pre><code>var tls = require('tls');\nvar fs = require('fs');\n\nvar options = {\n  pfx: fs.readFileSync('client.pfx')\n};\n\nvar cleartextStream = tls.connect(8000, options, function() {\n  console.log('client connected',\n              cleartextStream.authorized ? 'authorized' : 'unauthorized');\n  process.stdin.pipe(cleartextStream);\n  process.stdin.resume();\n});\ncleartextStream.setEncoding('utf8');\ncleartextStream.on('data', function(data) {\n  console.log(data);\n});\ncleartextStream.on('end', function() {\n  server.close();\n});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "port"
                },
                {
                  "name": "host",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "tls.connect(port, [host], [options], [callback])",
          "type": "method",
          "name": "connect",
          "desc": "<!--\nCreates a new client connection to the given `port` and `host` (old API) or\n`options.port` and `options.host`. (If `host` is omitted, it defaults to\n`localhost`.) `options` should be an object which specifies:\n-->\n\n<p>与えられた <code>port</code> と <code>host</code> (旧 API) または <code>options.port</code> と <code>options.host</code>\nで新しいクライアントコネクションを作成します\n(<code>host</code> が省略された場合、デフォルトは <code>localhost</code> です)。\n<code>options</code> は以下を指定したオブジェクトです:\n\n</p>\n<!--\n  - `host`: Host the client should connect to\n\n  - `port`: Port the client should connect to\n\n  - `socket`: Establish secure connection on a given socket rather than\n    creating a new socket. If this option is specified, `host` and `port`\n    are ignored.\n\n  - `pfx`: A string or `Buffer` containing the private key, certificate and\n    CA certs of the server in PFX or PKCS12 format.\n\n  - `key`: A string or `Buffer` containing the private key of the client in\n    PEM format.\n\n  - `passphrase`: A string of passphrase for the private key or pfx.\n\n  - `cert`: A string or `Buffer` containing the certificate key of the client in\n    PEM format.\n\n  - `ca`: An array of strings or `Buffer`s of trusted certificates in PEM\n    format. If this is omitted several well known \"root\" CAs will be used,\n    like VeriSign. These are used to authorize connections.\n\n  - `rejectUnauthorized`: If `true`, the server certificate is verified against\n    the list of supplied CAs. An `'error'` event is emitted if verification\n    fails. Default: `true`.\n\n  - `NPNProtocols`: An array of strings or `Buffer`s containing supported NPN\n    protocols. `Buffer`s should have following format: `0x05hello0x05world`,\n    where first byte is next protocol name's length. (Passing array should\n    usually be much simpler: `['hello', 'world']`.)\n\n  - `servername`: Servername for SNI (Server Name Indication) TLS extension.\n\n  - `secureProtocol`: The SSL method to use, e.g. `SSLv3_method` to force\n    SSL version 3. The possible values depend on your installation of\n    OpenSSL and are defined in the constant [SSL_METHODS][].\n-->\n\n<ul>\n<li><p><code>host</code>: クライアントが接続するホスト。</p>\n</li>\n<li><p><code>port</code>: クライアントが接続するポート番号。</p>\n</li>\n<li><p><code>socket</code>: 新しいソケットを生成するのではなく、与えられたソケット上で\nセキュアな接続を確立します。\nこのオプションが指定された場合、<code>host</code> および <code>port</code> は無視されます。</p>\n</li>\n<li><p><code>pfx</code> : PFX または PKCS12 でエンコードされた秘密鍵、証明書、\nおよびサーバに対する CA の証明書を含む文字列またはバッファ。</p>\n</li>\n<li><p><code>key</code>: PEM フォーマットによるサーバの秘密鍵を持つ文字列または\n<code>Buffer</code> です。</p>\n</li>\n<li><p><code>passphrase</code>: 秘密鍵または pfx のパスフレーズを表す文字列です。</p>\n</li>\n<li><p><code>cert</code>: PEM フォーマットによる証明書の鍵を持つ文字列または <code>Buffer</code> です。</p>\n</li>\n<li><p><code>ca</code>: PEMフォーマットによる信頼できる証明書の文字列または\n<code>Buffer</code> の配列です。\n省略された場合、ベリサインなどのよく知られた「ルート」認証局が使われます。\nこれらはコネクションの認証に使われます。</p>\n</li>\n<li><p><code>rejectUnauthorized</code>: <code>true</code> の場合、サーバ証明書は提供された認証局の\nリストによって検証されます。\n認証されなかった場合は <code>'error'</code> イベントが生成されます。\n認証は HTTP リクエストが送信される <em>前</em> にコネクションレベルで行われます。\nデフォルトは true です。</p>\n</li>\n<li><p><code>NPNProtocols</code>: サポートする NPN プロトコルの文字列または <code>Buffer</code> \nの配列です。\n<code>Buffer</code> は次のような形式です: <code>0x05hello0x5world</code>\n最初のバイトは次のプロトコル名の長さです\n(通常、配列を渡す方がシンプルです: <code>['hello', 'world']</code>)。</p>\n</li>\n<li><p><code>servername</code>: TLS 拡張である SNI (Server Name Indication) のサーバ名です。</p>\n</li>\n<li><p><code>secureProtocol</code>: 使用する SSL 方式、たとえば <code>SSLv3_method</code> は\nSSL バージョン 3 を強制します。可能な値はインストールされている OpenSSL\nと、その定数 [SSL_METHODS][] の定義に依存します。</p>\n</li>\n</ul>\n<!--\nThe `callback` parameter will be added as a listener for the\n['secureConnect'][] event.\n\n`tls.connect()` returns a [CleartextStream][] object.\n\nHere is an example of a client of echo server as described previously:\n-->\n\n<p><code>callback</code> 引数は ['secureConnect'][] イベントのリスナとして\n加えられます。\n\n</p>\n<p><code>tls.connect()</code> は [CleartextStream][] オブジェクトを返します。\n\n</p>\n<p>これは前述のエコーサーバに接続するクライアントの例です:\n\n</p>\n<pre><code>var tls = require('tls');\nvar fs = require('fs');\n\nvar options = {\n  // These are necessary only if using the client certificate authentication\n  key: fs.readFileSync('client-key.pem'),\n  cert: fs.readFileSync('client-cert.pem'),\n\n  // This is necessary only if the server uses the self-signed certificate\n  ca: [ fs.readFileSync('server-cert.pem') ]\n};\n\nvar cleartextStream = tls.connect(8000, options, function() {\n  console.log('client connected',\n              cleartextStream.authorized ? 'authorized' : 'unauthorized');\n  process.stdin.pipe(cleartextStream);\n  process.stdin.resume();\n});\ncleartextStream.setEncoding('utf8');\ncleartextStream.on('data', function(data) {\n  console.log(data);\n});\ncleartextStream.on('end', function() {\n  server.close();\n});</code></pre>\n<!--\nOr\n-->\n\n<p>または:\n\n</p>\n<pre><code>var tls = require('tls');\nvar fs = require('fs');\n\nvar options = {\n  pfx: fs.readFileSync('client.pfx')\n};\n\nvar cleartextStream = tls.connect(8000, options, function() {\n  console.log('client connected',\n              cleartextStream.authorized ? 'authorized' : 'unauthorized');\n  process.stdin.pipe(cleartextStream);\n  process.stdin.resume();\n});\ncleartextStream.setEncoding('utf8');\ncleartextStream.on('data', function(data) {\n  console.log(data);\n});\ncleartextStream.on('end', function() {\n  server.close();\n});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "port"
                },
                {
                  "name": "host",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])",
          "type": "method",
          "name": "createSecurePair",
          "desc": "<!--\nCreates a new secure pair object with two streams, one of which reads/writes\nencrypted data, and one reads/writes cleartext data.\nGenerally the encrypted one is piped to/from an incoming encrypted data stream,\nand the cleartext one is used as a replacement for the initial encrypted stream.\n - `credentials`: A credentials object from crypto.createCredentials( ... )\n\n - `isServer`: A boolean indicating whether this tls connection should be\n   opened as a server or a client.\n\n - `requestCert`: A boolean indicating whether a server should request a\n   certificate from a connecting client. Only applies to server connections.\n\n - `rejectUnauthorized`: A boolean indicating whether a server should\n   automatically reject clients with invalid certificates. Only applies to\n   servers with `requestCert` enabled.\n\n`tls.createSecurePair()` returns a SecurePair object with [cleartext][] and\n`encrypted` stream properties.\n-->\n\n<p>二つのストリームを持つセキュアペアオブジェクトを作成します。\n一つは暗号化されたデータを読み書きし、もう一つは平文のデータを読み書きします。\n通常、暗号化されたストリームに外部からの暗号化されたデータが連結され、\n暗号化されたストリームの代わりに平文のストリームが使われます。\n\n</p>\n<ul>\n<li><p><code>credentials</code>: <code>crypto.createCredentials( ... )</code> で作成された\n証明書オブジェクト。</p>\n</li>\n<li><p><code>isServer</code>: この TLS コネクションをサーバとしてオープンするかどうかを示す\nブーリアン値。</p>\n</li>\n<li><p><code>requestCert</code>: クライアントからの接続に対して、サーバがクライアントに\n証明書を要求するかどうかを示すブーリアン値。\nサーバコネクションにのみ適用されます。</p>\n</li>\n<li><p><code>rejectUnauthorized</code>: クライアント認証が不正だった場合に、\n自動的にクライアントを破棄するかどうかを示すブーリアン値。\n<code>requestCert</code> が有効なサーバにのみ適用されます。</p>\n</li>\n</ul>\n<p><code>tls.createSequrePair()</code> は、[cleartext][] と <code>encrypted</code>\nをプロパティとして持つ <code>SecurePair</code> オブジェクトを返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "credentials",
                  "optional": true
                },
                {
                  "name": "isServer",
                  "optional": true
                },
                {
                  "name": "requestCert",
                  "optional": true
                },
                {
                  "name": "rejectUnauthorized",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "tls.SLAB_BUFFER_SIZE",
          "name": "SLAB_BUFFER_SIZE",
          "desc": "<!--\nSize of slab buffer used by all tls servers and clients.\nDefault: `10 * 1024 * 1024`.\n-->\n\n<p>全ての TLS サーバ及びクライアントで使用されるスラブバッファのサイズ。\nデフォルトは: <code>10 * 1024 * 1024</code>。\n\n\n</p>\n<!--\nDon't change the defaults unless you know what you are doing.\n-->\n\n<p>あなたがしようとしていることを理解していない限り、\nデフォルトを変更しないでください。\n\n\n</p>\n"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: SecurePair",
          "type": "class",
          "name": "SecurePair",
          "desc": "<!--\nReturned by tls.createSecurePair.\n-->\n\n<p><code>tls.createSecurePair</code> から返されます。\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'secure'",
              "type": "event",
              "name": "secure",
              "desc": "<!--\nThe event is emitted from the SecurePair once the pair has successfully\nestablished a secure connection.\n\nSimilarly to the checking for the server 'secureConnection' event,\npair.cleartext.authorized should be checked to confirm whether the certificate\nused properly authorized.\n-->\n\n<p>SecurePair オブジェクトのペアが安全な接続を確立した場合に発生します。\n\n</p>\n<p>サーバの <code>'secureConnection'</code> イベントと同様に、\n<code>pari.cleartext.authorized</code> によって接続相手の証明書を承認できたかどうかを\nチェックすることができます。\n\n</p>\n",
              "params": []
            }
          ]
        },
        {
          "textRaw": "Class: tls.Server",
          "type": "class",
          "name": "tls.Server",
          "desc": "<!--\nThis class is a subclass of `net.Server` and has the same methods on it.\nInstead of accepting just raw TCP connections, this accepts encrypted\nconnections using TLS or SSL.\n-->\n\n<p>このクラスは <code>net.Server</code> のサブクラスで、同じメソッドを持っています。\n生の TCP コネクションを受け入れる代わりに、\nTLS または SSL を使った暗号化されたコネクションを受け付けます。\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'secureConnection'",
              "type": "event",
              "name": "secureConnection",
              "desc": "<p><code>function (cleartextStream) {}</code>\n\n</p>\n<!--\nThis event is emitted after a new connection has been successfully\nhandshaked. The argument is a instance of [CleartextStream][]. It has all the\ncommon stream methods and events.\n-->\n\n<p>このイベントは、新しい接続のハンドシェークが成功した場合に生成されます。\n引数は [CleartextStream][] のインスタンスです。\nこれはストリームに共通する全てのメソッドとイベントを持っています。\n\n</p>\n<!--\n`cleartextStream.authorized` is a boolean value which indicates if the\nclient has verified by one of the supplied certificate authorities for the\nserver. If `cleartextStream.authorized` is false, then\n`cleartextStream.authorizationError` is set to describe how authorization\nfailed. Implied but worth mentioning: depending on the settings of the TLS\nserver, you unauthorized connections may be accepted.\n`cleartextStream.npnProtocol` is a string containing selected NPN protocol.\n`cleartextStream.servername` is a string containing servername requested with\nSNI.\n-->\n\n<p><code>cleartextStream.authorized</code> は提供された認証局のいずれかによって\n認証されたかを示す boolean 値です。\n<code>cleartextStream.authorized</code> が false の場合、\n<code>cleartextStream.authorizationError</code> にはどのように認証が失敗したのかが設定されます。\n暗黙的ですが言及する価値のあること:\nTLS サーバの設定に依存しますが、認証されていないコネクションも受け入れられることがあります。\n<code>cleartextStream.npnProtocol</code> は、選択された NPN プロトコルを持つ文字列です。\n<code>cleartextStream.servername</code> は、SNI でリクエストされたサーバ名を持つ\n文字列です。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'clientError'",
              "type": "event",
              "name": "clientError",
              "desc": "<p><code>function (exception, securePair) { }</code>\n\n</p>\n<!--\nWhen a client connection emits an 'error' event before secure connection is\nestablished - it will be forwarded here.\n-->\n\n<p>セキュアコネクションが確立される前にクライアントコネクションが\n<code>'error'</code> イベントを発した場合 － ここに転送されます。\n\n</p>\n<!--\n`securePair` is the `tls.SecurePair` that the error originated from.\n-->\n\n<p><code>securePair</code> はエラーが発生した <code>tls.SecurePair</code> です。\n\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'newSession'",
              "type": "event",
              "name": "newSession",
              "desc": "<p><code>function (sessionId, sessionData) { }</code>\n\n</p>\n<!--\nEmitted on creation of TLS session. May be used to store sessions in external\nstorage.\n-->\n\n<p>TLS セッションが作成された場合に生成されます。\nセッションを外部ストレージに保存する場合に使えるでしょう。\n\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'resumeSession'",
              "type": "event",
              "name": "resumeSession",
              "desc": "<p><code>function (sessionId, callback) { }</code>\n\n</p>\n<!--\nEmitted when client wants to resume previous TLS session. Event listener may\nperform lookup in external storage using given `sessionId`, and invoke\n`callback(null, sessionData)` once finished. If session can't be resumed\n(i.e. doesn't exist in storage) one may call `callback(null, null)`. Calling\n`callback(err)` will terminate incoming connection and destroy socket.\n-->\n\n<p>クライアントが以前の TLS セッションを再開を要求した場合に生成されます。\nイベントリスナは与えられた <code>sessionId</code> を使用して外部ストレージから\nセッションを見つけた場合、<code>callback(null, sessionData)</code> を一度呼び出すことが\nできます。\nセッションを再開できない場合 (すなわち、ストレージに存在しない場合)、\n<code>callback(null, null)</code> を呼ぶことができます。\n<code>callback(err)</code> を呼び出すと接続を終了し、ソケットを破棄します。\n\n\n</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "server.listen(port, [host], [callback])",
              "type": "method",
              "name": "listen",
              "desc": "<!--\nBegin accepting connections on the specified `port` and `host`.  If the\n`host` is omitted, the server will accept connections directed to any\nIPv4 address (`INADDR_ANY`).\n-->\n\n<p>指定の <code>port</code> と <code>host</code> で接続の受け入れを開始します。\n<code>host</code> が省略されると、サーバはどんな IPv4 アドレスからのコネクションも受け入れます (<code>INADDR_ANY</code>)。\n\n</p>\n<!--\nThis function is asynchronous. The last parameter `callback` will be called\nwhen the server has been bound.\n-->\n\n<p>この関数は非同期です。\n最後の引数 <code>callback</code> はサーバがバインドされると呼び出されます。\n\n</p>\n<!--\nSee `net.Server` for more information.\n-->\n\n<p>より詳細は <code>net.Server</code> を参照してください。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "host",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.close()",
              "type": "method",
              "name": "close",
              "desc": "<!--\nStops the server from accepting new connections. This function is\nasynchronous, the server is finally closed when the server emits a `'close'`\nevent.\n-->\n\n<p>サーバが新しい接続を受け入れることを終了します。\nこの関数は非同期で、サーバが最終的にクローズされるとサーバは <code>'close'</code> イベントを生成します。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "server.address()",
              "type": "method",
              "name": "address",
              "desc": "<!--\nReturns the bound address, the address family name and port of the\nserver as reported by the operating system.  See [net.Server.address()][] for\nmore information.\n-->\n\n<p>オペレーティングシステムから報告された、サーバにバインドされたアドレスと\nアドレスファミリ名、ポートを返します。 \nより詳しくは [net.Server.address()][] を参照してください。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "server.addContext(hostname, credentials)",
              "type": "method",
              "name": "addContext",
              "desc": "<!--\nAdd secure context that will be used if client request's SNI hostname is\nmatching passed `hostname` (wildcards can be used). `credentials` can contain\n`key`, `cert` and `ca`.\n-->\n\n<p>クライアントが要求してきた SNI ホスト名と <code>hostname</code> (ワイルドカードを使用可能)\nがマッチした場合のセキュリティコンテキストを追加します。\n<code>credentials</code> は <code>key</code>、<code>cert</code>、そして <code>ca</code> を含むことができます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "hostname"
                    },
                    {
                      "name": "credentials"
                    }
                  ]
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "server.maxConnections",
              "name": "maxConnections",
              "desc": "<!--\nSet this property to reject connections when the server's connection count\ngets high.\n-->\n\n<p>このプロパティを設定すると、サーバの接続数がこれを越えた場合に接続を破棄します。\n</p>\n"
            },
            {
              "textRaw": "server.connections",
              "name": "connections",
              "desc": "<!--\nThe number of concurrent connections on the server.\n-->\n\n<p>サーバの並行コネクションの数です。\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: CryptoStream",
          "type": "class",
          "name": "CryptoStream",
          "desc": "<!--\nThis is an encrypted stream.\n-->\n\n<p>これは暗号化されたストリームです。\n\n</p>\n",
          "properties": [
            {
              "textRaw": "cryptoStream.bytesWritten",
              "name": "bytesWritten",
              "desc": "<!--\nA proxy to the underlying socket's bytesWritten accessor, this will return\nthe total bytes written to the socket, *including the TLS overhead*.\n-->\n\n<p>下層にあるソケットの bytesWritten にアクセスするプロキシで、\n<em>TLS のオーバーヘッドを含めて</em> ソケットに書き込まれたトータルのバイト数を\n返します。\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: tls.CleartextStream",
          "type": "class",
          "name": "tls.CleartextStream",
          "desc": "<!--\nThis is a stream on top of the *Encrypted* stream that makes it possible to\nread/write an encrypted data as a cleartext data.\n\nThis instance implements a duplex [Stream][] interfaces.  It has all the\ncommon stream methods and events.\n-->\n\n<p>暗号化されたストリーム上で、暗号化されたデータを平文のデータとして\n読み書きすることができるストリームです。\n\n</p>\n<p>このインスタンスは双方向の [Stream][] インタフェースを実装します。\nストリームに共通な全てのメソッドとイベントを持ちます。\n\n</p>\n<p>A ClearTextStream is the <code>clear</code> member of a SecurePair object.\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'secureConnect'",
              "type": "event",
              "name": "secureConnect",
              "desc": "<!--\nThis event is emitted after a new connection has been successfully handshaked. \nThe listener will be called no matter if the server's certificate was\nauthorized or not. It is up to the user to test `cleartextStream.authorized`\nto see if the server certificate was signed by one of the specified CAs.\nIf `cleartextStream.authorized === false` then the error can be found in\n`cleartextStream.authorizationError`. Also if NPN was used - you can check\n`cleartextStream.npnProtocol` for negotiated protocol.\n-->\n\n<p>新しいコネクションの TLS/SSL ハンドシェークが成功すると生成されます。\nリスナはサーバの証明書が認証されたかどうかに関わらず呼び出されます。\nサーバ証明書が指定した認証局に承認されたかチェックするために\n<code>cleartextStream.authorized</code> を確認するかはユーザ次第です。\n<code>cleartextStream.authorized === false</code>の場合、\n<code>cleartextStream.authorizationError</code> からエラーを見つけることができます。\n同様に NPN が使われている場合は <code>cleartextStream.npnProtocol</code>\nから合意されたプロトコルをチェックすることが出来ます。\n\n</p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "cleartextStream.authorized",
              "name": "authorized",
              "desc": "<!--\nA boolean that is `true` if the peer certificate was signed by one of the\nspecified CAs, otherwise `false`\n-->\n\n<p>接続相手の証明書が CA の一つによって署名されていれば <code>true</code>、\nそうでなければ <code>false</code> です。\n\n</p>\n"
            },
            {
              "textRaw": "cleartextStream.authorizationError",
              "name": "authorizationError",
              "The reason why the peer's certificate has not been verified. This property\nbecomes available only when `cleartextStream.authorized": "== false`.",
              "desc": "<p>接続相手の証明書が認証されなかった理由です。\nこのプロパティは <code>cleartextStream.authorized === false</code>\nの場合だけ利用可能になります。\n\n</p>\n"
            },
            {
              "textRaw": "cleartextStream.remoteAddress",
              "name": "remoteAddress",
              "desc": "<!--\nThe string representation of the remote IP address. For example,\n`'74.125.127.100'` or `'2001:4860:a005::68'`.\n-->\n\n<p>リモートの IP アドレスを表現する文字列です。\n例えば、<code>'74.125.127.100'</code> あるいは <code>'2001:4860:a005::68'</code>。\n\n</p>\n"
            },
            {
              "textRaw": "cleartextStream.remotePort",
              "name": "remotePort",
              "desc": "<!--\nThe numeric representation of the remote port. For example, `443`.\n-->\n\n<p>リモートポートの数値表現です。\n例えば、<code>443</code>。\n\n</p>\n<!--\n[OpenSSL cipher list format documentation]: http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT\n[BEAST attacks]: http://blog.ivanristic.com/2011/10/mitigating-the-beast-attack-on-tls.html\n[CleartextStream]: #tls_class_tls_cleartextstream\n[net.Server.address()]: net.html#net_server_address\n['secureConnect']: #tls_event_secureconnect\n[secureConnection]: #tls_event_secureconnection\n[Stream]: stream.html#stream_stream\n[SSL_METHODS]: http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS\n[tls.Server]: #tls_class_tls_server\n-->\n\n"
            }
          ],
          "methods": [
            {
              "textRaw": "cleartextStream.getPeerCertificate()",
              "type": "method",
              "name": "getPeerCertificate",
              "desc": "<!--\nReturns an object representing the peer's certificate. The returned object has\nsome properties corresponding to the field of the certificate.\n-->\n\n<p>接続相手の証明書を表現するオブジェクトを返します。\n返されるオブジェクトは証明書のフィールドに対応するプロパティを持ちます。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>{ subject: \n   { C: 'UK',\n     ST: 'Acknack Ltd',\n     L: 'Rhys Jones',\n     O: 'node.js',\n     OU: 'Test TLS Certificate',\n     CN: 'localhost' },\n  issuer: \n   { C: 'UK',\n     ST: 'Acknack Ltd',\n     L: 'Rhys Jones',\n     O: 'node.js',\n     OU: 'Test TLS Certificate',\n     CN: 'localhost' },\n  valid_from: 'Nov 11 09:52:22 2009 GMT',\n  valid_to: 'Nov  6 09:52:22 2029 GMT',\n  fingerprint: '2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF' }</code></pre>\n<!--\nIf the peer does not provide a certificate, it returns `null` or an empty\nobject.\n-->\n\n<p>接続相手が証明書を提供しなかった場合は、\n<code>null</code> または空のオブジェクトを返します。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "cleartextStream.getCipher()",
              "type": "method",
              "name": "getCipher",
              "desc": "<!--\nReturns an object representing the cipher name and the SSL/TLS\nprotocol version of the current connection.\n-->\n\n<p>現在の接続における暗号と SSL/TLS プロトコルのバージョンを表現する\nオブジェクトを返します。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>{ name: 'AES256-SHA', version: 'TLSv1/SSLv3' }</code></pre>\n<!--\nSee SSL_CIPHER_get_name() and SSL_CIPHER_get_version() in\nhttp://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_CIPHERS for more\ninformation.\n-->\n\n<p>詳細は\n<a href="\"http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_CIPHERS\"">http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_CIPHERS</a>\nで <code>SSL_CIPHER_get_name()</code> および <code>SSL_CIPHER_get_version()</code> を\n参照してください。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "cleartextStream.address()",
              "type": "method",
              "name": "address",
              "desc": "<!--\nReturns the bound address, the address family name and port of the\nunderlying socket as reported by the operating system. Returns an\nobject with three properties, e.g.\n`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`\n-->\n\n<p>オペレーティングシステムから報告された、ソケットにバインドされたアドレスと\nアドレスファミリ名、ポートを返します。\n返されるオブジェクトは二つのプロパティを持ちます。例:\n<code>{ port: 12346, family: 'IPv4', address: '127.0.0.1' }</code>\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "TLS (SSL)"
    },
    {
      "textRaw": "StringDecoder",
      "name": "stringdecoder",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<!--\nTo use this module, do `require('string_decoder')`. StringDecoder decodes a\nbuffer to a string. It is a simple interface to `buffer.toString()` but provides\nadditional support for utf8.\n-->\n\n<p>このモジュールを使用するには <code>require('string_decoder')</code> をします。\nStringDecoder はバッファから文字列にデコードします。\nこれは単純なインターフェース <code>buffer.toString()</code> ですが、\nUTF-8 を特別にサポートします。\n\n</p>\n<pre><code>var StringDecoder = require('string_decoder').StringDecoder;\nvar decoder = new StringDecoder('utf8');\n\nvar cent = new Buffer([0xC2, 0xA2]);\nconsole.log(decoder.write(cent));\n\nvar euro = new Buffer([0xE2, 0x82, 0xAC]);\nconsole.log(decoder.write(euro));</code></pre>\n",
      "classes": [
        {
          "textRaw": "Class: StringDecoder",
          "type": "class",
          "name": "StringDecoder",
          "desc": "<!--\nAccepts a single argument, `encoding` which defaults to `utf8`.\n-->\n\n<p>文字列の引数 <code>encoding</code> を受け取ります。デフォルトは <code>'utf8'</code> です。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "decoder.write(buffer)",
              "type": "method",
              "name": "write",
              "desc": "<!--\nReturns a decoded string.\n-->\n\n<p>デコードされた文字列を返します。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decoder.end()",
              "type": "method",
              "name": "end",
              "desc": "<!--\nReturns any trailing bytes that were left in the buffer.\n-->\n\n<p>バッファに残った終端のバイト列を返します。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "StringDecoder"
    },
    {
      "textRaw": "File System",
      "name": "fs",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<!--\nFile I/O is provided by simple wrappers around standard POSIX functions.  To\nuse this module do `require('fs')`. All the methods have asynchronous and\nsynchronous forms.\n-->\n\n<p>File I/O は POSIX 標準の関数に対する単純なラッパーとして提供されます。\nこのモジュールを使用するには <code>require('fs')</code> してください。\n全てのメソッドは非同期と同期の形式があります。\n\n</p>\n<!--\nThe asynchronous form always take a completion callback as its last argument.\nThe arguments passed to the completion callback depend on the method, but the\nfirst argument is always reserved for an exception. If the operation was\ncompleted successfully, then the first argument will be `null` or `undefined`.\n\nWhen using the synchronous form any exceptions are immediately thrown.\nYou can use try/catch to handle exceptions or allow them to bubble up.\n-->\n\n<p>非同期の形式は常に最後の引数として完了コールバックを受け取ります。\n引数として渡される完了コールバックはメソッドに依存しますが、\n最初の引数は常に例外のために予約されています。\n操作が成功で完了すると最初の引数は <code>null</code> または <code>undefined</code> となります\n\n</p>\n<p>同期の形式では、全ての例外はすぐにスローされます。\n例外は try/catch で捕まえることも、そのまま通過させることもできます。\n\n</p>\n<!--\nHere is an example of the asynchronous version:\n-->\n\n<p>非同期バージョンの例です:\n\n</p>\n<pre><code>var fs = require('fs');\n\nfs.unlink('/tmp/hello', function (err) {\n  if (err) throw err;\n  console.log('successfully deleted /tmp/hello');\n});</code></pre>\n<!--\nHere is the synchronous version:\n-->\n\n<p>同期バージョンです:\n\n</p>\n<pre><code>var fs = require('fs');\n\nfs.unlinkSync('/tmp/hello')\nconsole.log('successfully deleted /tmp/hello');</code></pre>\n<!--\nWith the asynchronous methods there is no guaranteed ordering. So the\nfollowing is prone to error:\n-->\n\n<p>非同期メソッドでは順序の保証はありません。\n以下のような傾向のエラーがあります。\n\n</p>\n<pre><code>fs.rename('/tmp/hello', '/tmp/world', function (err) {\n  if (err) throw err;\n  console.log('renamed complete');\n});\nfs.stat('/tmp/world', function (err, stats) {\n  if (err) throw err;\n  console.log('stats: ' + JSON.stringify(stats));\n});</code></pre>\n<!--\nIt could be that `fs.stat` is executed before `fs.rename`.\nThe correct way to do this is to chain the callbacks.\n-->\n\n<p><code>fs.stat</code> は <code>fs.rename</code> より先に実行される可能性がありrます。\n正しい方法はコールバックをチェーンすることです。\n\n</p>\n<pre><code>fs.rename('/tmp/hello', '/tmp/world', function (err) {\n  if (err) throw err;\n  fs.stat('/tmp/world', function (err, stats) {\n    if (err) throw err;\n    console.log('stats: ' + JSON.stringify(stats));\n  });\n});</code></pre>\n<!--\nIn busy processes, the programmer is _strongly encouraged_ to use the\nasynchronous versions of these calls. The synchronous versions will block\nthe entire process until they complete--halting all connections.\n\nRelative path to filename can be used, remember however that this path will be\nrelative to `process.cwd()`.\n-->\n\n<p>忙しいプロセスでは、プログラマはこれらの非同期バージョンを使うことが<em>強く推奨</em>されます。\n同期バージョンはそれが完了するまでプロセス全体をブロックします － 全ての接続を停止します。\n\n</p>\n<p>ファイル名には相対パスを使うことが出来ます。しかし、このパスは\n<code>process.cwd()</code> からの相対パスであることを思い出してください。\n\n</p>\n<!--\nMost fs functions let you omit the callback argument. If you do, a default\ncallback is used that ignores errors, but prints a deprecation\nwarning.\n-->\n\n<p>fs モジュールのほとんどの関数はコールバック引数を省略することができます。\nそうすると、エラーを無視するコールバックがデフォルトとして使用され、\n廃止予定の警告が出力されます。\n\n</p>\n<!--\n**IMPORTANT**: Omitting the callback is deprecated.  v0.12 will throw the\nerrors as exceptions.\n-->\n\n<p><strong>重要</strong>: コールバックの省略は廃止予定です。v0.12 は例外をスローするでしょう。\n\n\n</p>\n",
      "methods": [
        {
          "textRaw": "fs.rename(oldPath, newPath, callback)",
          "type": "method",
          "name": "rename",
          "desc": "<!--\nAsynchronous rename(2). No arguments other than a possible exception are given\nto the completion callback.\n-->\n\n<p>非同期の rename(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "oldPath"
                },
                {
                  "name": "newPath"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.renameSync(oldPath, newPath)",
          "type": "method",
          "name": "renameSync",
          "desc": "<!--\nSynchronous rename(2).\n-->\n\n<p>同期の rename(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "oldPath"
                },
                {
                  "name": "newPath"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.ftruncate(fd, len, callback)",
          "type": "method",
          "name": "ftruncate",
          "desc": "<!--\nAsynchronous ftruncate(2). No arguments other than a possible exception are\ngiven to the completion callback.\n-->\n\n<p>非同期の ftruncate(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "len"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.ftruncateSync(fd, len)",
          "type": "method",
          "name": "ftruncateSync",
          "desc": "<!--\nSynchronous ftruncate(2).\n-->\n\n<p>同期の ftruncate(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "len"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.truncate(path, len, callback)",
          "type": "method",
          "name": "truncate",
          "desc": "<!--\nAsynchronous truncate(2). No arguments other than a possible exception are\ngiven to the completion callback.\n-->\n\n<p>非同期の truncate(2)。\n完了コールバックには発生し得る例外以外に引数が渡されることはありません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "len"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.truncateSync(path, len)",
          "type": "method",
          "name": "truncateSync",
          "desc": "<!--\nSynchronous truncate(2).\n-->\n\n<p>同期の truncate(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "len"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.chown(path, uid, gid, callback)",
          "type": "method",
          "name": "chown",
          "desc": "<!--\nAsynchronous chown(2). No arguments other than a possible exception are given\nto the completion callback.\n-->\n\n<p>非同期の chown(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "uid"
                },
                {
                  "name": "gid"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.chownSync(path, uid, gid)",
          "type": "method",
          "name": "chownSync",
          "desc": "<!--\nSynchronous chown(2).\n-->\n\n<p>同期の chown(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "uid"
                },
                {
                  "name": "gid"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fchown(fd, uid, gid, callback)",
          "type": "method",
          "name": "fchown",
          "desc": "<!--\nAsynchronous fchown(2). No arguments other than a possible exception are given\nto the completion callback.\n-->\n\n<p>非同期の fchown(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "uid"
                },
                {
                  "name": "gid"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fchownSync(fd, uid, gid)",
          "type": "method",
          "name": "fchownSync",
          "desc": "<!--\nSynchronous fchown(2).\n-->\n\n<p>同期の fchown(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "uid"
                },
                {
                  "name": "gid"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.lchown(path, uid, gid, callback)",
          "type": "method",
          "name": "lchown",
          "desc": "<!--\nAsynchronous lchown(2). No arguments other than a possible exception are given\nto the completion callback.\n-->\n\n<p>非同期の lchown(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "uid"
                },
                {
                  "name": "gid"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.lchownSync(path, uid, gid)",
          "type": "method",
          "name": "lchownSync",
          "desc": "<!--\nSynchronous lchown(2).\n-->\n\n<p>同期の lchown(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "uid"
                },
                {
                  "name": "gid"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.chmod(path, mode, callback)",
          "type": "method",
          "name": "chmod",
          "desc": "<!--\nAsynchronous chmod(2). No arguments other than a possible exception are given\nto the completion callback.\n-->\n\n<p>非同期の chmod(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.chmodSync(path, mode)",
          "type": "method",
          "name": "chmodSync",
          "desc": "<!--\nSynchronous chmod(2).\n-->\n\n<p>同期の chmod(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fchmod(fd, mode, callback)",
          "type": "method",
          "name": "fchmod",
          "desc": "<!--\nAsynchronous fchmod(2). No arguments other than a possible exception\nare given to the completion callback.\n-->\n\n<p>非同期の fchmod(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "mode"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fchmodSync(fd, mode)",
          "type": "method",
          "name": "fchmodSync",
          "desc": "<!--\nSynchronous fchmod(2).\n-->\n\n<p>同期の fchmod(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "mode"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.lchmod(path, mode, callback)",
          "type": "method",
          "name": "lchmod",
          "desc": "<!--\nAsynchronous lchmod(2). No arguments other than a possible exception\nare given to the completion callback.\n-->\n\n<p>非同期の lchmod(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。\n\n</p>\n<!--\nOnly available on Mac OS X.\n-->\n\n<p>Mac OS X でのみ利用可能です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.lchmodSync(path, mode)",
          "type": "method",
          "name": "lchmodSync",
          "desc": "<!--\nSynchronous lchmod(2).\n-->\n\n<p>同期の lchmod(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.stat(path, callback)",
          "type": "method",
          "name": "stat",
          "desc": "<!--\nAsynchronous stat(2). The callback gets two arguments `(err, stats)` where\n`stats` is a [fs.Stats](#fs_class_fs_stats) object.  See the [fs.Stats](#fs_class_fs_stats)\nsection below for more information.\n-->\n\n<p>非同期の stat(2)。コールバックは 2 つの引数を受け取る <code>(err, stats)</code>で、\n<code>stats</code> は <a href="\"#fs_class_fs_stats\"">fs.Stats</a> オブジェクトです。\n詳細は <a href="\"#fs_class_fs_stats\"">fs.Stats</a> の節を参照してください。\n\n</p>\n<!--\nSee the [fs.Stats](#fs.Stats) section below for more information.\n-->\n\n<p>より詳しくは後述の <a href="\"#fs.Stats\"">fs.Stats</a> の節を参照してください。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.lstat(path, callback)",
          "type": "method",
          "name": "lstat",
          "desc": "<!--\nAsynchronous lstat(2). The callback gets two arguments `(err, stats)` where\n`stats` is a `fs.Stats` object. `lstat()` is identical to `stat()`, except that if\n`path` is a symbolic link, then the link itself is stat-ed, not the file that it\nrefers to.\n-->\n\n<p>非同期の lstat(2)。コールバックは 2 つの引数を受け取る <code>(err, stats)</code>で、\n<code>stats</code> は <code>fs.Stats</code> オブジェクトです。\n<code>lstat()</code> はパスがシンボリックリンクだった場合に、\n参照先のファイルではなくそのリンク自身が調べられる点を除いて <code>stat()</code> と同じす。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fstat(fd, callback)",
          "type": "method",
          "name": "fstat",
          "desc": "<!--\nAsynchronous fstat(2). The callback gets two arguments `(err, stats)` where\n`stats` is a `fs.Stats` object. `fstat()` is identical to `stat()`, except that\nthe file to be stat-ed is specified by the file descriptor `fd`.\n-->\n\n<p>非同期の fstat(2)。コールバックは 2 つの引数を受け取る <code>(err, stats)</code> で、\n<code>stats</code> は <code>fs.Stats</code> オブジェクトです。\n状態を取得するファイルをファイル記述子 <code>fd</code> で指定することを除いて、\n<code>fstat()</code> は <code>stat()</code> と同じです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.statSync(path)",
          "type": "method",
          "name": "statSync",
          "desc": "<!--\nSynchronous stat(2). Returns an instance of `fs.Stats`.\n-->\n\n<p>同期の stat(2)。<code>fs.Stats</code> のインスタンスを返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.lstatSync(path)",
          "type": "method",
          "name": "lstatSync",
          "desc": "<!--\nSynchronous lstat(2). Returns an instance of `fs.Stats`.\n-->\n\n<p>同期の lstat(2)。<code>fs.Stats</code> のインスタンスを返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fstatSync(fd)",
          "type": "method",
          "name": "fstatSync",
          "desc": "<!--\nSynchronous fstat(2). Returns an instance of `fs.Stats`.\n-->\n\n<p>同期の fstat(2)。<code>fs.Stats</code> のインスタンスを返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.link(srcpath, dstpath, callback)",
          "type": "method",
          "name": "link",
          "desc": "<!--\nAsynchronous link(2). No arguments other than a possible exception are given to\nthe completion callback.\n-->\n\n<p>非同期の link(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "srcpath"
                },
                {
                  "name": "dstpath"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.linkSync(srcpath, dstpath)",
          "type": "method",
          "name": "linkSync",
          "desc": "<!--\nSynchronous link(2).\n-->\n\n<p>同期の link(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "srcpath"
                },
                {
                  "name": "dstpath"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.symlink(srcpath, dstpath, [type], callback)",
          "type": "method",
          "name": "symlink",
          "desc": "<!--\nAsynchronous symlink(2). No arguments other than a possible exception are given\nto the completion callback.\nThe `type` argument can be set to `'dir'`, `'file'`, or `'junction'` (default\nis `'file'`) and is only available on Windows (ignored on other platforms).\nNote that Windows junction points require the destination path to be absolute.  When using\n`'junction'`, the `destination` argument will automatically be normalized to absolute path.\n-->\n\n<p>非同期の symlink(2)。\n完了コールバックには発生し得る例外以外に引数が渡されることはありません。\n<code>type</code> 引数は <code>'dir'</code>、<code>'file'</code>、または <code>'junction</code>' (デフォルトは <code>'file'</code>)\nに設定することができ、Windows でのみ利用可能です\n(他のプラットフォームでは無視されます)。\nWindows のジャンクションポイントは対象に絶対パスを要求することに\n注意してください。\n<code>'junction'</code> を使うと、<code>destination</code> 引数は自動的に絶対パスに正規化されます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "srcpath"
                },
                {
                  "name": "dstpath"
                },
                {
                  "name": "type",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.symlinkSync(srcpath, dstpath, [type])",
          "type": "method",
          "name": "symlinkSync",
          "desc": "<!--\nSynchronous symlink(2).\n-->\n\n<p>同期の symlink(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "srcpath"
                },
                {
                  "name": "dstpath"
                },
                {
                  "name": "type",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readlink(path, callback)",
          "type": "method",
          "name": "readlink",
          "desc": "<!--\nAsynchronous readlink(2). The callback gets two arguments `(err,\nlinkString)`.\n-->\n\n<p>非同期の readlink(2)。コールバックは 2 つの引数を受け取る <code>(err, linkString)</code>です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readlinkSync(path)",
          "type": "method",
          "name": "readlinkSync",
          "desc": "<!--\nSynchronous readlink(2). Returns the symbolic link's string value.\n-->\n\n<p>同期の readlink(2)。シンボリックリンクの持つ文字列値を返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.realpath(path, [cache], callback)",
          "type": "method",
          "name": "realpath",
          "desc": "<!--\nAsynchronous realpath(2). The `callback` gets two arguments `(err,\nresolvedPath)`. May use `process.cwd` to resolve relative paths. `cache` is an\nobject literal of mapped paths that can be used to force a specific path\nresolution or avoid additional `fs.stat` calls for known real paths.\n-->\n\n<p>非同期の realpath(2)。コールバックは 2 つの引数を受け取る <code>(err, resolvedPath)</code>です。\n相対パスを解決するために <code>process.cwd</code> を使用することができます。\n<code>cache</code> はオブジェクトで、パスがキーとして含まれていればその値が\n強制的に解決されたパスとして扱われ、<code>fs.stat</code> によってパスが実在するかどうかの\n確認が省かれます。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var cache = {'/etc':'/private/etc'};\nfs.realpath('/etc/passwd', cache, function (err, resolvedPath) {\n  if (err) throw err;\n  console.log(resolvedPath);\n});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "cache",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.realpathSync(path, [cache])",
          "type": "method",
          "name": "realpathSync",
          "desc": "<!--\nSynchronous realpath(2). Returns the resolved path.\n-->\n\n<p>同期の realpath(2)。解決されたパスを返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "cache",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.unlink(path, callback)",
          "type": "method",
          "name": "unlink",
          "desc": "<!--\nAsynchronous unlink(2). No arguments other than a possible exception are given\nto the completion callback.\n-->\n\n<p>非同期の unlink(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.unlinkSync(path)",
          "type": "method",
          "name": "unlinkSync",
          "desc": "<!--\nSynchronous unlink(2).\n-->\n\n<p>同期の unlink(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.rmdir(path, callback)",
          "type": "method",
          "name": "rmdir",
          "desc": "<!--\nAsynchronous rmdir(2). No arguments other than a possible exception are given\nto the completion callback.\n-->\n\n<p>非同期の rmdir(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.rmdirSync(path)",
          "type": "method",
          "name": "rmdirSync",
          "desc": "<!--\nSynchronous rmdir(2).\n-->\n\n<p>同期の rmdir(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.mkdir(path, [mode], callback)",
          "type": "method",
          "name": "mkdir",
          "desc": "<!--\nAsynchronous mkdir(2). No arguments other than a possible exception are given\nto the completion callback. `mode` defaults to `0777`.\n-->\n\n<p>非同期の mkdir(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。\n<code>mode</code> のデフォルトは <code>0777</code> です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.mkdirSync(path, [mode])",
          "type": "method",
          "name": "mkdirSync",
          "desc": "<!--\nSynchronous mkdir(2).\n-->\n\n<p>同期の mkdir(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "mode",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readdir(path, callback)",
          "type": "method",
          "name": "readdir",
          "desc": "<!--\nAsynchronous readdir(3).  Reads the contents of a directory.\nThe callback gets two arguments `(err, files)` where `files` is an array of\nthe names of the files in the directory excluding `'.'` and `'..'`.\n-->\n\n<p>非同期の readdir(3)。ディレクトリの内容を読み込みます。\nコールバックは 2 つの引数を受け取る <code>(err, files)</code>で、\n<code>files</code> は <code>'.'</code> と <code>'..'</code> を除くディレクトリ内のファイル名の配列です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readdirSync(path)",
          "type": "method",
          "name": "readdirSync",
          "desc": "<!--\nSynchronous readdir(3). Returns an array of filenames excluding `'.'` and\n`'..'`.\n-->\n\n<p>同期の readdir(3)。<code>'.'</code> と <code>'..'</code> を除くディレクトリ内のファイル名の配列を返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.close(fd, callback)",
          "type": "method",
          "name": "close",
          "desc": "<!--\nAsynchronous close(2).  No arguments other than a possible exception are given\nto the completion callback.\n-->\n\n<p>非同期の close(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.closeSync(fd)",
          "type": "method",
          "name": "closeSync",
          "desc": "<!--\nSynchronous close(2).\n-->\n\n<p>同期の close(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.open(path, flags, [mode], callback)",
          "type": "method",
          "name": "open",
          "desc": "<!--\nAsynchronous file open. See open(2). `flags` can be:\n-->\n\n<p>非同期のファイルオープン。open(2) を参照してください。\nフラグは以下になります:\n\n</p>\n<!--\n* `'r'` - Open file for reading.\nAn exception occurs if the file does not exist.\n-->\n\n<ul>\n<li><code>'r'</code> - ファイルを読み込み専用でオープンします。\nファイルが存在しない場合は例外が発生します。</li>\n</ul>\n<!--\n* `'r+'` - Open file for reading and writing.\nAn exception occurs if the file does not exist.\n-->\n\n<ul>\n<li><code>'r+'</code> - ファイルを読み書き両用でオープンします。\nファイルが存在しない場合は例外が発生します。</li>\n</ul>\n<!--\n* `'rs'` - Open file for reading in synchronous mode. Instructs the operating\n  system to bypass the local file system cache.\n\n  This is primarily useful for opening files on NFS mounts as it allows you to\n  skip the potentially stale local cache. It has a very real impact on I/O\n  performance so don't use this flag unless you need it.\n\n  Note that this doesn't turn `fs.open()` into a synchronous blocking call.\n  If that's what you want then you should be using `fs.openSync()`\n-->\n\n<ul>\n<li><p><code>'rs'</code> - ファイルを同期モードで読み込むためにオープンします。\nオペレーティングシステムにローカルファイルシステムのキャッシュを\nバイパスするように指示します。</p>\n<p>これは主に NFS にマウントされたファイルをオープンして、潜在的に古い\nローカルキャッシュをスキップするのに役立ちます。\nこれはI/O パフォーマンスにとても深刻な影響を与えるため、必要でない限りは\nこのフラグを使用しないでください。</p>\n<p>これは <code>fs.open()</code> を同期的なブロッキング呼び出しにするわけではないことに\n注意してください。\nそれが必要な場合は <code>fs.openSync()</code> を使用すべきです。</p>\n</li>\n</ul>\n<!--\n* `'rs+'` - Open file for reading and writing, telling the OS to open it\n  synchronously. See notes for `'rs'` about using this with caution.\n-->\n\n<ul>\n<li><code>'rs+'</code> - ファイルを読み書き両方でオープンし、OS に同期的にオープンするように\n伝えます。これを使用する際の警告は <code>'rs'</code> の注意を参照してください。</li>\n</ul>\n<!--\n* `'w'` - Open file for writing.\nThe file is created (if it does not exist) or truncated (if it exists).\n-->\n\n<ul>\n<li><code>'w'</code> - ファイルを書き込み専用でオープンします。\nファイルは作成されるか (存在しない場合)、または長さ 0 に切り詰められます\n(存在する場合)。</li>\n</ul>\n<!--\n* `'wx'` - Like `'w'` but fails if `path` exists.\n-->\n\n<ul>\n<li><code>'wx'</code> - <code>'w'</code> と似ていますが、<code>path</code> が存在すると失敗します。</li>\n</ul>\n<!--\n* `'w+'` - Open file for reading and writing.\nThe file is created (if it does not exist) or truncated (if it exists).\n-->\n\n<ul>\n<li><code>'w+'</code> - ファイルを読み書き両用でオープンします。\nファイルは作成されるか (存在しない場合)、または長さ 0 に切り詰められます\n(存在する場合)。</li>\n</ul>\n<!--\n* `'wx+'` - Like `'w+'` but fails if `path` exists.\n-->\n\n<ul>\n<li><code>'wx+'</code> - <code>'w+'</code> と似ていますが、<code>path</code> が存在すると失敗します。</li>\n</ul>\n<!--\n* `'a'` - Open file for appending.\nThe file is created if it does not exist.\n-->\n\n<ul>\n<li><code>'a'</code> - ファイルを追記用でオープンします。\nファイルが存在しない場合は作成されます。</li>\n</ul>\n<!--\n* `'ax'` - Like `'a'` but fails if `path` exists.\n-->\n\n<ul>\n<li><code>'ax'</code> - <code>'a'</code> と似ていますが、<code>path</code> が存在すると失敗します。</li>\n</ul>\n<!--\n* `'a+'` - Open file for reading and appending.\nThe file is created if it does not exist.\n-->\n\n<ul>\n<li><code>'a+'</code> - ファイルを読み込みおよび追記用でオープンします。\nファイルが存在しない場合は作成されます。</li>\n</ul>\n<!--\n* `'ax+'` - Like `'a+'` but fails if `path` exists.\n-->\n\n<ul>\n<li><code>'ax+'</code> - <code>'a+'</code> と似ていますが、<code>path</code> が存在すると失敗します。</li>\n</ul>\n<!--\n`mode` sets the file mode (permission and sticky bits), but only if the file was\ncreated. It defaults to `0666`, readable and writeable.\n-->\n\n<p><code>mode</code> はファイルモード (許可とスティッキービット) を設定しますが、\nそれはファイルが作成される場合に限られます。\nデフォルトは 0666 です。\n\n</p>\n<!--\nThe callback gets two arguments `(err, fd)`.\n-->\n\n<p>コールバックは 2 つの引数を受け取る <code>(err, fd)</code>です。\n\n</p>\n<!--\nThe exclusive flag `'x'` (`O_EXCL` flag in open(2)) ensures that `path` is newly\ncreated. On POSIX systems, `path` is considered to exist even if it is a symlink\nto a non-existent file. The exclusive flag may or may not work with network file\nsystems.\n-->\n\n<p>排他フラグ <code>'x'</code> (open(2) の <code>O_EXCL</code> フラグ) は、\n<code>path</code> が新しいファイルとして作成されることを保証します。\nPOSIX システムでは、<code>path</code> がたとえ存在しないファイルへのシンボリックだとしても\n存在すると見なされます。\n排他モードはネットワークファイルシステムでは動くかもしれませんし、\n動かないかもしれません。\n\n</p>\n<!--\nOn Linux, positional writes don't work when the file is opened in append mode.\nThe kernel ignores the position argument and always appends the data to\nthe end of the file.\n-->\n\n<p>Linux では、ファイルを追記モードでオープンした場合、\nポジションを指定した書き込みは動作しません。\nカーネルはポジション引数を無視し、データを常にファイルの最後に追記します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "flags"
                },
                {
                  "name": "mode",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.openSync(path, flags, [mode])",
          "type": "method",
          "name": "openSync",
          "desc": "<!--\nSynchronous version of `fs.open()`.\n-->\n\n<p>同期版の open(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "flags"
                },
                {
                  "name": "mode",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.utimes(path, atime, mtime, callback)",
          "type": "method",
          "name": "utimes",
          "desc": "<!--\nChange file timestamps.\nChange file timestamps of the file referenced by the supplied path.\n-->\n\n<p>渡されたパスが参照するファイルのタイムスタンプを変更します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "atime"
                },
                {
                  "name": "mtime"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "atime"
                },
                {
                  "name": "mtime"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.utimesSync(path, atime, mtime)",
          "type": "method",
          "name": "utimesSync",
          "desc": "<!--\nChange file timestamps.\nChange file timestamps of the file referenced by the supplied path.\n-->\n\n<p>渡されたパスが参照するファイルのタイムスタンプを変更します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "atime"
                },
                {
                  "name": "mtime"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.futimes(fd, atime, mtime, callback)",
          "type": "method",
          "name": "futimes",
          "desc": "<!--\nChange the file timestamps of a file referenced by the supplied file\ndescriptor.\n-->\n\n<p>渡されたファイル記述子が参照するファイルのタイムスタンプを変更します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "atime"
                },
                {
                  "name": "mtime"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "atime"
                },
                {
                  "name": "mtime"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.futimesSync(fd, atime, mtime)",
          "type": "method",
          "name": "futimesSync",
          "desc": "<!--\nChange the file timestamps of a file referenced by the supplied file\ndescriptor.\n-->\n\n<p>渡されたファイル記述子が参照するファイルのタイムスタンプを変更します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "atime"
                },
                {
                  "name": "mtime"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fsync(fd, callback)",
          "type": "method",
          "name": "fsync",
          "desc": "<!--\nAsynchronous fsync(2). No arguments other than a possible exception are given\nto the completion callback.\n-->\n\n<p>非同期の fsync(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.fsyncSync(fd)",
          "type": "method",
          "name": "fsyncSync",
          "desc": "<!--\nSynchronous fsync(2).\n-->\n\n<p>同期の fsync(2)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.write(fd, buffer, offset, length, position, callback)",
          "type": "method",
          "name": "write",
          "desc": "<!--\nWrite `buffer` to the file specified by `fd`.\n-->\n\n<p><code>fd</code> で指定されたファイルに <code>buffer</code> を書き込みます。\n\n</p>\n<!--\n`offset` and `length` determine the part of the buffer to be written.\n-->\n\n<p><code>offset</code> と <code>length</code> は書き込まれるバッファの部分を決定します。\n\n</p>\n<!--\n`position` refers to the offset from the beginning of the file where this data\nshould be written. If `position` is `null`, the data will be written at the\ncurrent position.\nSee pwrite(2).\n-->\n\n<p><code>position</code> はデータが書き込まれる位置をファイルの先頭からのオフセットで示します。\n<code>position</code> が <code>null</code> の場合、データは現在の位置から書き込まれます。\npwrite(2) を参照してください。\n\n</p>\n<!--\nThe callback will be given two arguments `(err, written)` where `written`\nspecifies how many _bytes_ were written.\nThe callback will be given three arguments `(err, written, buffer)` where `written`\nspecifies how many _bytes_ were written from `buffer`.\n-->\n\n<p>コールバックは 3 つの引数が与えられる <code>(err, written, buffer)</code> で、\n<code>written</code> は <code>buffer</code> から書き込まれた<em>バイト数</em>を示します。\n\n</p>\n<!--\nNote that it is unsafe to use `fs.write` multiple times on the same file\nwithout waiting for the callback. For this scenario,\n`fs.createWriteStream` is strongly recommended.\n-->\n\n<p>同じファイルに対してコールバックされるのを待つことなく <code>fs.write()</code> を何度も呼び出すことは、安全ではないことに注意してください。\nこのシナリオでは、 <code>fs.createWriteStream()</code> を強く推奨します。\n\n</p>\n<p>On Linux, positional writes don't work when the file is opened in append mode.\nThe kernel ignores the position argument and always appends the data to\nthe end of the file.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "buffer"
                },
                {
                  "name": "offset"
                },
                {
                  "name": "length"
                },
                {
                  "name": "position"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.writeSync(fd, buffer, offset, length, position)",
          "type": "method",
          "name": "writeSync",
          "desc": "<!--\nSynchronous version of `fs.write()`. Returns the number of bytes written.\n-->\n\n<p>同期版の <code>fs.write()</code>。書き込まれたバイト数を返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "buffer"
                },
                {
                  "name": "offset"
                },
                {
                  "name": "length"
                },
                {
                  "name": "position"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.read(fd, buffer, offset, length, position, callback)",
          "type": "method",
          "name": "read",
          "desc": "<!--\nRead data from the file specified by `fd`.\n-->\n\n<p><code>fd</code> で指定されたファイルからデータを読み込みます。\n\n</p>\n<!--\n`buffer` is the buffer that the data will be written to.\n-->\n\n<p><code>buffer</code> はデータが書き込まれるバッファです。\n\n</p>\n<!--\n`offset` is the offset in the buffer to start writing at.\n-->\n\n<p><code>offset</code> は書き込みを開始するバッファ内のオフセットです。\n\n</p>\n<!--\n`length` is an integer specifying the number of bytes to read.\n-->\n\n<p><code>length</code> は読み込むバイト数を指定する整数です。\n\n</p>\n<!--\n`position` is an integer specifying where to begin reading from in the file.\nIf `position` is `null`, data will be read from the current file position.\n-->\n\n<p><code>position</code> はファイルの読み込みを開始する位置を指定する整数です。\n<code>position</code> が <code>null</code> の場合、データは現在の位置から読み込まれます。\n\n</p>\n<!--\nThe callback is given the three arguments, `(err, bytesRead, buffer)`.\n-->\n\n<p>コールバックは3つの引数が与えられる <code>(err, bytesRead, buffer)</code> です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "buffer"
                },
                {
                  "name": "offset"
                },
                {
                  "name": "length"
                },
                {
                  "name": "position"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readSync(fd, buffer, offset, length, position)",
          "type": "method",
          "name": "readSync",
          "desc": "<!--\nSynchronous version of `fs.read`. Returns the number of `bytesRead`.\n-->\n\n<p>同期版の <code>fs.read</code>。<code>bytesRead</code> の数を返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                },
                {
                  "name": "buffer"
                },
                {
                  "name": "offset"
                },
                {
                  "name": "length"
                },
                {
                  "name": "position"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.readFile(filename, [options], callback)",
          "type": "method",
          "name": "readFile",
          "* `filename` {String}\n* `options` {Object}\n  * `encoding` {String | Null} default": "`null`\n  * `flag` {String} default = `'r'`\n* `callback` {Function}",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`filename` {String} ",
                  "name": "filename",
                  "type": "String"
                },
                {
                  "textRaw": "`options` {Object} ",
                  "options": [
                    {
                      "textRaw": "`encoding` {String | Null} デフォルトは `null` ",
                      "name": "encoding",
                      "type": "String | Null",
                      "desc": "デフォルトは `null`"
                    },
                    {
                      "textRaw": "`flag` {String} デフォルトは `'r'` ",
                      "name": "flag",
                      "type": "String",
                      "desc": "デフォルトは `'r'`"
                    }
                  ],
                  "name": "options",
                  "type": "Object",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "name": "callback",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<!--\nAsynchronously reads the entire contents of a file. Example:\n-->\n\n<p>ファイル全体の内容を非同期に読み込みます。例:\n\n</p>\n<pre><code>fs.readFile('/etc/passwd', function (err, data) {\n  if (err) throw err;\n  console.log(data);\n});</code></pre>\n<!--\nThe callback is passed two arguments `(err, data)`, where `data` is the\ncontents of the file.\n-->\n\n<p>コールバックは 2 つの引数が渡される <code>(err, data)</code> で、<code>data</code> はファイルの内容です。\n\n</p>\n<!--\nIf no encoding is specified, then the raw buffer is returned.\n-->\n\n<p>エンコーディングが指定されなければ、生のバッファが渡されます。\n\n</p>\n"
        },
        {
          "textRaw": "fs.readFileSync(filename, [options])",
          "type": "method",
          "name": "readFileSync",
          "desc": "<!--\nSynchronous version of `fs.readFile`. Returns the contents of the `filename`.\n-->\n\n<p>同期版の <code>fs.readFile</code>。<code>filename</code> の内容を返します。\n\n</p>\n<!--\nIf the `encoding` option is specified then this function returns a\nstring. Otherwise it returns a buffer.\n-->\n\n<p><code>encoding</code> オプションが指定されるとこの関数は文字列を返します。\nそうでなければバッファを返します。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.writeFile(filename, data, [options], callback)",
          "type": "method",
          "name": "writeFile",
          "* `filename` {String}\n* `data` {String | Buffer}\n* `options` {Object}\n  * `encoding` {String | Null} default": "`'utf8'`\n  * `mode` {Number} default = `438` (aka `0666` in Octal)\n  * `flag` {String} default = `'w'`\n* `callback` {Function}",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`filename` {String} ",
                  "name": "filename",
                  "type": "String"
                },
                {
                  "textRaw": "`data` {String | Buffer} ",
                  "name": "data",
                  "type": "String | Buffer"
                },
                {
                  "textRaw": "`options` {Object} ",
                  "options": [
                    {
                      "textRaw": "`encoding` {String | Null} デフォルトは `'utf8'` ",
                      "name": "encoding",
                      "type": "String | Null",
                      "desc": "デフォルトは `'utf8'`"
                    },
                    {
                      "textRaw": "`mode` {Number} デフォルトは `438` (8進数の `0666`) ",
                      "name": "mode",
                      "type": "Number",
                      "desc": "デフォルトは `438` (8進数の `0666`)"
                    },
                    {
                      "textRaw": "`flag` {String} デフォルトは `'w'` ",
                      "name": "flag",
                      "type": "String",
                      "desc": "デフォルトは `'w'`"
                    }
                  ],
                  "name": "options",
                  "type": "Object",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "name": "callback",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "data"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<!--\nAsynchronously writes data to a file, replacing the file if it already exists.\n`data` can be a string or a buffer.\n-->\n\n<p>非同期にデータをファイルに書き込みます。\nファイルが既に存在する場合は置き換えられます。\n<code>data</code> は文字列またはバッファです。\n\n</p>\n<!--\nThe `encoding` option is ignored if `data` is a buffer. It defaults\nto `'utf8'`.\n-->\n\n<p><code>data</code> がバッファの場合、<code>encoding</code> オプションは無視されます。\nデフォルトは <code>'utf8'</code> です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>fs.writeFile('message.txt', 'Hello Node', function (err) {\n  if (err) throw err;\n  console.log('It\\'s saved!');\n});</code></pre>\n"
        },
        {
          "textRaw": "fs.writeFileSync(filename, data, [options])",
          "type": "method",
          "name": "writeFileSync",
          "desc": "<!--\nThe synchronous version of `fs.writeFile`.\n-->\n\n<p>同期版の <code>fs.writeFile</code>。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "data"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.appendFile(filename, data, [options], callback)",
          "type": "method",
          "name": "appendFile",
          "* `filename` {String}\n* `data` {String | Buffer}\n* `options` {Object}\n  * `encoding` {String | Null} default": "`'utf8'`\n  * `mode` {Number} default = `438` (aka `0666` in Octal)\n  * `flag` {String} default = `'a'`\n* `callback` {Function}",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`filename` {String} ",
                  "name": "filename",
                  "type": "String"
                },
                {
                  "textRaw": "`data` {String | Buffer} ",
                  "name": "data",
                  "type": "String | Buffer"
                },
                {
                  "textRaw": "`options` {Object} ",
                  "options": [
                    {
                      "textRaw": "`encoding` {String | Null} デフォルトは `'utf8'` ",
                      "name": "encoding",
                      "type": "String | Null",
                      "desc": "デフォルトは `'utf8'`"
                    },
                    {
                      "textRaw": "`mode` {Number} デフォルトは `438` (8進数の `0666`) ",
                      "name": "mode",
                      "type": "Number",
                      "desc": "デフォルトは `438` (8進数の `0666`)"
                    },
                    {
                      "textRaw": "`flag` {String} デフォルトは `'a'` ",
                      "name": "flag",
                      "type": "String",
                      "desc": "デフォルトは `'a'`"
                    }
                  ],
                  "name": "options",
                  "type": "Object",
                  "optional": true
                },
                {
                  "textRaw": "`callback` {Function} ",
                  "name": "callback",
                  "type": "Function"
                }
              ]
            },
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "data"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ],
          "desc": "<!--\nAsynchronously append data to a file, creating the file if it not yet exists.\n`data` can be a string or a buffer.\n-->\n\n<p>非同期にデータをファイルに追加します。\nファイルが存在しなければ作成されます。\n<code>data</code> は文字列またはバッファです。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>fs.appendFile('message.txt', 'data to append', function (err) {\n  if (err) throw err;\n  console.log('The "data to append" was appended to file!');\n});</code></pre>\n"
        },
        {
          "textRaw": "fs.appendFileSync(filename, data, [options])",
          "type": "method",
          "name": "appendFileSync",
          "desc": "<!--\nThe synchronous version of `fs.appendFile`.\n-->\n\n<p>同期版の <code>fs.appendFile</code>。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "data"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.watchFile(filename, [options], listener)",
          "type": "method",
          "name": "watchFile",
          "stability": 2,
          "stabilityText": "Unstable.  Use fs.watch instead, if possible.",
          "desc": "<!--\nWatch for changes on `filename`. The callback `listener` will be called each\ntime the file is accessed.\n-->\n\n<p><code>filename</code> の変更を監視します。コールバックの <code>listener</code> はファイルがアクセスされる度に呼び出されます。\n\n</p>\n<!--\nThe second argument is optional. The `options` if provided should be an object\ncontaining two members a boolean, `persistent`, and `interval`. `persistent`\nindicates whether the process should continue to run as long as files are\nbeing watched. `interval` indicates how often the target should be polled,\nin milliseconds. The default is `{ persistent: true, interval: 5007 }`.\n-->\n\n<p>第 2 引数はオプションです．\n<code>options</code> が与えられる場合、それは boolean の <code>persistent</code> と <code>interval</code>\nの二つのメンバを含むオブジェクトです。\n<code>persistent</code> はファイルが監視されている間、\nプロセスが実行し続けることを示します。\n<code>interval</code> は対象をポーリングする間隔をミリ秒で示します\nデフォルトは <code>{ persistent: true, interval: 5007 }</code> です。\n\n</p>\n<!--\nThe `listener` gets two arguments the current stat object and the previous\nstat object:\n-->\n\n<p><code>listener</code> は現在の状態オブジェクトと前の状態オブジェクトの 2 つの引数を受け取ります:\n\n</p>\n<pre><code>fs.watchFile('message.text', function (curr, prev) {\n  console.log('the current mtime is: ' + curr.mtime);\n  console.log('the previous mtime was: ' + prev.mtime);\n});</code></pre>\n<!--\nThese stat objects are instances of `fs.Stat`.\n\nIf you want to be notified when the file was modified, not just accessed\nyou need to compare `curr.mtime` and `prev.mtime`.\n-->\n\n<p>これらの状態オブジェクトは <code>fs.Stat</code> のインスタンスです。\n\n</p>\n<p>もしファイルがアクセスされただけでなく、変更された時の通知が必要であれば、<code>curr.mtime</code> と <code>prev.mtime</code> を比較する必要があります。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "listener"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.unwatchFile(filename, [listener])",
          "type": "method",
          "name": "unwatchFile",
          "stability": 2,
          "stabilityText": "Unstable.  Use fs.watch instead, if possible.",
          "desc": "<!--\nStop watching for changes on `filename`. If `listener` is specified, only that\nparticular listener is removed. Otherwise, *all* listeners are removed and you\nhave effectively stopped watching `filename`.\n\nCalling `fs.unwatchFile()` with a filename that is not being watched is a\nno-op, not an error.\n-->\n\n<p><code>filename</code> の変更に対する監視を終了します。\n<code>listener</code> が指定された場合は該当の <code>listener</code> だけが取り除かれます。\nそうでなければ、<em>全ての</em> リスナが取り除かれ、\n<code>filenam</code> の監視は事実上終了します。\n\n</p>\n<p>監視されていないファイル名を指定した <code>fs.unwatchFile()</code> の呼び出しは\nエラーになるのではなく、何もしません。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "listener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.watch(filename, [options], [listener])",
          "type": "method",
          "name": "watch",
          "stability": 2,
          "stabilityText": "Unstable.",
          "desc": "<!--\nWatch for changes on `filename`, where `filename` is either a file or a\ndirectory.  The returned object is a [fs.FSWatcher](#fs_class_fs_fswatcher).\n\nThe second argument is optional. The `options` if provided should be an object\ncontaining a boolean member `persistent`, which indicates whether the process\nshould continue to run as long as files are being watched. The default is\n`{ persistent: true }`.\n\nThe listener callback gets two arguments `(event, filename)`.  `event` is either\n'rename' or 'change', and `filename` is the name of the file which triggered\nthe event.\n-->\n\n<p><code>filename</code> の変更を監視します。\n<code>filename</code> はファイルまたはディレクトリのどちらかです。\n戻り値のオブジェクトは <a href="\"#fs.FSWatcher\"">fs.FSWatcher</a> です。\n\n</p>\n<p>第 2 引数はオプションです。\nもし指定されるなら、<code>options</code> は boolean の <code>persistent</code> プロパティを\n持つオブジェクトであるべきです。\n<code>persistent</code> はファイルが監視されている間、\nプロセスが実行し続けることを示します。\nデフォルトは <code>{ persistent: true }</code> です。\n\n</p>\n<p>リスナーコールバックは二つの引数 <code>(event, filename)</code> を与えられます。\n<code>event</code> は <code>'rename'</code> または <code>'change'</code>、そして <code>filename</code> はイベントを\n引き起こしたファイルの名前です。\n\n</p>\n",
          "miscs": [
            {
              "textRaw": "Caveats",
              "name": "Caveats",
              "type": "misc",
              "desc": "<!--\nThe `fs.watch` API is not 100% consistent across platforms, and is\nunavailable in some situations.\n-->\n\n<p><code>fs.watch</code> API はプラットフォーム間で 100% 完全ではありmせんし、\nいくつかのシチュエーションで利用不可能です。\n\n</p>\n",
              "miscs": [
                {
                  "textRaw": "Availability",
                  "name": "Availability",
                  "type": "misc",
                  "desc": "<!--\nThis feature depends on the underlying operating system providing a way\nto be notified of filesystem changes.\n-->\n\n<p>この機能は下層のオペレーティングシステムが提供するファイルシステム変更の\n通知に依存します。\n\n</p>\n<!--\n* On Linux systems, this uses `inotify`.\n* On BSD systems (including OS X), this uses `kqueue`.\n* On SunOS systems (including Solaris and SmartOS), this uses `event ports`.\n* On Windows systems, this feature depends on `ReadDirectoryChangesW`.\n-->\n\n<ul>\n<li>Linux システムでは <code>inotify</code> が使われます。</li>\n<li>BSD システム (OS X を含みます) では <code>kqueue</code> が使われます。</li>\n<li>SunOS システム (Solaris および SmartOS を含みます) では <code>event ports</code>\nが使われます。</li>\n<li>Windows システムでは、この機能は <code>ReadDirectoryChangesW</code> に依存します。</li>\n</ul>\n<!--\nIf the underlying functionality is not available for some reason, then\n`fs.watch` will not be able to function.  For example, watching files or\ndirectories on network file systems (NFS, SMB, etc.) often doesn't work\nreliably or at all.\n-->\n\n<p>何らかの理由で下層の機能が使えない場合、<code>fs.watch()</code> は使えません。\nたとえば、ネットワークファイルシステム (NFS、SMB、その他) はしばしば\n信頼できないか全く動作しません。\n\n</p>\n<!--\nYou can still use `fs.watchFile`, which uses stat polling, but it is slower and\nless reliable.\n-->\n\n<p>stat をポーリングする <code>fs.watchFile()</code> を使うことはできますが、\nそれは遅くて信頼性はより低くなります。\n\n</p>\n"
                },
                {
                  "textRaw": "Filename Argument",
                  "name": "Filename Argument",
                  "type": "misc",
                  "desc": "<!--\nProviding `filename` argument in the callback is not supported\non every platform (currently it's only supported on Linux and Windows).  Even\non supported platforms `filename` is not always guaranteed to be provided.\nTherefore, don't assume that `filename` argument is always provided in the\ncallback, and have some fallback logic if it is null.\n-->\n\n<p>コールバックに提供される <code>filename</code> 引数は、\n全てのプラットフォームでサポートされるわけではありません\n(現時点では Linux と Windows でのみサポートされます)。\nサポートされるプラットフォームであっても、<code>filename</code> が常に提供されることが\n保証されているわけではありません。\nそのため、コールバックは <code>filename</code> 引数が常に提供されると仮定せず、\nそれが <code>null</code> だったときの代替手段を持つべきです。\n\n</p>\n<pre><code>fs.watch('somedir', function (event, filename) {\n  console.log('event is: ' + event);\n  if (filename) {\n    console.log('filename provided: ' + filename);\n  } else {\n    console.log('filename not provided');\n  }\n});</code></pre>\n"
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "filename"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "listener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.exists(path, callback)",
          "type": "method",
          "name": "exists",
          "desc": "<!--\nTest whether or not the given path exists by checking with the file system.\nThen call the `callback` argument with either true or false.  Example:\n-->\n\n<p>与えられたパスがファイルシステム上に存在するかどうか検査します。\nそして引数の <code>callback</code> を真か偽か検査の結果とともに呼び出します。\n例:\n\n</p>\n<pre><code>fs.exists('/etc/passwd', function (exists) {\n  util.debug(exists ? "it's there" : "no passwd!");\n});</code></pre>\n<!--\n`fs.exists()` is an anachronism and exists only for historical reasons.\nThere should almost never be a reason to use it in your own code.\n-->\n\n<p><code>fs.exists()</code> は時代錯誤で、存在する理由は歴史的経緯だけです。\nあなたのコードでこれを使うべき理由があってはいけません。\n\n</p>\n<!--\nIn particular, checking if a file exists before opening it is an anti-pattern\nthat leaves you vulnerable to race conditions: another process may remove the\nfile between the calls to `fs.exists()` and `fs.open()`.  Just open the file\nand handle the error when it's not there.\n-->\n\n<p>とりわけ、ファイルをオープンする前に存在をチェックするのは、\nあなたのコードを競合条件に対して脆弱にするアンチパターンです:\n<code>fs.exists()</code> と <code>fs.open()</code> の間に別のプロセスがファイルを\n削除するかもしれません。\n単純にファイルをオープンして、それが存在しない時はエラーを処理してください。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.existsSync(path)",
          "type": "method",
          "name": "existsSync",
          "desc": "<!--\nSynchronous version of `fs.exists`.\n-->\n\n<p>同期版の <code>fs.exists</code> です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.createReadStream(path, [options])",
          "type": "method",
          "name": "createReadStream",
          "desc": "<!--\nReturns a new ReadStream object (See `Readable Stream`).\n-->\n\n<p>新しい ReadStream オブジェクトを返します (<code>Readable Stream</code> を参照してください)。\n\n</p>\n<!--\n`options` is an object with the following defaults:\n-->\n\n<p><code>options</code> は以下のデフォルト値を持つオブジェクトです:\n\n</p>\n<pre><code>{ flags: 'r',\n  encoding: null,\n  fd: null,\n  mode: 0666,\n  autoClose: true\n}</code></pre>\n<!--\n`options` can include `start` and `end` values to read a range of bytes from\nthe file instead of the entire file.  Both `start` and `end` are inclusive and\nstart at 0. The `encoding` can be `'utf8'`, `'ascii'`, or `'base64'`.\n-->\n\n<p>ファイル全体を読み込む代わりに一部の範囲を読み込むため、\n<code>options</code> に <code>start</code> および <code>end</code> を含めることができます。\n<code>start</code> と <code>end</code> はどちらも包含的で0から始まります。\n<code>encoding</code> は <code>'utf8'</code>、<code>'ascii'</code>、または <code>'base64'</code> です。\n\n</p>\n<!--\nIf `autoClose` is false, then the file descriptor won't be closed, even if\nthere's an error.  It is your responsiblity to close it and make sure\nthere's no file descriptor leak.  If `autoClose` is set to true (default\nbehavior), on `error` or `end` the file descriptor will be closed\nautomatically.\n-->\n\n<p><code>autoClose</code> が <code>false</code> の場合、エラーが発生しない限りファイル記述子は\nクローズされません。ファイルをクローズし、ファイル記述子が\nリークしないようにするのはあなたの責務です。\n<code>autoClose</code> が <code>true</code> に設定されると (デフォルトの振る舞いです)、\n<code>error</code> または <code>end</code> によってファイル記述子は自動的にクローズされます。\n\n</p>\n<!--\nAn example to read the last 10 bytes of a file which is 100 bytes long:\n-->\n\n<p>100 バイトの長さを持つファイルの最後の 10 バイトを読み込む例:\n\n</p>\n<pre><code>fs.createReadStream('sample.txt', {start: 90, end: 99});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "fs.createWriteStream(path, [options])",
          "type": "method",
          "name": "createWriteStream",
          "desc": "<!--\nReturns a new WriteStream object (See `Writable Stream`).\n-->\n\n<p>新しい WriteStream オブジェクトを返します (<code>Writable Stream</code> を参照してください)。\n\n</p>\n<!--\n`options` is an object with the following defaults:\n-->\n\n<p><code>options</code> は以下のデフォルト値を持つオブジェクトです:\n\n</p>\n<pre><code>{ flags: 'w',\n  encoding: null,\n  mode: 0666 }</code></pre>\n<!--\n`options` may also include a `start` option to allow writing data at\nsome position past the beginning of the file.  Modifying a file rather\nthan replacing it may require a `flags` mode of `r+` rather than the\ndefault mode `w`.\n-->\n\n<p><code>options</code> にはデータをファイルのどの位置に書き込むかを指定する\n<code>start</code> を含めることができます。\nファイルを置換するのではなく変更する場合は、 <code>flags</code> にデフォルトの\n<code>w</code> ではなく <code>r+</code> が必要となります。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: fs.Stats",
          "type": "class",
          "name": "fs.Stats",
          "desc": "<!--\nObjects returned from `fs.stat()`, `fs.lstat()` and `fs.fstat()` and their\nsynchronous counterparts are of this type.\n-->\n\n<p><code>fs.stat()</code>、<code>fs.lstat()</code>、<code>fs.fstat()</code>、そしてそれらの同期版 から返される\nオブジェクトはこの型です。\n\n</p>\n<!--\n - `stats.isFile()`\n - `stats.isDirectory()`\n - `stats.isBlockDevice()`\n - `stats.isCharacterDevice()`\n - `stats.isSymbolicLink()` (only valid with  `fs.lstat()`)\n - `stats.isFIFO()`\n - `stats.isSocket()`\n-->\n\n<ul>\n<li><code>stats.isFile()</code></li>\n<li><code>stats.isDirectory()</code></li>\n<li><code>stats.isBlockDevice()</code></li>\n<li><code>stats.isCharacterDevice()</code></li>\n<li><code>stats.isSymbolicLink()</code> (<code>fs.lstat()</code> でのみ有効)</li>\n<li><code>stats.isFIFO()</code></li>\n<li><code>stats.isSocket()</code></li>\n</ul>\n<!--\nFor a regular file `util.inspect(stats)` would return a string very\nsimilar to this:\n-->\n\n<p><code>util.inspect(stats)</code> は通常のファイルに対して次のような文字列を返します。\n\n</p>\n<pre><code>{ dev: 2114,\n  ino: 48064969,\n  mode: 33188,\n  nlink: 1,\n  uid: 85,\n  gid: 100,\n  rdev: 0,\n  size: 527,\n  blksize: 4096,\n  blocks: 8,\n  atime: Mon, 10 Oct 2011 23:24:11 GMT,\n  mtime: Mon, 10 Oct 2011 23:24:11 GMT,\n  ctime: Mon, 10 Oct 2011 23:24:11 GMT }</code></pre>\n<!--\nPlease note that `atime`, `mtime` and `ctime` are instances\nof [Date][MDN-Date] object and to compare the values of\nthese objects you should use appropriate methods. For most\ngeneral uses [getTime()][MDN-Date-getTime] will return\nthe number of milliseconds elapsed since _1 January 1970\n00:00:00 UTC_ and this integer should be sufficient for\nany comparison, however there additional methods which can\nbe used for displaying fuzzy information. More details can\nbe found in the [MDN JavaScript Reference][MDN-Date] page.\n-->\n\n<p><code>atime</code>、<code>mtime</code>、そして <code>ctime</code> は [Date][MDN-Date] オブジェクトであり、\nその値を比較するには適切な方法があるということに注意してください。\nもっとも一般的に使われる [getTime()][MDN-Date-getTime] は <em>1970 年 1 月\n1 日</em>からの経過時間をミリ秒単位で返します。\nそれは比較には十分ですが、曖昧な情報を表示するには別の方法を使ってください。\nより詳しい情報は [MDN JavaScript Reference][MDN-Date] で探すことができます。\n\n</p>\n"
        },
        {
          "textRaw": "Class: fs.ReadStream",
          "type": "class",
          "name": "fs.ReadStream",
          "desc": "<!--\n`ReadStream` is a [Readable Stream](stream.html#stream_class_stream_readable).\n-->\n\n<p><code>ReadStream</code> は <a href="\"stream.html#stream_class_stream_readable\"">Readable Stream</a>\nです。\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'open'",
              "type": "event",
              "name": "open",
              "desc": "<!--\n* `fd` {Integer} file descriptor used by the ReadStream.\n\nEmitted when the ReadStream's file is opened.\n-->\n\n<ul>\n<li><code>fd</code> {Integer} ReadStream で使われる ファイル記述子。</li>\n</ul>\n<p>ReadStream のファイルがオープンされた場合に生成されます。\n\n\n</p>\n",
              "params": []
            }
          ]
        },
        {
          "textRaw": "Class: fs.WriteStream",
          "type": "class",
          "name": "fs.WriteStream",
          "desc": "<!--\n`WriteStream` is a [Writable Stream](stream.html#stream_class_stream_writable).\n-->\n\n<p><code>WriteStream</code> は <a href="\"stream.html#stream_class_stream_writable\"">Writable Stream</a>\nです。\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'open'",
              "type": "event",
              "name": "open",
              "desc": "<!--\n* `fd` {Integer} file descriptor used by the WriteStream.\n\nEmitted when the WriteStream's file is opened.\n-->\n\n<ul>\n<li><code>fd</code> {Integer} WriteStream で使われる ファイル記述子。</li>\n</ul>\n<p>WriteStream のファイルがオープンされた場合に生成されます。\n\n</p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "file.bytesWritten",
              "name": "bytesWritten",
              "desc": "<!--\nThe number of bytes written so far. Does not include data that is still queued\nfor writing.\n-->\n\n<p>これまでに書き込まれたバイト数。\n書き込みがキューイングされたままのデータは含まれません。\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: fs.FSWatcher",
          "type": "class",
          "name": "fs.FSWatcher",
          "desc": "<!--\nObjects returned from `fs.watch()` are of this type.\n-->\n\n<p><code>fs.watch()</code> が返すオブジェクトはこの型です。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "watcher.close()",
              "type": "method",
              "name": "close",
              "desc": "<!--\nStop watching for changes on the given `fs.FSWatcher`.\n-->\n\n<p><code>fs.FSWatcher</code> に与えられたファイルの監視を終了します。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'change'",
              "type": "event",
              "name": "change",
              "desc": "<!--\n* `event` {String} The type of fs change\n* `filename` {String} The filename that changed (if relevant/available)\n-->\n\n<ul>\n<li><code>event</code> {String} ファイルシステム変更の種類です。</li>\n<li><code>filename</code> {String} 変更されたファイル名です (もし利用可能であれば)。</li>\n</ul>\n<!--\nEmitted when something changes in a watched directory or file.\nSee more details in [fs.watch](#fs_fs_watch_filename_options_listener).\n-->\n\n<p>監視しているファイルまたはディレクトリに変更があると生成されます。\n詳しくは <a href="\"#fs_fs_watch_filename_options_listener\"">fs.watch</a>\nを参照してください。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "params": [],
              "desc": "<!--\nEmitted when an error occurs.\n-->\n\n<p>エラーが発生すると生成されます。\n\n</p>\n"
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "fs"
    },
    {
      "textRaw": "Path",
      "name": "path",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<!--\nThis module contains utilities for handling and transforming file\npaths.  Almost all these methods perform only string transformations.\nThe file system is not consulted to check whether paths are valid.\n\nUse `require('path')` to use this module.  The following methods are provided:\n-->\n\n<p>このモジュールはファイルのパスに対する処理や変換を行うユーティリティを含みます。\nほとんどのメソッドは文字列の変換だけを行います。\nパスが正しいか検証するためにファイルシステムに尋ねることはありません。\n\n</p>\n<p>このモジュールを利用するには<code>require('path')</code>を呼び出してください。\nこのモジュールは以下のメソッドを提供します。\n\n</p>\n",
      "methods": [
        {
          "textRaw": "path.normalize(p)",
          "type": "method",
          "name": "normalize",
          "desc": "<!--\nNormalize a string path, taking care of `'..'` and `'.'` parts.\n->\n\n文字列によるパスを正規化します。`'..'` と `'.'` の要素には注意してください。\n\n<!--\nWhen multiple slashes are found, they're replaced by a single one;\nwhen the path contains a trailing slash, it is preserved.\nOn Windows backslashes are used.\n-->\n\n<p>複数のスラッシュが見つかると、それらは一つに置換されます;\nパスの最後にスラッシュが含まれていると、それは維持されます。\nWindows ではバックスラッシュが使われます。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>path.normalize('/foo/bar//baz/asdf/quux/..')\n// returns\n'/foo/bar/baz/asdf'</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "p"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.join([path1], [path2], [...])",
          "type": "method",
          "name": "join",
          "desc": "<!--\nJoin all arguments together and normalize the resulting path.\n-->\n\n<p>全ての引数を一つに結合し、結果として得られるパスを正規化します。\n\n</p>\n<!--\nArguments must be strings.  In v0.8, non-string arguments were\nsilently ignored.  In v0.10 and up, an exception is thrown.\n-->\n\n<p>引数は文字列でなくてはなりません。\nv0.8 では、非文字列の引数は静かに無視されていました。\nv0.10 以降では、例外がスローされます。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')\n// returns\n'/foo/bar/baz/asdf'\n\npath.join('foo', {}, 'bar')\n// throws exception\nTypeError: Arguments to path.join must be strings</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path1",
                  "optional": true
                },
                {
                  "name": "path2",
                  "optional": true
                },
                {
                  "name": "...",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.resolve([from ...], to)",
          "type": "method",
          "name": "resolve",
          "desc": "<!--\nResolves `to` to an absolute path.\n-->\n\n<p><code>to</code> の絶対パスを解決します。\n\n</p>\n<!--\nIf `to` isn't already absolute `from` arguments are prepended in right to left\norder, until an absolute path is found. If after using all `from` paths still\nno absolute path is found, the current working directory is used as well. The\nresulting path is normalized, and trailing slashes are removed unless the path\ngets resolved to the root directory. Non-string arguments are ignored.\n-->\n\n<p>もし <code>to</code> が既に絶対パスでなければ、絶対パスが見つかるまで <code>from</code> 引数を右から左の順で先頭に加えます。\n全ての <code>from</code> を加えた後、パスがまだ絶対パスでなければ、カレントワーキングディレクトリが同様に使われます。\n結果のパスは正規化され、解決されたパスがルートディレクトリでない限り末尾のスラッシュは削除されます。\n文字列でない引数は無視されます。\n\n</p>\n<!--\nAnother way to think of it is as a sequence of `cd` commands in a shell.\n-->\n\n<p>それはシェルにおける <code>cd</code> コマンドの列だと考えることができます。\n\n</p>\n<!--\nExamples:\n-->\n\n<p>例:\n\n</p>\n<pre><code>path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')</code></pre>\n<!--\nIs similar to:\n-->\n\n<p>これは以下と同様です。\n\n</p>\n<pre><code>cd foo/bar\ncd /tmp/file/\ncd ..\ncd a/../subfile\npwd</code></pre>\n<!--\nThe difference is that the different paths don't need to exist and may also be\nfiles.\n-->\n\n<p>いは、それぞれのパスが必ずしも存在する必要がないことと、ファイルでも構わないことです。\n\n</p>\n<!--\nExamples:\n-->\n\n<p>例:\n\n</p>\n<pre><code>path.resolve('/foo/bar', './baz')\n// returns\n'/foo/bar/baz'\n\npath.resolve('/foo/bar', '/tmp/file/')\n// returns\n'/tmp/file'\n\npath.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')\n// if currently in /home/myself/node, it returns\n'/home/myself/node/wwwroot/static_files/gif/image.gif'</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "from ...",
                  "optional": true
                },
                {
                  "name": "to"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.relative(from, to)",
          "type": "method",
          "name": "relative",
          "desc": "<!--\nSolve the relative path from `from` to `to`.\n-->\n\n<p><code>from</code> から <code>to</code> への相対パスを解決します。\n\n</p>\n<!--\nAt times we have two absolute paths, and we need to derive the relative\npath from one to the other.  This is actually the reverse transform of\n`path.resolve`, which means we see that:\n-->\n\n<p>二つの絶対パスがあり、一方から他方への相対パスを得なければならない場合があります。\nこれは実際のところ、<code>path.resolve()</code> とは逆の変換です。\nそれは以下を意味します:\n\n</p>\n<pre><code>path.resolve(from, path.relative(from, to)) == path.resolve(to)</code></pre>\n<!--\nExamples:\n-->\n\n<p>例:\n\n</p>\n<pre><code>path.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb')\n// returns\n'..\\\\..\\\\impl\\\\bbb'\n\npath.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\n// returns\n'../../impl/bbb'</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "from"
                },
                {
                  "name": "to"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.dirname(p)",
          "type": "method",
          "name": "dirname",
          "desc": "<!--\nReturn the directory name of a path.  Similar to the Unix `dirname` command.\n-->\n\n<p>パスに含まれるディレクトリ名を返します。Unixの <code>dirname</code> コマンドと同様です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>path.dirname('/foo/bar/baz/asdf/quux')\n// returns\n'/foo/bar/baz/asdf'</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "p"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.basename(p, [ext])",
          "type": "method",
          "name": "basename",
          "desc": "<!--\nReturn the last portion of a path.  Similar to the Unix `basename` command.\n-->\n\n<p>パスの最後の要素を返します。Unixの <code>basename</code> コマンドと同様です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>path.basename('/foo/bar/baz/asdf/quux.html')\n// returns\n'quux.html'\n\npath.basename('/foo/bar/baz/asdf/quux.html', '.html')\n// returns\n'quux'</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "p"
                },
                {
                  "name": "ext",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "path.extname(p)",
          "type": "method",
          "name": "extname",
          "desc": "<!--\nReturn the extension of the path, from the last '.' to end of string\nin the last portion of the path.  If there is no '.' in the last portion\nof the path or the first character of it is '.', then it returns\nan empty string.  Examples:\n-->\n\n<p>パスの最後の要素について、最後の '.' から文字列の最後までのパスの拡張子を返します。\n最後の要素に '.' が含まれていなかった場合、もしくは '.' が最初の文字だった場合は、空の文字列を返します。\n例:\n\n</p>\n<pre><code>path.extname('index.html')\n// returns\n'.html'\n\npath.extname('index.coffee.md')\n// returns\n'.md'\n\npath.extname('index.')\n// returns\n'.'\n\npath.extname('index')\n// returns\n''</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "p"
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "path.sep",
          "name": "sep",
          "desc": "<!--\nThe platform-specific file separator. `'\\\\'` or `'/'`.\n-->\n\n<p>プラットフォーム固有のファイルセパレータ。 <code>'\\\\'</code> または <code>'/'</code>。\n\n</p>\n<!--\nAn example on *nix:\n-->\n\n<p>*nix での例:\n\n</p>\n<pre><code>'foo/bar/baz'.split(path.sep)\n// returns\n['foo', 'bar', 'baz']</code></pre>\n<!--\nAn example on Windows:\n-->\n\n<p>Windows での例:\n\n</p>\n<pre><code>'foo\\\\bar\\\\baz'.split(path.sep)\n// returns\n['foo', 'bar', 'baz']</code></pre>\n"
        },
        {
          "textRaw": "path.delimiter",
          "name": "delimiter",
          "desc": "<!--\nThe platform-specific path delimiter, `;` or `':'`.\n-->\n\n<p>プラットフォーム固有のパス区切り文字、<code>';'</code> または <code>':'</code>。\n\n</p>\n<!--\nAn example on *nix:\n-->\n\n<p>*nix での例:\n\n</p>\n<pre><code>console.log(process.env.PATH)\n// '/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin'\n\nprocess.env.PATH.split(path.delimiter)\n// returns\n['/usr/bin', '/bin', '/usr/sbin', '/sbin', '/usr/local/bin']</code></pre>\n<!--\nAn example on Windows:\n-->\n\n<p>Windows での例:\n\n</p>\n<pre><code>console.log(process.env.PATH)\n// 'C:\\Windows\\system32;C:\\Windows;C:\\Program Files\\nodejs\\'\n\nprocess.env.PATH.split(path.delimiter)\n// returns\n['C:\\Windows\\system32', 'C:\\Windows', 'C:\\Program Files\\nodejs\\']</code></pre>\n"
        }
      ],
      "type": "module",
      "displayName": "Path"
    },
    {
      "textRaw": "net",
      "name": "net",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<!--\nThe `net` module provides you with an asynchronous network wrapper. It contains\nmethods for creating both servers and clients (called streams). You can include\nthis module with `require('net');`\n-->\n\n<p><code>net</code> モジュールは非同期なネットワークのラッパーを提供します。\nそれはサーバとクライアントの両方 (ストリームと呼ばれます) を作成するための方法を含みます。\nこのモジュールは<code>require("net");</code>によって取り込むことができます。\n\n</p>\n",
      "methods": [
        {
          "textRaw": "net.createServer([options], [connectionListener])",
          "type": "method",
          "name": "createServer",
          "desc": "<!--\nCreates a new TCP server. The `connectionListener` argument is\nautomatically set as a listener for the ['connection'][] event.\n\n`options` is an object with the following defaults:\n-->\n\n<p>新しい TCP サーバを作成します。\n<code>connectionListener</code> 引数は ['connection'][]\nイベントに対するリスナーとして自動的に加えられます。\n\n</p>\n<p><code>options</code> は以下のデフォルト値を持つオブジェクトです:\n\n</p>\n<pre><code>{ allowHalfOpen: false\n}</code></pre>\n<!--\nIf `allowHalfOpen` is `true`, then the socket won't automatically send a FIN\npacket when the other end of the socket sends a FIN packet. The socket becomes\nnon-readable, but still writable. You should call the `end()` method explicitly.\nSee ['end'][] event for more information.\n-->\n\n<p><code>allowHalfOpen</code> が <code>true</code> だと、反対側のソケットが FIN パケットを送信してきても自動的に FIN を送信しなくなります。\nソケットは読み込み可能ではなくなりますが、書き込み可能のままです。\n明示的に <code>end()</code> を呼び出す必要があります。\n['end'][] イベントにより多くの情報があります。\n\n</p>\n<!--\nHere is an example of an echo server which listens for connections\non port 8124:\n-->\n\n<p>8124 番のポートへの接続を待ち受けるエコーサーバの例:\n\n</p>\n<pre><code>var net = require('net');\nvar server = net.createServer(function(c) { //'connection' listener\n  console.log('server connected');\n  c.on('end', function() {\n    console.log('server disconnected');\n  });\n  c.write('hello\\r\\n');\n  c.pipe(c);\n});\nserver.listen(8124, function() { //'listening' listener\n  console.log('server bound');\n});</code></pre>\n<!--\nTest this by using `telnet`:\n-->\n\n<p><code>telnet</code> を使ってテストします:\n\n</p>\n<pre><code>telnet localhost 8124</code></pre>\n<!--\nTo listen on the socket `/tmp/echo.sock` the third line from the last would\njust be changed to\n-->\n\n<p><code>'/tmp/echo.sock'</code> へのソケットを待ち受けるには、最後から三行目をこのように変更します。\n\n</p>\n<pre><code>server.listen('/tmp/echo.sock', function() { //'listening' listener</code></pre>\n<!--\nUse `nc` to connect to a UNIX domain socket server:\n-->\n\n<p><code>nc</code> を使って UNIX ドメインソケットサーバへ接続します:\n\n</p>\n<pre><code>nc -U /tmp/echo.sock</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "connectionListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.connect(options, [connectionListener])",
          "type": "method",
          "name": "connect",
          "desc": "<!--\nConstructs a new socket object and opens the socket to the given location.\nWhen the socket is established, the ['connect'][] event will be emitted.\n-->\n\n<p>新しいソケットオブジェクトを構築し、与えられたロケーションへのソケットを\nオープンします。\nソケットが確立されると、['connect'][] イベントが生成されます。\n\n</p>\n<!--\nFor TCP sockets, `options` argument should be an object which specifies:\n-->\n\n<p>TCP ソケットの場合、<code>options</code> 引数は以下を指定したオブジェクトです。\n\n</p>\n<!--\n  - `port`: Port the client should connect to (Required).\n\n  - `host`: Host the client should connect to. Defaults to `'localhost'`.\n\n  - `localAddress`: Local interface to bind to for network connections.\n-->\n\n<ul>\n<li><p><code>port</code>: クライアントが接続するポート番号です (必須)。</p>\n</li>\n<li><p><code>host</code>: クライアントが接続するホストです。デフォルトは <code>localhost</code> です。</p>\n</li>\n<li><p><code>localAddress</code>: ネットワーク接続をバインドするローカルインタフェースです。</p>\n</li>\n</ul>\n<!--\nFor UNIX domain sockets, `options` argument should be an object which specifies:\n-->\n\n<p>UNIX ドメインソケットの場合、<code>options</code> 引数は以下を指定したオブジェクトです。\n\n</p>\n<!--\n  - `path`: Path the client should connect to (Required).\n-->\n\n<ul>\n<li><code>path</code>: クライアントが接続するパスです (必須)。</li>\n</ul>\n<!--\nCommon options are:\n-->\n\n<p>共通のオプション:\n\n</p>\n<!--\n  - `allowHalfOpen`: if `true`, the socket won't automatically send\n    a FIN packet when the other end of the socket sends a FIN packet.\n    Defaults to `false`.  See ['end'][] event for more information.\n-->\n\n<ul>\n<li><code>allowHalfOpen</code>: <code>true</code> の場合、反対側のソケットが FIN\nパケットを送信してきても自動的に FIN を送信しなくなります。\nデフォルトは <code>false</code> です。\n['end'][] イベントにより多くの情報があります。</li>\n</ul>\n<!--\nThe `connectListener` parameter will be added as an listener for the\n['connect'][] event.\n-->\n\n<p><code>connectListener</code> 引数は ['connect'][] イベントのリスナとして追加されます。\n\n</p>\n<!--\nHere is an example of a client of echo server as described previously:\n-->\n\n<p>前述のエコーサーバに接続するクライアントの例:\n\n</p>\n<pre><code>var net = require('net');\nvar client = net.connect({port: 8124},\n    function() { //'connect' listener\n  console.log('client connected');\n  client.write('world!\\r\\n');\n});\nclient.on('data', function(data) {\n  console.log(data.toString());\n  client.end();\n});\nclient.on('end', function() {\n  console.log('client disconnected');\n});</code></pre>\n<!--\nTo connect on the socket `/tmp/echo.sock` the second line would just be\nchanged to\n-->\n\n<p><code>'/tmp/echo.sock'</code> へのソケットに接続するには、2 行目をこのように変更します。\n\n</p>\n<pre><code>var client = net.connect({path: '/tmp/echo.sock'});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "connectionListener",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "connectionListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.createConnection(options, [connectionListener])",
          "type": "method",
          "name": "createConnection",
          "desc": "<!--\nConstructs a new socket object and opens the socket to the given location.\nWhen the socket is established, the ['connect'][] event will be emitted.\n-->\n\n<p>新しいソケットオブジェクトを構築し、与えられたロケーションへのソケットを\nオープンします。\nソケットが確立されると、['connect'][] イベントが生成されます。\n\n</p>\n<!--\nFor TCP sockets, `options` argument should be an object which specifies:\n-->\n\n<p>TCP ソケットの場合、<code>options</code> 引数は以下を指定したオブジェクトです。\n\n</p>\n<!--\n  - `port`: Port the client should connect to (Required).\n\n  - `host`: Host the client should connect to. Defaults to `'localhost'`.\n\n  - `localAddress`: Local interface to bind to for network connections.\n-->\n\n<ul>\n<li><p><code>port</code>: クライアントが接続するポート番号です (必須)。</p>\n</li>\n<li><p><code>host</code>: クライアントが接続するホストです。デフォルトは <code>localhost</code> です。</p>\n</li>\n<li><p><code>localAddress</code>: ネットワーク接続をバインドするローカルインタフェースです。</p>\n</li>\n</ul>\n<!--\nFor UNIX domain sockets, `options` argument should be an object which specifies:\n-->\n\n<p>UNIX ドメインソケットの場合、<code>options</code> 引数は以下を指定したオブジェクトです。\n\n</p>\n<!--\n  - `path`: Path the client should connect to (Required).\n-->\n\n<ul>\n<li><code>path</code>: クライアントが接続するパスです (必須)。</li>\n</ul>\n<!--\nCommon options are:\n-->\n\n<p>共通のオプション:\n\n</p>\n<!--\n  - `allowHalfOpen`: if `true`, the socket won't automatically send\n    a FIN packet when the other end of the socket sends a FIN packet.\n    Defaults to `false`.  See ['end'][] event for more information.\n-->\n\n<ul>\n<li><code>allowHalfOpen</code>: <code>true</code> の場合、反対側のソケットが FIN\nパケットを送信してきても自動的に FIN を送信しなくなります。\nデフォルトは <code>false</code> です。\n['end'][] イベントにより多くの情報があります。</li>\n</ul>\n<!--\nThe `connectListener` parameter will be added as an listener for the\n['connect'][] event.\n-->\n\n<p><code>connectListener</code> 引数は ['connect'][] イベントのリスナとして追加されます。\n\n</p>\n<!--\nHere is an example of a client of echo server as described previously:\n-->\n\n<p>前述のエコーサーバに接続するクライアントの例:\n\n</p>\n<pre><code>var net = require('net');\nvar client = net.connect({port: 8124},\n    function() { //'connect' listener\n  console.log('client connected');\n  client.write('world!\\r\\n');\n});\nclient.on('data', function(data) {\n  console.log(data.toString());\n  client.end();\n});\nclient.on('end', function() {\n  console.log('client disconnected');\n});</code></pre>\n<!--\nTo connect on the socket `/tmp/echo.sock` the second line would just be\nchanged to\n-->\n\n<p><code>'/tmp/echo.sock'</code> へのソケットに接続するには、2 行目をこのように変更します。\n\n</p>\n<pre><code>var client = net.connect({path: '/tmp/echo.sock'});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "connectionListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.connect(port, [host], [connectListener])",
          "type": "method",
          "name": "connect",
          "desc": "<!--\nCreates a TCP connection to `port` on `host`. If `host` is omitted,\n`'localhost'` will be assumed.\nThe `connectListener` parameter will be added as an listener for the\n['connect'][] event.\n-->\n\n<p><code>host</code> 上の <code>port</code> に対する TCP コネクションを作成します。\n<code>host</code> が省略されると <code>localhost</code> が仮定されます。\n<code>connectListener</code> 引数は ['connect'][] イベントのリスナとして追加されます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "port"
                },
                {
                  "name": "host",
                  "optional": true
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "port"
                },
                {
                  "name": "host",
                  "optional": true
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.createConnection(port, [host], [connectListener])",
          "type": "method",
          "name": "createConnection",
          "desc": "<!--\nCreates a TCP connection to `port` on `host`. If `host` is omitted,\n`'localhost'` will be assumed.\nThe `connectListener` parameter will be added as an listener for the\n['connect'][] event.\n-->\n\n<p><code>host</code> 上の <code>port</code> に対する TCP コネクションを作成します。\n<code>host</code> が省略されると <code>localhost</code> が仮定されます。\n<code>connectListener</code> 引数は ['connect'][] イベントのリスナとして追加されます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "port"
                },
                {
                  "name": "host",
                  "optional": true
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.connect(path, [connectListener])",
          "type": "method",
          "name": "connect",
          "desc": "<!--\nCreates unix socket connection to `path`.\nThe `connectListener` parameter will be added as an listener for the\n['connect'][] event.\n-->\n\n<p><code>path</code> に対する UNIX ドメインソケットを作成します。\n<code>connectListener</code> 引数は ['connect'][] イベントのリスナとして追加されます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.createConnection(path, [connectListener])",
          "type": "method",
          "name": "createConnection",
          "desc": "<!--\nCreates unix socket connection to `path`.\nThe `connectListener` parameter will be added as an listener for the\n['connect'][] event.\n-->\n\n<p><code>path</code> に対する UNIX ドメインソケットを作成します。\n<code>connectListener</code> 引数は ['connect'][] イベントのリスナとして追加されます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "path"
                },
                {
                  "name": "connectListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.isIP(input)",
          "type": "method",
          "name": "isIP",
          "desc": "<!--\nTests if input is an IP address. Returns 0 for invalid strings,\nreturns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses.\n-->\n\n<p><code>input</code> が IP アドレスかテストします。\n不正な文字列だと 0、IP バージョン 4 アドレスだと 4，IP バージョン 6\nアドレスだと 6 が返されます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "input"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.isIPv4(input)",
          "type": "method",
          "name": "isIPv4",
          "desc": "<!--\nReturns true if input is a version 4 IP address, otherwise returns false.\n-->\n\n<p><code>input</code> が バージョン 4 の IP アドレスなら true、そうでなければ false を返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "input"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "net.isIPv6(input)",
          "type": "method",
          "name": "isIPv6",
          "desc": "<!--\nReturns true if input is a version 6 IP address, otherwise returns false.\n-->\n\n<p><code>input</code> が バージョン 6 の IP アドレスなら true、そうでなければ false を返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "input"
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: net.Server",
          "type": "class",
          "name": "net.Server",
          "desc": "<!--\nThis class is used to create a TCP or UNIX server.\n-->\n\n<p>このクラスは TCP または UNIX ドメインのサーバを作成するために使われます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "server.listen(port, [host], [backlog], [callback])",
              "type": "method",
              "name": "listen",
              "desc": "<!--\nBegin accepting connections on the specified `port` and `host`.  If the\n`host` is omitted, the server will accept connections directed to any\nIPv4 address (`INADDR_ANY`). A port value of zero will assign a random port.\n-->\n\n<p>指定された <code>port</code> と <code>host</code> でコネクションの受け入れを開始します。\n<code>host</code> が省略されると、サーバはどんな IPv4 アドレスへの接続も受け入れます\n(<code>INADDR_ANY</code>)。\nポート番号に 0 を指定すると、ランダムなポートが割り当てられます。\n\n</p>\n<!--\nBacklog is the maximum length of the queue of pending connections.\nThe actual length will be determined by your OS through sysctl settings such as\n`tcp_max_syn_backlog` and `somaxconn` on linux. The default value of this\nparameter is 511 (not 512).\n-->\n\n<p>バックログは保留された接続のキューの最大長です。\n実際の長さは Linux では <code>tcp_max_syn_backlog</code> や <code>somaxconn</code> など、\nsysctl の設定を通じて OS によって決定されます。\nこのパラメータのデフォルト値は 511 (512 ではありません) です。\n\n</p>\n<!--\nThis function is asynchronous.  When the server has been bound,\n['listening'][] event will be emitted.  The last parameter `callback`\nwill be added as an listener for the ['listening'][] event.\n-->\n\n<p>この関数は非同期です。\nサーバがバインドされると、['listening'][] イベントが生成されます。\n最後の引数 <code>callback</code> は ['listening'][] のリスナとして加えられます。\n\n</p>\n<!--\nOne issue some users run into is getting `EADDRINUSE` errors. This means that\nanother server is already running on the requested port. One way of handling this\nwould be to wait a second and then try again. This can be done with\n-->\n\n<p>一部のユーザが陥る問題の一つは、<code>EADDRINUSE</code> エラーです。\nこれは、他のサーバが要求されたポートを使っていることを意味します。\nこれに対照する方法の一つは、1秒待機してからリトライすることです。\nこれは次のようになります\n\n</p>\n<pre><code>server.on('error', function (e) {\n  if (e.code == 'EADDRINUSE') {\n    console.log('Address in use, retrying...');\n    setTimeout(function () {\n      server.close();\n      server.listen(PORT, HOST);\n    }, 1000);\n  }\n});</code></pre>\n<!--\n(Note: All sockets in Node set `SO_REUSEADDR` already)\n-->\n\n<p>注意: Node の全てのソケットは <code>SO_REUSEADDR</code> が設定されます)\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "host",
                      "optional": true
                    },
                    {
                      "name": "backlog",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.listen(path, [callback])",
              "type": "method",
              "name": "listen",
              "desc": "<!--\nStart a UNIX socket server listening for connections on the given `path`.\n-->\n\n<p>与えられた <code>path</code> へのコネクションを待ち受けるする UNIX ドメインソケットのサーバを開始します。\n\n</p>\n<!--\nThis function is asynchronous.  When the server has been bound,\n['listening'][] event will be emitted.  The last parameter `callback`\nwill be added as an listener for the ['listening'][] event.\n-->\n\n<p>この関数は非同期です。\nサーバがバインドされると、['listening'][] イベントが生成されます。\n最後の引数 <code>callback</code> は ['listening'][] のリスナとして加えられます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.listen(handle, [callback])",
              "type": "method",
              "name": "listen",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`handle` {Object} ",
                      "name": "handle",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "handle"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nThe `handle` object can be set to either a server or socket (anything\nwith an underlying `_handle` member), or a `{fd: <n>}` object.\n-->\n\n<p><code>handle</code> オブジェクトには、サーバまたはソケット (下層の <code>_handle</code> メンバなら\nなんでも) または、 <code>{fd: <n>}</code> オブジェクトを設定することができます。\n\n</p>\n<!--\nThis will cause the server to accept connections on the specified\nhandle, but it is presumed that the file descriptor or handle has\nalready been bound to a port or domain socket.\n-->\n\n<p>これによりサーバは指定したハンドルへの接続を受け付けることになりますが、\nファイル記述子またはハンドルは既にポートまたはドメインソケットに\nバインドされているものと見なされます。\n\n</p>\n<!--\nListening on a file descriptor is not supported on Windows.\n-->\n\n<p>ファイル記述子へのリスニングは Windows ではサポートされません。\n\n</p>\n<!--\nThis function is asynchronous.  When the server has been bound,\n['listening'](#event_listening_) event will be emitted.\nthe last parameter `callback` will be added as an listener for the\n['listening'](#event_listening_) event.\n-->\n\n<p>この関数は非同期です。\nサーバがバインドされると、['listening'][] イベントが生成されます。\n最後の引数 <code>callback</code> は ['listening'][] のリスナとして加えられます。\n\n</p>\n"
            },
            {
              "textRaw": "server.close([callback])",
              "type": "method",
              "name": "close",
              "desc": "<!--\nStops the server from accepting new connections and keeps existing\nconnections. This function is asynchronous, the server is finally\nclosed when all connections are ended and the server emits a `'close'`\nevent. Optionally, you can pass a callback to listen for the `'close'`\nevent.\n-->\n\n<p>サーバが新しい接続を受け付けるのを終了しますが、既存の接続は維持します。\nこの関数は非同期で、サーバは最終的に全ての接続が閉じられると\n<code>'close'</code> イベントを生成してクローズされます。\nオプションとして、<code>'close'</code> イベントに対するリスナを渡すことができます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.address()",
              "type": "method",
              "name": "address",
              "desc": "<!--\nReturns the bound address, the address family name and port of the server\nas reported by the operating system.\nUseful to find which port was assigned when giving getting an OS-assigned address.\nReturns an object with three properties, e.g.\n`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`\n-->\n\n<p>オペレーティングシステムから報告された、サーバにバインドされたアドレスと\nアドレスファミリ名、ポートを返します。\nOSによって割り当てられたアドレスが渡された時に、どのポートに割り当てられたものかを調べるのに便利です。\n返されるオブジェクトは 3 つのプロパティを持ちます。例:\n<code>{ port: 12346, family: 'IPv4', address: '127.0.0.1' }</code>\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var server = net.createServer(function (socket) {\n  socket.end("goodbye\\n");\n});\n\n// grab a random port.\nserver.listen(function() {\n  address = server.address();\n  console.log("opened server on %j", address);\n});</code></pre>\n<!--\nDon't call `server.address()` until the `'listening'` event has been emitted.\n-->\n\n<p><code>'listening'</code> イベントが生成される前に <code>server.address()</code> を呼び出してはいけません。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "server.unref()",
              "type": "method",
              "name": "unref",
              "desc": "<!--\nCalling `unref` on a server will allow the program to exit if this is the only\nactive server in the event system. If the server is already `unref`d calling\n`unref` again will have no effect.\n-->\n\n<p>イベントシステムにおいて、このサーバだけがアクティブな場合にプログラムを\n終了することができるように、<code>unref</code> を呼び出します。\n既に <code>unref</code> されたサーバで再び <code>unref</code> が呼び出されても影響はありません。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "server.ref()",
              "type": "method",
              "name": "ref",
              "desc": "<!--\nOpposite of `unref`, calling `ref` on a previously `unref`d server will *not*\nlet the program exit if it's the only server left (the default behavior). If\nthe server is `ref`d calling `ref` again will have no effect.\n-->\n\n<p><code>unref</code> とは逆に、以前に <code>unref</code> されたサーバが唯一残ったサーバになっても、\nプログラムが終了 (デフォルトの動作です) しないように、<code>ref</code> を呼び出します。\n既に <code>ref</code> されたサーバで再び <code>ref</code> が呼び出されても影響はありません。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "server.getConnections(callback)",
              "type": "method",
              "name": "getConnections",
              "desc": "<!--\nAsynchronously get the number of concurrent connections on the server. Works\nwhen sockets were sent to forks.\n-->\n\n<p>サーバ上の並行コネクオションの数を非同期に取得します。\nソケットが fork した子プロセスに送られても動作します。\n\n</p>\n<!--\nCallback should take two arguments `err` and `count`.\n-->\n\n<p>コールバックは <code>err</code> と <code>count</code> の二つの引数を取るべきです。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "server.maxConnections",
              "name": "maxConnections",
              "desc": "<!--\nSet this property to reject connections when the server's connection count gets\nhigh.\n-->\n\n<p>サーバの接続数が大きくなった時に接続を拒否するためにこのプロパティを設定します。\n\n</p>\n<!--\nIt is not recommended to use this option once a socket has been sent to a child\nwith `child_process.fork()`.\n-->\n\n<p><code>child_process.fork()</code> によって子プロセスに送られたソケットに対して\nこのオプションを使用することは推奨されません。\n\n</p>\n"
            },
            {
              "textRaw": "server.connections",
              "name": "connections",
              "desc": "<!--\nThis function is **deprecated**; please use [server.getConnections()][] instead.\n-->\n\n<p>この関数は <strong>廃止予定</strong> です;\n代わりに [server.getConnections()][] を使ってください。\n\n</p>\n<!--\nThe number of concurrent connections on the server.\n-->\n\n<p>このサーバ上の並行コネクションの数です。\n\n</p>\n<!--\nThis becomes `null` when sending a socket to a child with\n`child_process.fork()`. To poll forks and get current number of active\nconnections use asynchronous `server.getConnections` instead.\n-->\n\n<p>ソケットが <code>child_process.fork()</code> によって子プロセスに送られると、\nこれは <code>null</code> になります。\nfork した子プロセスにポーリングして現在のアクティブな接続を得る代わりに、\n非同期の <code>server.getConnections</code> を使用してください。\n\n</p>\n<!--\n`net.Server` is an [EventEmitter][] with the following events:\n-->\n\n<p><code>net.Server</code> は以下のイベントを持つ [EventEmitter][] です:\n\n</p>\n"
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'listening'",
              "type": "event",
              "name": "listening",
              "desc": "<!--\nEmitted when the server has been bound after calling `server.listen`.\n-->\n\n<p><code>server.listen()</code> が呼ばれた後、サーバがバインドされると生成されます。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'connection'",
              "type": "event",
              "name": "connection",
              "params": [],
              "desc": "<!--\nEmitted when a new connection is made. `socket` is an instance of\n`net.Socket`.\n-->\n\n<p>新しいコネクションが作成されると生成されます。\n<code>socket</code> は <code>net.Socket</code> のインスタンスです。\n\n</p>\n"
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<!--\nEmitted when the server closes. Note that if connections exist, this\nevent is not emitted until all connections are ended.\n-->\n\n<p>サーバがクローズした時に生成されます。\nもし接続が存在すると、このイベントは全ての接続が閉じられるまで\n生成されないことに注意してください。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "params": [],
              "desc": "<!--\nEmitted when an error occurs.  The `'close'` event will be called directly\nfollowing this event.  See example in discussion of `server.listen`.\n-->\n\n<p>エラーが発生すると生成されます。\nこのイベントに続いて <code>'close'</code> イベントが直接生成される場合があります。\n<code>server.listen()</code> の例を参照してください。\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: net.Socket",
          "type": "class",
          "name": "net.Socket",
          "desc": "<!--\nThis object is an abstraction of a TCP or UNIX socket.  `net.Socket`\ninstances implement a duplex Stream interface.  They can be created by the\nuser and used as a client (with `connect()`) or they can be created by Node\nand passed to the user through the `'connection'` event of a server.\n-->\n\n<p>このオブジェクトは TCP または UNIX ドメインのソケットを抽象化したものです。\n<code>net.Socket</code> のインスタンスは双方向のストリームインタフェースを実装します。\nそれらはユーザによって (<code>connect()</code> によって) 作成されてクライアントとして使われるか、\nNode によって作成されてサーバの <code>'connection'</code> イベントを通じてユーザに渡されます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "new net.Socket([options])",
              "type": "method",
              "name": "Socket",
              "desc": "<!--\nConstruct a new socket object.\n-->\n\n<p>新しいソケットオブジェクトを構築します。\n\n</p>\n<!--\n`options` is an object with the following defaults:\n-->\n\n<p><code>options</code> は以下のデフォルト値を持つオブジェクトです。\n\n</p>\n<pre><code>{ fd: null\n  allowHalfOpen: false,\n  readable: false,\n  writable: false\n}</code></pre>\n<!--\n`fd` allows you to specify the existing file descriptor of socket.\nSet `readable` and/or `writable` to `true` to allow reads and/or writes on this\nsocket (NOTE: Works only when `fd` is passed).\nAbout `allowHalfOpen`, refer to `createServer()` and `'end'` event.\n-->\n\n<p><code>fd</code> に既存のソケットのファイル記述子を指定することができます。\n<code>readable</code> および <code>writable</code> を <code>true</code> にすると、このソケットを読み込みまたは\n書き出し可能にすることが出来ます (注意: <code>fd</code> が渡され場合のみ効果があります)。\n<code>allowHalfOpen</code> については <code>createServer()</code> および <code>'end'</code> イベントを参照してください。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.connect(port, [host], [connectListener])",
              "type": "method",
              "name": "connect",
              "desc": "<!--\nOpens the connection for a given socket. If `port` and `host` are given,\nthen the socket will be opened as a TCP socket, if `host` is omitted,\n`localhost` will be assumed. If a `path` is given, the socket will be\nopened as a unix socket to that path.\n-->\n\n<p>与えられたソケットでコネクションをオープンします。\n<code>port</code> と <code>host</code> が与えられた場合、\nソケットは TCP ソケットとしてオープンされます。\n<code>host</code> が省略された場合は <code>localhost</code> が仮定されます。\n<code>path</code> が与えられた場合は、\nソケットはそのパスへの UNIX ドメインソケットとしてオープンされます。\n\n</p>\n<!--\nNormally this method is not needed, as `net.createConnection` opens the\nsocket. Use this only if you are implementing a custom Socket.\n-->\n\n<p>通常このメソッドは必要なく、<code>net.createConnection</code> でソケットをオープンします。\nこれを使うのは、カスタマイズされたソケットを実装している場合だけです。\n\n</p>\n<!--\nThis function is asynchronous. When the ['connect'][] event is emitted the\nsocket is established. If there is a problem connecting, the `'connect'` event\nwill not be emitted, the `'error'` event will be emitted with the exception.\n-->\n\n<p>この関数は非同期です。ソケットが確立されると ['connect'][]\nイベントが生成されます。\n接続で問題があった場合は <code>'connect'</code> イベントは生成されず、\n例外とともに <code>'error'</code> イベントが生成されます。\n\n</p>\n<!--\nThe `connectListener` parameter will be added as an listener for the\n['connect'][] event.\n-->\n\n<p><code>connectListener</code> 引数は ['connect'][] イベントのリスナに加えられます。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "connectListener",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "host",
                      "optional": true
                    },
                    {
                      "name": "connectListener",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.connect(path, [connectListener])",
              "type": "method",
              "name": "connect",
              "desc": "<!--\nOpens the connection for a given socket. If `port` and `host` are given,\nthen the socket will be opened as a TCP socket, if `host` is omitted,\n`localhost` will be assumed. If a `path` is given, the socket will be\nopened as a unix socket to that path.\n-->\n\n<p>与えられたソケットでコネクションをオープンします。\n<code>port</code> と <code>host</code> が与えられた場合、\nソケットは TCP ソケットとしてオープンされます。\n<code>host</code> が省略された場合は <code>localhost</code> が仮定されます。\n<code>path</code> が与えられた場合は、\nソケットはそのパスへの UNIX ドメインソケットとしてオープンされます。\n\n</p>\n<!--\nNormally this method is not needed, as `net.createConnection` opens the\nsocket. Use this only if you are implementing a custom Socket.\n-->\n\n<p>通常このメソッドは必要なく、<code>net.createConnection</code> でソケットをオープンします。\nこれを使うのは、カスタマイズされたソケットを実装している場合だけです。\n\n</p>\n<!--\nThis function is asynchronous. When the ['connect'][] event is emitted the\nsocket is established. If there is a problem connecting, the `'connect'` event\nwill not be emitted, the `'error'` event will be emitted with the exception.\n-->\n\n<p>この関数は非同期です。ソケットが確立されると ['connect'][]\nイベントが生成されます。\n接続で問題があった場合は <code>'connect'</code> イベントは生成されず、\n例外とともに <code>'error'</code> イベントが生成されます。\n\n</p>\n<!--\nThe `connectListener` parameter will be added as an listener for the\n['connect'][] event.\n-->\n\n<p><code>connectListener</code> 引数は ['connect'][] イベントのリスナに加えられます。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "connectListener",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.setEncoding([encoding])",
              "type": "method",
              "name": "setEncoding",
              "desc": "<!--\nSet the encoding for the socket as a Readable Stream. See\n[stream.setEncoding()][] for more information.\n-->\n\n<p>ソケットを入力ストリームとしてエンコーディングを設定します。\n詳細は [stream.setEncoding()][] を参照してください。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.write(data, [encoding], [callback])",
              "type": "method",
              "name": "write",
              "desc": "<!--\nSends data on the socket. The second parameter specifies the encoding in the\ncase of a string--it defaults to UTF8 encoding.\n-->\n\n<p>ソケットにデータを送信します。\n文字列の場合、第 2 引数はエンコーディングを指定します － デフォルトは UTF-8 です。\n\n</p>\n<!--\nReturns `true` if the entire data was flushed successfully to the kernel\nbuffer. Returns `false` if all or part of the data was queued in user memory.\n`'drain'` will be emitted when the buffer is again free.\n-->\n\n<p>データ全体のカーネルバッファへのフラッシュが成功すると <code>true</code> を返します。\nデータ全体または一部がユーザメモリ内のキューに入れられた場合は <code>false</code> を返します。\n再びバッファが空いた場合は <code>'drain'</code> イベントが生成されます。\n\n</p>\n<!--\nThe optional `callback` parameter will be executed when the data is finally\nwritten out - this may not be immediately.\n-->\n\n<p>オプションの <code>callback</code> 引数はデータが最終的に出力された時に実行されます\n－ これはすぐには起きないでしょう。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.end([data], [encoding])",
              "type": "method",
              "name": "end",
              "desc": "<!--\nHalf-closes the socket. i.e., it sends a FIN packet. It is possible the\nserver will still send some data.\n-->\n\n<p>ソケットをハーフクローズします。例えば FIN パケットを送信します。\nサーバはまだデータを送り続けてくることができます。\n\n</p>\n<!--\nIf `data` is specified, it is equivalent to calling\n`socket.write(data, encoding)` followed by `socket.end()`.\n-->\n\n<p><code>data</code> が指定された場合は、\n<code>socket.write(data, encoding)</code> に続けて <code>socket.end()</code> を呼び出すのと等価です。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.destroy()",
              "type": "method",
              "name": "destroy",
              "desc": "<!--\nEnsures that no more I/O activity happens on this socket. Only necessary in\ncase of errors (parse error or so).\n-->\n\n<p>このソケット上でどんな I/O も起こらないことを保証します。\n(パースエラーなどの) エラーの場合にだけ必要です。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.pause()",
              "type": "method",
              "name": "pause",
              "desc": "<!--\nPauses the reading of data. That is, `'data'` events will not be emitted.\nUseful to throttle back an upload.\n-->\n\n<p>データの読み込みを中断します。つまり、<code>'data'</code> イベントは生成されません。\nアップロード速度を落とすために便利です。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.resume()",
              "type": "method",
              "name": "resume",
              "desc": "<!--\nResumes reading after a call to `pause()`.\n-->\n\n<p><code>pause()</code> を呼び出した後で読み込みを再開します。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.setTimeout(timeout, [callback])",
              "type": "method",
              "name": "setTimeout",
              "desc": "<!--\nSets the socket to timeout after `timeout` milliseconds of inactivity on\nthe socket. By default `net.Socket` do not have a timeout.\n-->\n\n<p>このソケットが非アクティブになってから <code>timeout</code> ミリ秒後にタイムアウト\nするように設定します。デフォルトでは <code>net.Socket</code> はタイムアウトしません。\n\n</p>\n<!--\nWhen an idle timeout is triggered the socket will receive a `'timeout'`\nevent but the connection will not be severed. The user must manually `end()`\nor `destroy()` the socket.\n-->\n\n<p>アイドルタイムアウトが引き起こされると、ソケットは <code>'timeout'</code> イベントを受信しますが、\nコネクションは切断されません。\nユーザは手動で <code>end()</code> または <code>destroy()</code> を呼び出す必要があります。\n\n</p>\n<!--\nIf `timeout` is 0, then the existing idle timeout is disabled.\n-->\n\n<p><code>timeout</code> が 0 の場合、アイドルタイムアウトは無効にされます。\n\n</p>\n<!--\nThe optional `callback` parameter will be added as a one time listener for the\n`'timeout'` event.\n-->\n\n<p>オプションの <code>callback</code> 引数は、<code>timeouot</code> イベントの一回限りのリスナを追加します。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "timeout"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.setNoDelay([noDelay])",
              "type": "method",
              "name": "setNoDelay",
              "desc": "<!--\nDisables the Nagle algorithm. By default TCP connections use the Nagle\nalgorithm, they buffer data before sending it off. Setting `true` for\n`noDelay` will immediately fire off data each time `socket.write()` is called.\n`noDelay` defaults to `true`.\n-->\n\n<p>Nagle アルゴリズムを無効にします。\nデフォルトでは TCP コネクションは Nagle アルゴリズムを使用し、データを送信する前にバッファリングします。\n<code>noDelay</code> に <code>true</code> を設定すると、データは <code>socket.write()</code>\nを呼び出す度に即座に送信されます。デフォルトは <code>true</code> です。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "noDelay",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.setKeepAlive([enable], [initialDelay])",
              "type": "method",
              "name": "setKeepAlive",
              "desc": "<!--\nEnable/disable keep-alive functionality, and optionally set the initial\ndelay before the first keepalive probe is sent on an idle socket.\n`enable` defaults to `false`.\n\nSet `initialDelay` (in milliseconds) to set the delay between the last\ndata packet received and the first keepalive probe. Setting 0 for\ninitialDelay will leave the value unchanged from the default\n(or previous) setting. Defaults to `0`.\n-->\n\n<p>キープアライブ機能を有効/無効にします。\nオプションで最初の keepalive probe がアイドルソケットに送信されるまでの初期遅延を設定します。\n<code>enable</code> のデフォルトは <code>false</code> です。\n\n</p>\n<p><code>initialDelay</code> (ミリ秒) が設定されると、\n最後にデータパケットを受信してから最初の keepalive probe までの遅延が設定されます。\n初期遅延に 0 が設定されると、デフォルト設定から値を変更されないようにします。\nデフォルトは <code>0</code> です。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "enable",
                      "optional": true
                    },
                    {
                      "name": "initialDelay",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.address()",
              "type": "method",
              "name": "address",
              "desc": "<!--\nReturns the bound address, the address family name and port of the\nsocket as reported by the operating system. Returns an object with\nthree properties, e.g.\n`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`\n-->\n\n<p>オペレーティングシステムから報告された、ソケットにバインドされたアドレスと\nアドレスファミリ名、ポートを返します。\n返されるオブジェクトは 3 つのプロパティを持ちます。例:\n<code>{ port: 12346, family: 'IPv4', address: '127.0.0.1' }</code>\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.unref()",
              "type": "method",
              "name": "unref",
              "desc": "<!--\nCalling `unref` on a socket will allow the program to exit if this is the only\nactive socket in the event system. If the socket is already `unref`d calling\n`unref` again will have no effect.\n-->\n\n<p>イベントシステムにおいて、このソケットだけがアクティブな場合にプログラムを\n終了することができるように、<code>unref</code> を呼び出します。\n既に <code>unref</code> されたソケットで再び <code>unref</code> が呼び出されても影響はありません。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.ref()",
              "type": "method",
              "name": "ref",
              "desc": "<!--\nOpposite of `unref`, calling `ref` on a previously `unref`d socket will *not*\nlet the program exit if it's the only socket left (the default behavior). If\nthe socket is `ref`d calling `ref` again will have no effect.\n-->\n\n<p><code>unref</code> とは逆に、以前に <code>unref</code> されたソケットが唯一残ったソケットになっても、\nプログラムが終了 (デフォルトの動作です) しないように、<code>ref</code> を呼び出します。\n既に <code>ref</code> されたソケットで再び <code>ref</code> が呼び出されても影響はありません。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "socket.bufferSize",
              "name": "bufferSize",
              "desc": "<!--\n`net.Socket` has the property that `socket.write()` always works. This is to\nhelp users get up and running quickly. The computer cannot always keep up\nwith the amount of data that is written to a socket - the network connection\nsimply might be too slow. Node will internally queue up the data written to a\nsocket and send it out over the wire when it is possible. (Internally it is\npolling on the socket's file descriptor for being writable).\n\nThe consequence of this internal buffering is that memory may grow. This\nproperty shows the number of characters currently buffered to be written.\n(Number of characters is approximately equal to the number of bytes to be\nwritten, but the buffer may contain strings, and the strings are lazily\nencoded, so the exact number of bytes is not known.)\n\nUsers who experience large or growing `bufferSize` should attempt to\n\"throttle\" the data flows in their program with `pause()` and `resume()`.\n-->\n\n<p><code>net.Socket</code> には、<code>socket.write()</code> と常に協調するプロパティがあります。\nこれはユーザが実行速度を向上させる手助けになります。\nコンピュータは、ソケットに書き込まれるデータ量についていくことはできません。\n- ネットワーク接続は、単純に遅すぎます。\nNode は、ソケットに書き込まれるデータを内部のキューに入れ、可能になった時にワイヤ上に送信します (内部ではソケットのファイル記述子が書き込み可能になるのをポーリングします)。\n\n</p>\n<p>内部的なバッファリングの結果、メモリ消費が増大するかもしれません。\nこのプロパティは、現在書き込みのためにバッファリングされている文字数を示します。\n(文字数は書き込まれるバイト数とほぼ同じですが、バッファが文字列を含んでいる場合、文字列は遅延的にエンコードされるため、正確なバイト数は分かっていません)\n\n</p>\n<p>大きな、あるいは増大する <code>bufferSize</code> を体験したユーザは、そのプログラムで <code>pause()</code> および <code>resume()</code> を使ってデータフローを「抑えよう」としなければなりません。\n\n</p>\n"
            },
            {
              "textRaw": "socket.remoteAddress",
              "name": "remoteAddress",
              "desc": "<!--\nThe string representation of the remote IP address. For example,\n`'74.125.127.100'` or `'2001:4860:a005::68'`.\n-->\n\n<p>リモートの IP アドレスを表現する文字列です。\n例えば、<code>'74.125.127.100'</code> あるいは <code>'2001:4860:a005::68'</code>。\n\n</p>\n<!--\nThis member is only present in server-side connections.\n-->\n\n<p>このメンバはサーバサイドのコネクションにのみ与えられます。\n\n</p>\n"
            },
            {
              "textRaw": "socket.remotePort",
              "name": "remotePort",
              "desc": "<!--\nThe numeric representation of the remote port. For example,\n`80` or `21`.\n-->\n\n<p>リモートポートの数値表現です。\nたとえば、<code>80</code> や <code>21</code>。\n\n</p>\n"
            },
            {
              "textRaw": "socket.localAddress",
              "name": "localAddress",
              "desc": "<!--\nThe string representation of the local IP address the remote client is\nconnecting on. For example, if you are listening on `'0.0.0.0'` and the\nclient connects on `'192.168.1.1'`, the value would be `'192.168.1.1'`.\n-->\n\n<p>リモートクライアントが接続しているローカル IP アドレスを表現する文字列です。\nたとえば、 <code>'0.0.0.0'</code> をリッスンしていて、クライアントが <code>'192.168.1.1'</code>\nに接続した場合、この値は <code>'192.168.1.1'</code> になります。\n\n</p>\n"
            },
            {
              "textRaw": "socket.localPort",
              "name": "localPort",
              "desc": "<!--\nThe numeric representation of the local port. For example,\n`80` or `21`.\n-->\n\n<p>ローカルポートの数値表現です。\nたとえば、<code>80</code> や <code>21</code>。\n\n</p>\n"
            },
            {
              "textRaw": "socket.bytesRead",
              "name": "bytesRead",
              "desc": "<!--\nThe amount of received bytes.\n-->\n\n<p>受信したバイトの合計です。\n\n</p>\n"
            },
            {
              "textRaw": "socket.bytesWritten",
              "name": "bytesWritten",
              "desc": "<!--\nThe amount of bytes sent.\n-->\n\n<p>送信したバイトの合計です。\n\n</p>\n<!--\n`net.Socket` instances are [EventEmitter][] with the following events:\n-->\n\n<p><code>net.Socket</code> のインスタンスは以下のイベントを持つ [EventEmitter][] です:\n\n</p>\n"
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'connect'",
              "type": "event",
              "name": "connect",
              "desc": "<!--\nEmitted when a socket connection is successfully established.\nSee `connect()`.\n-->\n\n<p>ソケットコネクションの確立が成功した場合に生成されます。\n<code>connect()</code> を参照してください。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'data'",
              "type": "event",
              "name": "data",
              "params": [],
              "desc": "<!--\nEmitted when data is received.  The argument `data` will be a `Buffer` or\n`String`.  Encoding of data is set by `socket.setEncoding()`.\n(See the [Readable Stream][] section for more information.)\n\nNote that the __data will be lost__ if there is no listener when a `Socket`\nemits a `'data'` event.\n-->\n\n<p>データを受信した場合に生成されます。\n<code>data</code> 引数は <code>Buffer</code> または <code>String</code> です。\nデータのエンコーディングは <code>socket.setEncoding()</code> で設定されます。\n(より詳しい情報は [Readable Stream][] を参照してください)。\n\n</p>\n<p><code>Socket</code> が <code>'data'</code> イベントを生成した時にリスナが存在しなければ、\n<strong>データは失われる</strong>ことに注意してください。\n\n</p>\n"
            },
            {
              "textRaw": "Event: 'end'",
              "type": "event",
              "name": "end",
              "desc": "<!--\nEmitted when the other end of the socket sends a FIN packet.\n-->\n\n<p>ソケットの相手側が FIN パケットを送信した場合に生成されます。\n\n</p>\n<p>デフォルト (<code>allowHalfOpen == false</code>) では、\n保留されていた書き込みキューが出力されるとソケットはファイル識別子を破棄します。\nしかし、<code>allowHalfOpen == true</code> が設定されていると、\nユーザがデータを書き込めるようにしておくために、ソケットは自動的に <code>end()</code> を呼び出さないので、\nユーザが <code>end()</code> を呼び出す必要があります。\n\n\n</p>\n",
              "By default (`allowHalfOpen": "= false`) the socket will destroy its file\ndescriptor  once it has written out its pending write queue.  However, by\nsetting `allowHalfOpen == true` the socket will not automatically `end()`\nits side allowing the user to write arbitrary amounts of data, with the\ncaveat that the user is required to `end()` their side now.",
              "params": []
            },
            {
              "textRaw": "Event: 'timeout'",
              "type": "event",
              "name": "timeout",
              "desc": "<!--\nEmitted if the socket times out from inactivity. This is only to notify that\nthe socket has been idle. The user must manually close the connection.\n\nSee also: `socket.setTimeout()`\n-->\n\n<p>ソケットがタイムアウトして非アクティブになった場合に生成されます。\nこれはソケットがアイドルになったことを通知するだけです。\n利用者は手動でコネクションをクローズする必要があります。\n\n</p>\n<p><code>socket.setTimeout()</code> を参照してください。\n\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'drain'",
              "type": "event",
              "name": "drain",
              "desc": "<!--\nEmitted when the write buffer becomes empty. Can be used to throttle uploads.\n\nSee also: the return values of `socket.write()`\n-->\n\n<p>書き込みバッファが空になった場合に生成されます。アップロード速度を落とすために使うことができます。\n\n</p>\n<p><code>socket.write()</code> の戻り値を参照してください。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "params": [],
              "desc": "<!--\nEmitted when an error occurs.  The `'close'` event will be called directly\nfollowing this event.\n-->\n\n<p>エラーが発生した場合に生成されます。<code>'close'</code> イベントはこのイベントの後に直接呼び出されます。\n\n</p>\n"
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<!--\n* `had_error` {Boolean} true if the socket had a transmission error\n-->\n\n<ul>\n<li><code>had_error</code> {Boolean} ソケットで転送エラーが発生した場合は true です。</li>\n</ul>\n<!--\nEmitted once the socket is fully closed. The argument `had_error` is a boolean\nwhich says if the socket was closed due to a transmission error.\n-->\n\n<p>ソケットが完全にクローズした場合に生成されます。\n引数 <code>had_error</code> は boolean で、ソケットが転送エラーでクローズされたのかどうかを示します。\n\n</p>\n",
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "net"
    },
    {
      "textRaw": "UDP / Datagram Sockets",
      "name": "dgram",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<!--\nDatagram sockets are available through `require('dgram')`.\n-->\n\n<p>データグラムソケットは <code>require('dgram')</code> で利用可能になります。\n\n</p>\n<!--\nImportant note: the behavior of `dgram.Socket#bind()` has changed in v0.10\nand is always asynchronous now.  If you have code that looks like this:\n-->\n\n<p>重要な注意: <code>dgram.Socket#bind()</code> の振る舞いは v0.10 で変更され、\nそれは常に非同期になりました。\nもし次のようなコードがあると:\n\n</p>\n<pre><code>var s = dgram.createSocket('udp4');\ns.bind(1234);\ns.addMembership('224.0.0.114');</code></pre>\n<!--\nYou have to change it to this:\n-->\n\n<p>これは次のように変更されなければなりません。\n\n</p>\n<pre><code>var s = dgram.createSocket('udp4');\ns.bind(1234, function() {\n  s.addMembership('224.0.0.114');\n});</code></pre>\n",
      "methods": [
        {
          "textRaw": "dgram.createSocket(type, [callback])",
          "type": "method",
          "name": "createSocket",
          "desc": "<!--\n* `type` String. Either 'udp4' or 'udp6'\n* `callback` Function. Attached as a listener to `message` events.\n  Optional\n* Returns: Socket object\n-->\n\n<ul>\n<li><code>type</code> String. 'udp4' または 'udp6' のいずれか</li>\n<li><code>callback</code> Function. <code>'message'</code> イベントのリスナとして割り当てられる、\nOptional</li>\n<li>Returns: Socket object</li>\n</ul>\n<!--\nCreates a datagram Socket of the specified types.  Valid types are `udp4`\nand `udp6`.\n\nTakes an optional callback which is added as a listener for `message` events.\n\nCall `socket.bind` if you want to receive datagrams. `socket.bind()` will bind\nto the \"all interfaces\" address on a random port (it does the right thing for\nboth `udp4` and `udp6` sockets). You can then retrieve the address and port\nwith `socket.address().address` and `socket.address().port`.\n-->\n\n<p>指定された種類のデータグラムソケットを作成します。\n妥当な種類は <code>udp4</code> と <code>udp6</code>です。\n\n</p>\n<p>オプションのコールバックは <code>message</code> イベントのリスナーとして加えられます。\n\n</p>\n<p>データグラムを受信したい場合は <code>socket.bind()</code> を呼び出します。\n<code>socket.bind()</code> は「全てのインタフェース」のアドレスにランダムなポート\n(<code>udp4</code> と <code>udp6</code> ソケットの両方で正しいものです) をバインドします。\nそのアドレスとポートは <code>socket.address().address</code> および\n<code>socket.address().port</code> で取得することができます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "type"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: dgram.Socket",
          "type": "class",
          "name": "dgram.Socket",
          "desc": "<!--\nThe dgram Socket class encapsulates the datagram functionality.  It\nshould be created via `dgram.createSocket(type, [callback])`.\n-->\n\n<p>dgram Scoket クラスはデータグラム機能をカプセル化します。\nそれは <code>dgram.createSocket(type, [callback])</code> を通じて生成されます。\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'message'",
              "type": "event",
              "name": "message",
              "desc": "<!--\n* `msg` Buffer object. The message\n* `rinfo` Object. Remote address information\n-->\n\n<ul>\n<li><code>msg</code> Buffer object. メッセージ</li>\n<li><code>rinfo</code> Object. リモートアドレスの情報</li>\n</ul>\n<!--\nEmitted when a new datagram is available on a socket.  `msg` is a `Buffer` and `rinfo` is\nan object with the sender's address information and the number of bytes in the datagram.\n-->\n\n<p>ソケット上で新しいデータグラムが到着した時に生成されます。<code>msg</code> は <code>Buffer</code> で、\n<code>rinfo</code> は送信者のアドレス情報とデータグラムのバイト数を持ったオブジェクトです。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'listening'",
              "type": "event",
              "name": "listening",
              "desc": "<!--\nEmitted when a socket starts listening for datagrams.  This happens as soon as UDP sockets\nare created.\n-->\n\n<p>ソケットでデータグラムの待ち受けを開始すると生成されます。\nこれは UDP ソケットが作成されるとすぐに発生します。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<!--\nEmitted when a socket is closed with `close()`.  No new `message` events will be emitted\non this socket.\n-->\n\n<p><code>close()</code> によってソケットがクローズすると生成されます。\nこのソケットでは新しい <code>message</code> イベントは生成されなくなります。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "params": [],
              "desc": "<!--\nEmitted when an error occurs.\n-->\n\n<p>エラーが発生すると生成されます。\n\n</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "socket.send(buf, offset, length, port, address, [callback])",
              "type": "method",
              "name": "send",
              "desc": "<!--\n* `buf` Buffer object.  Message to be sent\n* `offset` Integer. Offset in the buffer where the message starts.\n* `length` Integer. Number of bytes in the message.\n* `port` Integer. Destination port.\n* `address` String. Destination hostname or IP address.\n* `callback` Function. Called when the message has been sent. Optional.\n-->\n\n<ul>\n<li><code>buf</code> Buffer オブジェクト送信されるメッセージ。</li>\n<li><code>offset</code> 整数。メッセージの開始位置となるバッファ内のオフセット。</li>\n<li><code>length</code> 整数。メッセージのバイト長。</li>\n<li><code>port</code> 整数。接続先のポート番号。</li>\n<li><code>address</code> 文字列。接続先のホスト名または IP アドレス。</li>\n<li><code>callback</code> 関数。メッセージが送信されるとコールバックされる。任意。</li>\n</ul>\n<!--\nFor UDP sockets, the destination port and address must be specified.  A string\nmay be supplied for the `address` parameter, and it will be resolved with DNS.\n-->\n\n<p>UDP ソケットに対しては、相手先のポートとアドレスは必ず指定しなければなりません。\n<code>address</code> パラメータに文字列を提供すると、それは DNS によって解決されます。\n\n</p>\n<!--\nIf the address is omitted or is an empty string, `'0.0.0.0'` or `'::0'` is used\ninstead.  Depending on the network configuration, those defaults may or may not\nwork; it's best to be explicit about the destination address.\n-->\n\n<p>アドレスが省略された場合や空文字列だった場合は、代わりに <code>'0.0.0.0'</code> または\n<code>'::0'</code> が使われます。ネットワークの構成によっては、これらのデフォルト値は\n動作したりしなかったりします; 相手先のアドレスは明示的に指定することが最適です。\n\n</p>\n<!--\nIf the socket has not been previously bound with a call to `bind`, it gets\nassigned a random port number and is bound to the \"all interfaces\" address\n(`'0.0.0.0'` for `udp4` sockets, `'::0'` for `udp6` sockets.)\n-->\n\n<p>ソケットが以前に <code>bind</code> の呼び出しによってバインドされていない場合は、\nランダムなポート番号が「全てのインタフェース」アドレスに対してバインドされます\n(<code>udp4</code> ソケットでは 0.0.0.0、<code>udp6</code> では ::0)。\n\n</p>\n<!--\nAn optional callback may be specified to detect DNS errors or for determining\nwhen it's safe to reuse the `buf` object.  Note that DNS lookups delay the time\nto send for at least one tick.  The only way to know for sure that the datagram\nhas been sent is by using a callback.\n-->\n\n<p>DNS におけるエラー検出と、<code>buf</code> が再利用可能になったことを安全に知るために、\nオプションのコールバックを指定することができます。\nDNS ルックアップは送信を少なくとも次のイベントループまで遅らせることに\n注意してください。\nデータグラムの送信が行われたことを確実に知る唯一の手段は、\nコールバックを使うことです。\n\n</p>\n<!--\nExample of sending a UDP packet to a random port on `localhost`;\n-->\n\n<p><code>localhost</code> の適当なポートに UDP パケットを送信する例;\n\n</p>\n<pre><code>var dgram = require('dgram');\nvar message = new Buffer("Some bytes");\nvar client = dgram.createSocket("udp4");\nclient.send(message, 0, message.length, 41234, "localhost", function(err, bytes) {\n  client.close();\n});</code></pre>\n<!--\n**A Note about UDP datagram size**\n\nThe maximum size of an `IPv4/v6` datagram depends on the `MTU` (_Maximum Transmission Unit_)\nand on the `Payload Length` field size.\n\n- The `Payload Length` field is `16 bits` wide, which means that a normal payload\n  cannot be larger than 64K octets including internet header and data\n  (65,507 bytes = 65,535 − 8 bytes UDP header − 20 bytes IP header);\n  this is generally true for loopback interfaces, but such long datagrams\n  are impractical for most hosts and networks.\n\n- The `MTU` is the largest size a given link layer technology can support for datagrams.\n  For any link, `IPv4` mandates a minimum `MTU` of `68` octets, while the recommended `MTU`\n  for IPv4 is `576` (typically recommended as the `MTU` for dial-up type applications),\n  whether they arrive whole or in fragments.\n\n  For `IPv6`, the minimum `MTU` is `1280` octets, however, the mandatory minimum\n  fragment reassembly buffer size is `1500` octets.\n  The value of `68` octets is very small, since most current link layer technologies have\n  a minimum `MTU` of `1500` (like Ethernet).\n\nNote that it's impossible to know in advance the MTU of each link through which\na packet might travel, and that generally sending a datagram greater than\nthe (receiver) `MTU` won't work (the packet gets silently dropped, without\ninforming the source that the data did not reach its intended recipient).\n-->\n\n<p><strong>UDP データグラムのサイズについて</strong>\n\n</p>\n<p><code>IPv4/v6</code> データグラムの最大のサイズは <code>MTU</code> (<em>Maximum Transmission Unit</em>) と、\n<code>Payload Length</code> フィールドサイズに依存します。\n\n</p>\n<ul>\n<li><p><code>Payload Length</code> フィールドサイズは 16bit 長で、これは通常のペイロードが\nIP ヘッダとデータ含めて 64K オクテットより長くなれないことを意味します\n(65,507 バイト = 65,535 − 8 バイトの UDP ヘッダ − 20 バイトの IP ヘッダ);\nこれは一般的にループバックインタフェースでは正しいものの、\nほとんどのホストとネットワークにとって長大なデータグラムは\n現実的ではありません。</p>\n</li>\n<li><p><code>MTU</code> はリンク層により大きなサイズを与える技術で、\nデータグラムもサポートできます。\nどんなリンクでも、それらが全体として到着するか断片化されるかに関わらず、\n<code>IPv4</code> は最低 <code>69</code> オクテット必要で、推奨される <code>IPv4</code> の <code>MTU</code> は <code>576</code> です\n(典型的なダイヤルアップ型アプリケーションの <code>MUT</code> 推奨値)。</p>\n<p><code>IPv6</code> では最小の <code>MTU</code> は <code>1280</code> オクテットですが、フラグメントを再構築する\nバッファサイズは最低 <code>1500</code> オクテットが必要です。\n<code>68</code> オクテットはとても小さいので、もっとも現代的なリンク層技術では、\n最小の <code>MTU</code> は <code>1500</code> です (イーサネットと同じです)。</p>\n</li>\n</ul>\n<p>パケットが通過する各リンクの MTU をあらかじめ知ることは\nできないこと、(受信側の) <code>MTU</code> より大きなデータグラムを送信しても\n通常は動作しないことに注意してください\n(パケットは送り主に知らされることなく黙って捨てられ、\n意図した受信者に到達することはありません)。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "buf"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "length"
                    },
                    {
                      "name": "port"
                    },
                    {
                      "name": "address"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.bind(port, [address], [callback])",
              "type": "method",
              "name": "bind",
              "desc": "<!--\n* `port` Integer\n* `address` String, Optional\n* `callback` Function with no parameters, Optional. Callback when\n  binding is done.\n-->\n\n<ul>\n<li><code>port</code> Integer</li>\n<li><code>address</code> String、任意</li>\n<li><code>callback</code> 引数のない関数、任意。バインディングが終了した時に\nコールバックされます。</li>\n</ul>\n<!--\nFor UDP sockets, listen for datagrams on a named `port` and optional\n`address`. If `address` is not specified, the OS will try to listen on\nall addresses.  After binding is done, a \"listening\" event is emitted\nand the `callback`(if specified) is called. Specifying both a\n\"listening\" event listener and `callback` is not harmful but not very\nuseful.\n-->\n\n<p>UDP ソケットに対して、<code>port</code> とオプションの <code>address</code> でデータグラムを\n待ち受けます。\n<code>address</code> が指定されなければ、OS は全てのアドレスからの待ち受けを試みます。\nバインディングが完了すると、<code>'listening'</code> イベントが生成され、\n(もし指定されていれば) <code>callback</code> が呼び出されます。\n<code>'listening'</code> イベントリスナと <code>callback</code> の両方を指定しても有害ではありませんが\nあまり役には立ちません。\n\n</p>\n<!--\nA bound datagram socket keeps the node process running to receive\ndatagrams.\n-->\n\n<p>束縛されたデータグラムソケットはデータグラムを受信するために node プロセスの\n実行を維持し続けます。\n\n</p>\n<!--\nIf binding fails, an \"error\" event is generated. In rare case (e.g.\nbinding a closed socket), an `Error` may be thrown by this method.\n-->\n\n<p>バインディングが失敗すると、<code>'error'</code> イベントが生成されます。\nまれなケース (たとえばクローズしたソケットへのバインディング) では、\nこのメソッドは <code>Error</code> をスローすることがあります。\n\n</p>\n<!--\nExample of a UDP server listening on port 41234:\n-->\n\n<p>41234 番ポートを待ち受ける UDP サーバの例:\n\n</p>\n<pre><code>var dgram = require("dgram");\n\nvar server = dgram.createSocket("udp4");\n\nserver.on("error", function (err) {\n  console.log("server error:\\n" + err.stack);\n  server.close();\n});\n\nserver.on("message", function (msg, rinfo) {\n  console.log("server got: " + msg + " from " +\n    rinfo.address + ":" + rinfo.port);\n});\n\nserver.on("listening", function () {\n  var address = server.address();\n  console.log("server listening " +\n      address.address + ":" + address.port);\n});\n\nserver.bind(41234);\n// server listening 0.0.0.0:41234</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "address",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "socket.close()",
              "type": "method",
              "name": "close",
              "desc": "<!--\nClose the underlying socket and stop listening for data on it.\n-->\n\n<p>下層のソケットをクローズし、データの待ち受けを終了します。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.address()",
              "type": "method",
              "name": "address",
              "desc": "<!--\nReturns an object containing the address information for a socket.  For UDP sockets,\nthis object will contain `address` , `family` and `port`.\n-->\n\n<p>オブジェクトが持っているソケットのアドレス情報を返します。\nこのオブジェクトは <code>address</code>、<code>port</code>、そして <code>family</code> を持っています。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.setBroadcast(flag)",
              "type": "method",
              "name": "setBroadcast",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`flag` Boolean ",
                      "name": "flag",
                      "desc": "Boolean"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "flag"
                    }
                  ]
                }
              ],
              "desc": "<!--\nSets or clears the `SO_BROADCAST` socket option.  When this option is set, UDP packets\nmay be sent to a local interface's broadcast address.\n-->\n\n<p>ソケットのオプション <code>SO_BROADCAST</code> を設定またはクリアします。\nこのオプションが設定されると、UDP パケットはローカルインタフェースのブロードキャスト用アドレスに送信されます。\n\n</p>\n"
            },
            {
              "textRaw": "socket.setTTL(ttl)",
              "type": "method",
              "name": "setTTL",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`ttl` Integer ",
                      "name": "ttl",
                      "desc": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "ttl"
                    }
                  ]
                }
              ],
              "desc": "<!--\nSets the `IP_TTL` socket option.  TTL stands for \"Time to Live,\" but in this context it\nspecifies the number of IP hops that a packet is allowed to go through.  Each router or\ngateway that forwards a packet decrements the TTL.  If the TTL is decremented to 0 by a\nrouter, it will not be forwarded.  Changing TTL values is typically done for network\nprobes or when multicasting.\n-->\n\n<p>ソケットオプションの <code>IP_TTL</code> を設定します。\nTTL は「生存期間」を表しますが、このコンテキストではパケットが通過を許可される IP のホップ数を指定します。\n各ルータまたはゲートウェイはパケットを送出する際 TTL をデクリメントします。\nルータによって TTL がデクリメントされて 0 になるとそれは送出されません。\nTTL 値の変更は通常、ネットワークの調査やマルチキャストで使われます。\n\n</p>\n<!--\nThe argument to `setTTL()` is a number of hops between 1 and 255.  The default on most\nsystems is 64.\n-->\n\n<p><code>setTTL()</code> の引数は 1 から 255 のホップ数でです。ほとんどのシステムでデフォルトは 64 です。\n\n</p>\n"
            },
            {
              "textRaw": "socket.setMulticastTTL(ttl)",
              "type": "method",
              "name": "setMulticastTTL",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`ttl` Integer ",
                      "name": "ttl",
                      "desc": "Integer"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "ttl"
                    }
                  ]
                }
              ],
              "desc": "<!--\nSets the `IP_MULTICAST_TTL` socket option.  TTL stands for \"Time to Live,\" but in this\ncontext it specifies the number of IP hops that a packet is allowed to go through,\nspecifically for multicast traffic.  Each router or gateway that forwards a packet\ndecrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded.\n\nThe argument to `setMulticastTTL()` is a number of hops between 0 and 255.  The default on most\nsystems is 1.\n-->\n\n<p><code>IP_MULTICAST_TTL</code> ソケットオプションを設定します。\nTTL は「生存期間」を表しますが、この文脈では特にマルチキャストのトラフィックにおいてパケットが通過できるIPホップの数を指定します。\nそれぞれのルーターまたはゲートウェイは、パケットを転送する際に TTL をデクリメントします。\nTTL がルーターによって 0 までデクリメントされると、それは転送されません。\n<code>setMulticastTTL()</code> の引数はホップを表す数値で、0 から 255 の間です。\nほとんどのシステムでデフォルトは 1 です。\n\n</p>\n"
            },
            {
              "textRaw": "socket.setMulticastLoopback(flag)",
              "type": "method",
              "name": "setMulticastLoopback",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`flag` Boolean ",
                      "name": "flag",
                      "desc": "Boolean"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "flag"
                    }
                  ]
                }
              ],
              "desc": "<!--\nSets or clears the `IP_MULTICAST_LOOP` socket option.  When this option is set, multicast\npackets will also be received on the local interface.\n-->\n\n<p><code>IP_MULTICAST_LOOP</code> ソケットオプションを設定またはクリアします。\nこのオプションが設定されると、マルチキャストのパケットはローカルインタフェースでも受信できるようになります。\n\n</p>\n"
            },
            {
              "textRaw": "socket.addMembership(multicastAddress, [multicastInterface])",
              "type": "method",
              "name": "addMembership",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`multicastAddress` String ",
                      "name": "multicastAddress",
                      "desc": "String"
                    },
                    {
                      "textRaw": "`multicastInterface` String, Optional ",
                      "name": "multicastInterface",
                      "optional": true,
                      "desc": "String"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "multicastAddress"
                    },
                    {
                      "name": "multicastInterface",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nTells the kernel to join a multicast group with `IP_ADD_MEMBERSHIP` socket option.\n\nIf `multicastInterface` is not specified, the OS will try to add membership to all valid\ninterfaces.\n-->\n\n<p><code>IP_ADD_MEMBERSHIP</code> ソケットオプションを設定し、マルチキャストグループに参加することをカーネルに伝えます。\n\n</p>\n<p><code>multicastInterface</code> が指定されなかった場合は、全ての妥当なインタフェースをメンバーシップに加えようとします。\n\n</p>\n"
            },
            {
              "textRaw": "socket.dropMembership(multicastAddress, [multicastInterface])",
              "type": "method",
              "name": "dropMembership",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`multicastAddress` String ",
                      "name": "multicastAddress",
                      "desc": "String"
                    },
                    {
                      "textRaw": "`multicastInterface` String, Optional ",
                      "name": "multicastInterface",
                      "optional": true,
                      "desc": "String"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "multicastAddress"
                    },
                    {
                      "name": "multicastInterface",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nOpposite of `addMembership` - tells the kernel to leave a multicast group with\n`IP_DROP_MEMBERSHIP` socket option. This is automatically called by the kernel\nwhen the socket is closed or process terminates, so most apps will never need to call\nthis.\n\nIf `multicastInterface` is not specified, the OS will try to drop membership to all valid\ninterfaces.\n-->\n\n<p><code>addMembership</code> の反対です - <code>IP_DROP_MEMBERSHIP</code> ソケットオプションによって、マルチキャストグループから抜けることをカーネルに伝えます。\nこれはソケットのクローズ時やプロセスの終了時にカーネルによって自動的に呼び出されるため、ほとんどのアプリケーションはこれを呼び出す必要がありません。\n\n</p>\n<p><code>multicastInterface</code> が指定されなかった場合は、全ての妥当なインタフェースをメンバーシップから削除しようとします。\n\n</p>\n"
            },
            {
              "textRaw": "socket.unref()",
              "type": "method",
              "name": "unref",
              "desc": "<!--\nCalling `unref` on a socket will allow the program to exit if this is the only\nactive socket in the event system. If the socket is already `unref`d calling\n`unref` again will have no effect.\n-->\n\n<p>イベントシステムにおいて、このソケットだけがアクティブな場合にプログラムを\n終了することができるように、<code>unref</code> を呼び出します。\n既に <code>unref</code> されたソケットで再び <code>unref</code> が呼び出されても影響はありません。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "socket.ref()",
              "type": "method",
              "name": "ref",
              "desc": "<!--\nOpposite of `unref`, calling `ref` on a previously `unref`d socket will *not*\nlet the program exit if it's the only socket left (the default behavior). If\nthe socket is `ref`d calling `ref` again will have no effect.\n-->\n\n<p><code>unref</code> とは逆に、以前に <code>unref</code> されたソケットが唯一残ったソケットになっても、\nプログラムが終了 (デフォルトの動作です) しないように、<code>ref</code> を呼び出します。\n既に <code>ref</code> されたソケットで再び <code>ref</code> が呼び出されても影響はありません。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "dgram"
    },
    {
      "textRaw": "DNS",
      "name": "dns",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<!--\nUse `require('dns')` to access this module. All methods in the dns module\nuse C-Ares except for `dns.lookup` which uses `getaddrinfo(3)` in a thread\npool. C-Ares is much faster than `getaddrinfo` but the system resolver is\nmore consistent with how other programs operate. When a user does\n`net.connect(80, 'google.com')` or `http.get({ host: 'google.com' })` the\n`dns.lookup` method is used. Users who need to do a large number of lookups\nquickly should use the methods that go through C-Ares.\n-->\n\n<p>このモジュールにアクセスするには <code>require('dns')</code> を使用します。\ndns モジュールの全てのメソッドは C-Ares を使用します。\nただし、<code>dns.lookup</code> はスレッドプール上で <code>getaddrinfo(3)</code> を使用します。\nC-Ares は <code>getaddrinfo</code> よりずっと速いものの、\n他のシステムと連携するにはシステムリゾルバの方が一貫しています。\nユーザが <code>net.connect(80, 'google.com')</code> または\n<code>http.get({ host: 'google.com' })</code> を行った時、<code>dns.lookup</code>\nメソッドが使われます。\n多数のルックアップを素早く実行したいユーザは、\nC-Ares を呼び出すメソッドを使用すべきです。\n\n</p>\n<!--\nHere is an example which resolves `'www.google.com'` then reverse\nresolves the IP addresses which are returned.\n-->\n\n<p>これは <code>'www.google.com'</code> を解決して、返された IP アドレスを逆引きで解決する例です。\n\n</p>\n<pre><code>var dns = require('dns');\n\ndns.resolve4('www.google.com', function (err, addresses) {\n  if (err) throw err;\n\n  console.log('addresses: ' + JSON.stringify(addresses));\n\n  addresses.forEach(function (a) {\n    dns.reverse(a, function (err, domains) {\n      if (err) {\n        throw err;\n      }\n\n      console.log('reverse for ' + a + ': ' + JSON.stringify(domains));\n    });\n  });\n});</code></pre>\n",
      "methods": [
        {
          "textRaw": "dns.lookup(domain, [family], callback)",
          "type": "method",
          "name": "lookup",
          "desc": "<!--\nResolves a domain (e.g. `'google.com'`) into the first found A (IPv4) or\nAAAA (IPv6) record.\nThe `family` can be the integer `4` or `6`. Defaults to `null` that indicates\nboth Ip v4 and v6 address family.\n-->\n\n<p>ドメイン (例 <code>'google.com'</code>) を解決して最初に見つかった\nA (IPv4) または AAAA (IPv6) レコードにします。\n<code>family</code> は整数の <code>4</code> または <code>6</code> を指定することができます。\nデフォルトは <code>null</code> で、IP v4 と v6 の両方をアドレスファミリーを意味します。\n\n</p>\n<!--\nThe callback has arguments `(err, address, family)`.  The `address` argument\nis a string representation of a IP v4 or v6 address. The `family` argument\nis either the integer 4 or 6 and denotes the family of `address` (not\nnecessarily the value initially passed to `lookup`).\n-->\n\n<p>コールバックは引数 <code>(err, address, family)</code> を持ちます。\n<code>address</code> 引数は IP v4 または v6 アドレスを表現する文字列です。\n<code>family</code> 引数は整数の 4 または 6 で、<code>address</code> のファミリーを意味します\n(この値は必ずしも最初に <code>lookup</code> に渡す必要はありません)。\n\n</p>\n<!--\nOn error, `err` is an `Error` object, where `err.code` is the error code.\nKeep in mind that `err.code` will be set to `'ENOENT'` not only when\nthe domain does not exist but also when the lookup fails in other ways\nsuch as no available file descriptors.\n-->\n\n<p>エラー時、<code>err</code> は <code>Error</code> オブジェクトで、<code>err.code</code> はエラーコードです。\n<code>err.code</code> が <code>'ENOENT'</code> に設定されるのはドメインが存在しない場合だけではなく、\nファイル記述子が使えないなどルックアップが失敗した場合もあることに\n注意してください。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "family",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolve(domain, [rrtype], callback)",
          "type": "method",
          "name": "resolve",
          "desc": "<!--\nResolves a domain (e.g. `'google.com'`) into an array of the record types\nspecified by rrtype. Valid rrtypes are `'A'` (IPV4 addresses, default),\n`'AAAA'` (IPV6 addresses), `'MX'` (mail exchange records), `'TXT'` (text\nrecords), `'SRV'` (SRV records), `'PTR'` (used for reverse IP lookups),\n`'NS'` (name server records) and `'CNAME'` (canonical name records).\n-->\n\n<p>ドメイン (例 <code>'google.com'</code>) を解決して <code>rrtype</code> で指定されたレコードタイプの配列にします。\n妥当な <code>rrtype</code> は <code>'A'</code> (IPV4アドレス)、<code>'AAAA'</code> (IPV6アドレス)、\n<code>'MX'</code> (mail exchangeレコード), <code>'TXT'</code> (テキストレコード)、\n<code>'SRV'</code> (SRVレコード)、<code>'PTR'</code> (IP を逆引きでルックアップするために使われる)、\n<code>'NS'</code> (ネームサーバレコード)、そして <code>'CNAME'</code> (別名レコード) です。\n\n</p>\n<!--\nThe callback has arguments `(err, addresses)`.  The type of each item\nin `addresses` is determined by the record type, and described in the\ndocumentation for the corresponding lookup methods below.\n-->\n\n<p>コールバックは引数 <code>(err, addresses)</code> を持ちます。\n<code>addresses</code> の各要素の種類はレコードの種類によって決まり、\n対応する後述のルックアップメソッドで記述されます。\n\n</p>\n<!--\nOn error, `err` is an `Error` object, where `err.code` is\none of the error codes listed below.\n-->\n\n<p>エラー時、<code>err</code> は <code>Error</code> オブジェクトで、\n<code>err.errno</code> は後述するエラーコードのいずれかです。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "rrtype",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolve4(domain, callback)",
          "type": "method",
          "name": "resolve4",
          "desc": "<!--\nThe same as `dns.resolve()`, but only for IPv4 queries (`A` records).\n`addresses` is an array of IPv4 addresses (e.g.\n`['74.125.79.104', '74.125.79.105', '74.125.79.106']`).\n-->\n\n<p><code>dns.resolve()</code> と同じですが、IPv4 アドレス (<code>A</code> レコード) だけを問い合わせます。\n<code>addresses</code> は IPv4 アドレスの配列です (例<br>\n<code>['74.125.79.104', '74.125.79.105', '74.125.79.106']</code>)\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolve6(domain, callback)",
          "type": "method",
          "name": "resolve6",
          "desc": "<!--\nThe same as `dns.resolve4()` except for IPv6 queries (an `AAAA` query).\n-->\n\n<p>IPv6 (<code>AAAA</code> レコード) を問い合わせることを除いて <code>dns.resolve4()</code> と同じです。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveMx(domain, callback)",
          "type": "method",
          "name": "resolveMx",
          "desc": "<!--\nThe same as `dns.resolve()`, but only for mail exchange queries (`MX` records).\n-->\n\n<p><code>dns.resolve()</code> と同じですが、mail exchange (<code>MX</code> レコード) だけを問い合わせます。\n\n</p>\n<!--\n`addresses` is an array of MX records, each with a priority and an exchange\nattribute (e.g. `[{'priority': 10, 'exchange': 'mx.example.com'},...]`).\n-->\n\n<p><code>addresses</code> は MX レコードの配列で、それぞれは priority と exchange の属性を持ちます\n(例 <code>[{'priority': 10, 'exchange': 'mx.example.com'},...]</code>)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveTxt(domain, callback)",
          "type": "method",
          "name": "resolveTxt",
          "The same as `dns.resolve()`, but only for text queries (`TXT` records).\n`addresses` is an array of the text records available for `domain` (e.g.,\n`['v": "spf1 ip4:0.0.0.0 ~all']`).",
          "desc": "<p><code>dns.resolve()</code> と同じですが、テキスト (<code>TXT</code> レコード) だけを問い合わせます。\n<code>addresses</code> は <code>domain</code> で利用可能なテキストレコードの配列です。\n(例、<code>['v=spf1 ip4:0.0.0.0 ~all']</code>)\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveSrv(domain, callback)",
          "type": "method",
          "name": "resolveSrv",
          "desc": "<!--\nThe same as `dns.resolve()`, but only for service records (`SRV` records).\n`addresses` is an array of the SRV records available for `domain`. Properties\nof SRV records are priority, weight, port, and name (e.g.,\n`[{'priority': 10, {'weight': 5, 'port': 21223, 'name': 'service.example.com'}, ...]`).\n-->\n\n<p><code>dns.resolve()</code> と同じですが、サービスレコード (<code>SRV</code> レコード) だけを問い合わせます。\n<code>addresses</code> は <code>domain</code> で利用可能な SRV レコードの配列です。\nSRV レコードのプロパティは priority、weight、port、そして name です\n(例 <code>[{'priority': 10, {'weight': 5, 'port': 21223, 'name': 'service.example.com'}, ...]</code>)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveNs(domain, callback)",
          "type": "method",
          "name": "resolveNs",
          "desc": "<!--\nThe same as `dns.resolve()`, but only for name server records (`NS` records).\n`addresses` is an array of the name server records available for `domain`\n(e.g., `['ns1.example.com', 'ns2.example.com']`).\n-->\n\n<p><code>dns.resolve()</code> と同じですが、ネームサーバレコード (<code>NS</code> レコード) \nだけを問い合わせます。\n<code>address</code> は <code>domain</code> で利用可能なネームサーバレコードの配列です\n(例 <code>['ns1.example.com', 'ns2.example.com']</code>)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.resolveCname(domain, callback)",
          "type": "method",
          "name": "resolveCname",
          "desc": "<!--\nThe same as `dns.resolve()`, but only for canonical name records (`CNAME`\nrecords). `addresses` is an array of the canonical name records available for\n`domain` (e.g., `['bar.example.com']`).\n-->\n\n<p><code>dns.resolve()</code> と同じですが、別名レコード (<code>CNAME</code> レコード) \nだけを問い合わせます。\n<code>address</code> は <code>domain</code> で利用可能な別名レコードの配列です\n<code>domain</code> (e.g., <code>['bar.example.com']</code>)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "dns.reverse(ip, callback)",
          "type": "method",
          "name": "reverse",
          "desc": "<!--\nReverse resolves an ip address to an array of domain names.\n-->\n\n<p>IP アドレスからドメイン名の配列へ逆引きで解決します。\n\n</p>\n<!--\nThe callback has arguments `(err, domains)`.\n-->\n\n<p>コールバックは引数 <code>(err, domains)</code> を持ちます。\n\n</p>\n<!--\nOn error, `err` is an `Error` object, where `err.code` is\none of the error codes listed below.\n-->\n\n<p>エラー時、<code>err</code> は <code>Error</code> オブジェクトで、\n<code>err.errno</code> は後述するエラーコードのいずれかです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "ip"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        }
      ],
      "modules": [
        {
          "textRaw": "Error codes",
          "name": "error_codes",
          "desc": "<!--\nEach DNS query can return one of the following error codes:\n-->\n\n<p>どの DNS 問い合わせも以下のエラーコードの一つを返します:\n\n</p>\n<!--\n- `dns.NODATA`: DNS server returned answer with no data.\n- `dns.FORMERR`: DNS server claims query was misformatted.\n- `dns.SERVFAIL`: DNS server returned general failure.\n- `dns.NOTFOUND`: Domain name not found.\n- `dns.NOTIMP`: DNS server does not implement requested operation.\n- `dns.REFUSED`: DNS server refused query.\n- `dns.BADQUERY`: Misformatted DNS query.\n- `dns.BADNAME`: Misformatted domain name.\n- `dns.BADFAMILY`: Unsupported address family.\n- `dns.BADRESP`: Misformatted DNS reply.\n- `dns.CONNREFUSED`: Could not contact DNS servers.\n- `dns.TIMEOUT`: Timeout while contacting DNS servers.\n- `dns.EOF`: End of file.\n- `dns.FILE`: Error reading file.\n- `dns.NOMEM`: Out of memory.\n- `dns.DESTRUCTION`: Channel is being destroyed.\n- `dns.BADSTR`: Misformatted string.\n- `dns.BADFLAGS`: Illegal flags specified.\n- `dns.NONAME`: Given hostname is not numeric.\n- `dns.BADHINTS`: Illegal hints flags specified.\n- `dns.NOTINITIALIZED`: c-ares library initialization not yet performed.\n- `dns.LOADIPHLPAPI`: Error loading iphlpapi.dll.\n- `dns.ADDRGETNETWORKPARAMS`: Could not find GetNetworkParams function.\n- `dns.CANCELLED`: DNS query cancelled.\n-->\n\n<ul>\n<li><code>dns.NODATA</code>: DNS サーバがデータがないと応答した。</li>\n<li><code>dns.FORMERR</code>: DNS サーバが問い合わせフォーマットが不正だと主張した。</li>\n<li><code>dns.SERVFAIL</code>: DNS サーバが一般的な失敗を返した。</li>\n<li><code>dns.NOTFOUND</code>: ドメイン名が見つからない。</li>\n<li><code>dns.NOTIMP</code>: DNS サーバは要求された操作を実装していない。</li>\n<li><code>dns.REFUSED</code>: DNS サーバが問い合わせを拒否した。</li>\n<li><code>dns.BADQUERY</code>: DNS 問い合わせのフォーマットが不正。</li>\n<li><code>dns.BADNAME</code>: ドメイン名のフォーマットが不正。</li>\n<li><code>dns.BADFAMILY</code>: サポートされないアドレスファミリー。</li>\n<li><code>dns.BADRESP</code>: DNS 応答のフォーマットが不正。</li>\n<li><code>dns.CONNREFUSED</code>: DNS サーバに接続できない。</li>\n<li><code>dns.TIMEOUT</code>: DNS サーバへの接続がタイムアウトした。</li>\n<li><code>dns.EOF</code>: エンドオブファイル。</li>\n<li><code>dns.FILE</code>: ファイルの読み込みがエラー。</li>\n<li><code>dns.NOMEM</code>: メモリ不足。</li>\n<li><code>dns.DESTRUCTION</code>: チャネルが壊れている。</li>\n<li><code>dns.BADSTR</code>: 文字列のフォーマットが不正。</li>\n<li><code>dns.BADFLAGS</code>: 不正なフラグが指定された。</li>\n<li><code>dns.NONAME</code>: 与えられたホスト名が数値ではない。</li>\n<li><code>dns.BADHINTS</code>: 不正なヒントフラグが指定された。</li>\n<li><code>dns.NOTINITIALIZED</code>: c-ares ライブラリが初期化されていない。</li>\n<li><code>dns.LOADIPHLPAPI</code>: iphlpapi.dll のローディングでエラー。</li>\n<li><code>dns.ADDRGETNETWORKPARAMS</code>: GetNetworkParams 関数が見つからない。</li>\n<li><code>dns.CANCELLED</code>: DNS 問い合わせがキャンセルされた。</li>\n</ul>\n",
          "type": "module",
          "displayName": "Error codes"
        }
      ],
      "type": "module",
      "displayName": "DNS"
    },
    {
      "textRaw": "HTTP",
      "name": "http",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<!--\nTo use the HTTP server and client one must `require('http')`.\n-->\n\n<p>HTTP サーバおよびクライアントを使用するにはいずれも <code>require('http')</code> が必要です。\n\n</p>\n<!--\nThe HTTP interfaces in Node are designed to support many features\nof the protocol which have been traditionally difficult to use.\nIn particular, large, possibly chunk-encoded, messages. The interface is\ncareful to never buffer entire requests or responses--the\nuser is able to stream data.\n-->\n\n<p>Node の HTTP インタフェースは、\n伝統的に扱いが難しかったプロトコルの多くの機能をサポートするように設計されています。\nとりわけ大きくて、場合によってはチャンク化されたメッセージです。\nインタフェースは決してリクエストまたはレスポンス全体をバッファリングしないように気をつけています\n－ 利用者はストリームデータを使うことができます。\n\n</p>\n<!--\nHTTP message headers are represented by an object like this:\n-->\n\n<p>HTTP メッセージヘッダはこのようなオブジェクトとして表現されます:\n\n</p>\n<pre><code>{ 'content-length': '123',\n  'content-type': 'text/plain',\n  'connection': 'keep-alive',\n  'accept': '*/*' }</code></pre>\n<!--\nKeys are lowercased. Values are not modified.\n-->\n\n<p>キーは小文字化されます。値は変更されません。\n\n</p>\n<!--\nIn order to support the full spectrum of possible HTTP applications, Node's\nHTTP API is very low-level. It deals with stream handling and message\nparsing only. It parses a message into headers and body but it does not\nparse the actual headers or the body.\n-->\n\n<p>考えられる HTTP アプリケーションを完全にサポートするために、\nNode の HTTP API はとても低水準です。それはストリームのハンドリングとメッセージの解析だけに対処します。\n解析はメッセージをヘッダとボディに分けますが、実際のヘッダとボディは解析しません。\n\n\n</p>\n",
      "properties": [
        {
          "textRaw": "`STATUS_CODES` {Object} ",
          "name": "STATUS_CODES",
          "A collection of all the standard HTTP response status codes, and the\nshort description of each.  For example, `http.STATUS_CODES[404]": "== 'Not\nFound'`.",
          "desc": "<p>全ての HTTP 標準ステータスコードと短い説明のコレクションです。\nたとえば、<code>http.STATUS_CODES[404] === 'Not Found'</code>。\n\n</p>\n"
        },
        {
          "textRaw": "http.globalAgent",
          "name": "globalAgent",
          "desc": "<!--\nGlobal instance of Agent which is used as the default for all http client\nrequests.\n-->\n\n<p>全ての HTTP クライアントリクエストで使用される、デフォルトの Agent のインスタンスです。\n\n\n</p>\n"
        },
        {
          "textRaw": "http.IncomingMessage",
          "name": "IncomingMessage",
          "desc": "<!--\nAn `IncomingMessage` object is created by [http.Server][] or\n[http.ClientRequest][] and passed as the first argument to the `'request'`\nand `'response'` event respectively. It may be used to access response status,\nheaders and data.\n-->\n\n<p><code>IncomingMessage</code> オブジェクトは [http.Server][] または [http.ClientRequest][]\nによって作成され、<code>'request'</code> および <code>'response'</code> イベントそれぞれの\n最初の引数として渡されます。\nそれはステータス、ヘッダ、およびデータにアクセスするために使われます。\n\n</p>\n<!--\nIt implements the [Readable Stream][] interface, as well as the\nfollowing additional events, methods, and properties.\n-->\n\n<p>これは [Readable Stream][] インタフェースの実装で、\n以下のイベント、メソッド、およびプロパティを追加で持ちます。\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<p><code>function () { }</code>\n\n</p>\n<!--\nIndicates that the underlaying connection was closed.\nJust like `'end'`, this event occurs only once per response.\n-->\n\n<p>下層の接続が切断されたことを示します。\n<code>'end'</code> と同様、このイベントはレスポンス毎に一度だけ生成されます。\n\n</p>\n<!--\nJust like `'end'`, this event occurs only once per response. See\n[http.ServerResponse][]'s `'close'` event for more information.\n-->\n\n<p><code>'end'</code> のように、このイベントはレスポンス毎に一回生成されます。\n[http.ServerResponse][] の <code>'close'</code> イベントにより多くの情報があります。\n\n</p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "message.httpVersion",
              "name": "httpVersion",
              "desc": "<!--\nIn case of server request, the HTTP version sent by the client. In the case of\nclient response, the HTTP version of the connected-to server.\nProbably either `'1.1'` or `'1.0'`.\n-->\n\n<p>サーバリクエストの場合、クライアントが送信した HTTP バージョンです。\nクライアントレスポンスの場合、接続したサーバの HTTP バージョンです。\nいずれの場合も <code>'1.1'</code> または <code>'1.0'</code> です。\n\n</p>\n<!--\nAlso `response.httpVersionMajor` is the first integer and\n`response.httpVersionMinor` is the second.\n-->\n\n<p>同様に <code>response.httpVersionMajor</code> は最初の整数、\n<code>response.httpVersionMinor</code> は 2 番目の整数です。\n\n\n</p>\n"
            },
            {
              "textRaw": "message.headers",
              "name": "headers",
              "desc": "<!--\nThe request/response headers object.\n-->\n\n<p>リクエスト／レスポンスヘッダオブジェクトです。\n\n</p>\n<!--\nRead only map of header names and values. Header names are lower-cased.\nExample:\n-->\n\n<p>ヘッダ名と値のリードオンリーなマップです。ヘッダ名は小文字です。\n例:\n\n</p>\n<pre><code>// Prints something like:\n//\n// { 'user-agent': 'curl/7.22.0',\n//   host: '127.0.0.1:8000',\n//   accept: '*/*' }\nconsole.log(request.headers);</code></pre>\n"
            },
            {
              "textRaw": "message.trailers",
              "name": "trailers",
              "desc": "<!--\nThe request/response trailers object. Only populated after the 'end' event.\n-->\n\n<p>リクエスト／レスポンスのトレーラオブジェクトです。\n<code>'end'</code> イベントの後にだけ発生します。\n\n</p>\n"
            },
            {
              "textRaw": "message.method",
              "name": "method",
              "desc": "<!--\n**Only valid for request obtained from [http.Server][].**\n-->\n\n<p><strong> [http.Server][] から得たリクエストでのみ有効です </strong>\n\n</p>\n<!--\nThe request method as a string. Read only. Example:\n`'GET'`, `'DELETE'`.\n-->\n\n<p>リクエストメソッドを表す文字列です。参照のみ可能です。\n例: <code>'GET'</code>、<code>'DELETE'</code>\n\n</p>\n"
            },
            {
              "textRaw": "message.url",
              "name": "url",
              "desc": "<!--\n**Only valid for request obtained from [http.Server][].**\n-->\n\n<p><strong> [http.Server][] から得たリクエストでのみ有効です </strong>\n\n</p>\n<!--\nRequest URL string. This contains only the URL that is\npresent in the actual HTTP request. If the request is:\n-->\n\n<p>リクエスト URL を表す文字列です。\nこれは実際の HTTP リクエストに存在する URL だけを含みます。\nもしリクエストが:\n\n</p>\n<pre><code>GET /status?name=ryan HTTP/1.1\\r\\n\nAccept: text/plain\\r\\n\n\\r\\n</code></pre>\n<!--\nThen `request.url` will be:\n-->\n\n<p>この場合の <code>request.url</code> はこうなります:\n\n</p>\n<pre><code>'/status?name=ryan'</code></pre>\n<!--\nIf you would like to parse the URL into its parts, you can use\n`require('url').parse(request.url)`.  Example:\n-->\n\n<p>URL の要素を解析したい場合は、\n<code>require('url').parse(request.url)</code> を参照してください。例:\n\n</p>\n<pre><code>node> require('url').parse('/status?name=ryan')\n{ href: '/status?name=ryan',\n  search: '?name=ryan',\n  query: 'name=ryan',\n  pathname: '/status' }</code></pre>\n<!--\nIf you would like to extract the params from the query string,\nyou can use the `require('querystring').parse` function, or pass\n`true` as the second argument to `require('url').parse`.  Example:\n-->\n\n<p>問い合わせ文字列からパラメータを取り出したい場合は、\n<code>require('querystring').parse</code> 関数を参照するか、\n<code>require('url').parse</code> の第 2 引数に <code>true</code> を渡してください。例:\n\n</p>\n<pre><code>node> require('url').parse('/status?name=ryan', true)\n{ href: '/status?name=ryan',\n  search: '?name=ryan',\n  query: { name: 'ryan' },\n  pathname: '/status' }</code></pre>\n"
            },
            {
              "textRaw": "message.statusCode",
              "name": "statusCode",
              "desc": "<!--\n**Only valid for response obtained from `http.ClientRequest`.**\n-->\n\n<p><strong> <code>http.ClientRequest</code> から得たレスポンスでのみ有効です </strong>\n\n</p>\n<!--\nThe 3-digit HTTP response status code. E.G. `404`.\n-->\n\n<p>3 桁の数字によるレスポンスのステータスコードです。例えば <code>404</code>。\n\n</p>\n"
            },
            {
              "textRaw": "message.socket",
              "name": "socket",
              "desc": "<!--\nThe `net.Socket` object associated with the connection.\n-->\n\n<p>コネクションに関連づけられた <code>net.Socket</code> オブジェクトです。\n\n</p>\n<!--\nWith HTTPS support, use request.connection.verifyPeer() and\nrequest.connection.getPeerCertificate() to obtain the client's\nauthentication details.\n-->\n\n<p>HTTPS では <code>request.connection.verifyPeer()</code> と\n<code>request.connection.getPeerCertificate()</code> で\nクライアントの認証の詳細を取得できます。\n\n</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "message.setTimeout(msecs, callback)",
              "type": "method",
              "name": "setTimeout",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`msecs` {Number} ",
                      "name": "msecs",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "msecs"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ],
              "desc": "<!--\nCalls `message.connection.setTimeout(msecs, callback)`.\n-->\n\n<p><code>message.connection.setTimeout(msecs, callback)</code> を呼びます。\n\n</p>\n"
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "http.createServer([requestListener])",
          "type": "method",
          "name": "createServer",
          "desc": "<!--\nReturns a new web server object.\n-->\n\n<p>新しい Web サーバオブジェクトを返します。\n\n</p>\n<!--\nThe `requestListener` is a function which is automatically\nadded to the `'request'` event.\n-->\n\n<p><code>requestListener</code> は自動的に <code>'request'</code> イベントに加えられる関数です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "requestListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "http.createClient([port], [host])",
          "type": "method",
          "name": "createClient",
          "desc": "<!--\nThis function is **deprecated**; please use [http.request()][] instead.\nConstructs a new HTTP client. `port` and `host` refer to the server to be\nconnected to.\n-->\n\n<p>この関数は <strong>deprecated</strong> です; 代わりに\n[http.request()][] を使用してください。\n新しい HTTP クライアントを構築します。\n<code>port</code> と <code>host</code> は接続するサーバを示します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "port",
                  "optional": true
                },
                {
                  "name": "host",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "http.request(options, [callback])",
          "type": "method",
          "name": "request",
          "desc": "<!--\nNode maintains several connections per server to make HTTP requests.\nThis function allows one to transparently issue requests.\n-->\n\n<p>Node は HTTP リクエストを行うために、サーバごとにいくつかのコネクションを\n保持します。\nこの関数はその一つを使って透過的にリクエストを発行できるようにします。\n\n</p>\n<!--\n`options` can be an object or a string. If `options` is a string, it is\nautomatically parsed with [url.parse()][].\n-->\n\n<p><code>options</code> はオブジェクトまたは文字列です。\nもし <code>options</code> が文字列なら、それは [url.parse()][] によって自動的に\n解析されます。\n\n</p>\n<!--\nOptions:\n-->\n\n<p>オプション:\n\n</p>\n<!--\n- `host`: A domain name or IP address of the server to issue the request to.\n  Defaults to `'localhost'`.\n- `hostname`: To support `url.parse()` `hostname` is preferred over `host`\n- `port`: Port of remote server. Defaults to 80.\n- `localAddress`: Local interface to bind for network connections.\n- `socketPath`: Unix Domain Socket (use one of host:port or socketPath)\n- `method`: A string specifying the HTTP request method. Defaults to `'GET'`.\n- `path`: Request path. Defaults to `'/'`. Should include query string if any.\n  E.G. `'/index.html?page=12'`\n- `headers`: An object containing request headers.\n- `auth`: Basic authentication i.e. `'user:password'` to compute an\n  Authorization header.\n- `agent`: Controls [Agent][] behavior. When an Agent is used request will\n  default to `Connection: keep-alive`. Possible values:\n - `undefined` (default): use [global Agent][] for this host and port.\n - `Agent` object: explicitly use the passed in `Agent`.\n - `false`: opts out of connection pooling with an Agent, defaults request to\n   `Connection: close`.\n-->\n\n<ul>\n<li><code>host</code>: リクエストを発行するサーバのドメイン名または IP アドレス。</li>\n<li><code>hostname</code>: <code>url.parse()</code> サポート。<code>hostname</code> は <code>host</code> を上書きします。</li>\n<li><code>port</code>: リモートサーバのポート。デフォルトは 80 です。</li>\n<li><code>localAddress</code>: ネットワーク接続をバインドするローカルインタフェースです。</li>\n<li><code>socketPath</code>: Unix ドメインソケット (host:port または socketPath のどちらか)</li>\n<li><code>method</code>: HTTP リクエストのメソッドの文字列。デフォルトは <code>'GET'</code> です。</li>\n<li><code>path</code>: リクエストのパス。デフォルトは <code>'/'</code> です。\n必要なら問い合わせ文字列を含めるべきです．\n例 <code>'/index.html?page=12'</code></li>\n<li><code>headers</code>: リクエストヘッダを含むオブジェクト。</li>\n<li><code>auth</code>: ベーシック認証すなわち Authorization ヘッダのための\n<code>'user:password'</code>。</li>\n<li><code>agent</code>: [Agent][] の振る舞いを制御します。\nエージェントが使われる場合、Connection:keep-alive がデフォルトになります。\n可能な値は:<ul>\n<li><code>undefined</code> (デフォルト): ホストとポートで [global Agent][] を使用します。</li>\n<li><code>Agent</code> オブジェクト: 明示的に渡された <code>Agent</code> を使用します。</li>\n<li><code>false</code>: Agent によるコネクションプーリングを使用しません。\n Connection:close の場合のデフォルトです。</li>\n</ul>\n</li>\n</ul>\n<!--\nThe optional `callback` parameter will be added as a one time listener for\nthe ['response'][] event.\n-->\n\n<p>オプションの <code>callback</code> 引数は、['response'][] イベントへの\n一回限りのリスナとして追加されます。\n\n</p>\n<!--\n`http.request()` returns an instance of the [http.ClientRequest][]\nclass. The `ClientRequest` instance is a writable stream. If one needs to\nupload a file with a POST request, then write to the `ClientRequest` object.\n-->\n\n<p><code>http.request()</code> は [http.ClientRequest][] クラスのインスタンスを返します。\n<code>http.ClientRequest</code> のインスタンスは書き込み可能なストリームです。\nもし POST リクエストでファイルのアップロードがしたければ、\n<code>http.ClientRequest</code> オブジェクトに出力してください。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var options = {\n  hostname: 'www.google.com',\n  port: 80,\n  path: '/upload',\n  method: 'POST'\n};\n\nvar req = http.request(options, function(res) {\n  console.log('STATUS: ' + res.statusCode);\n  console.log('HEADERS: ' + JSON.stringify(res.headers));\n  res.setEncoding('utf8');\n  res.on('data', function (chunk) {\n    console.log('BODY: ' + chunk);\n  });\n});\n\nreq.on('error', function(e) {\n  console.log('problem with request: ' + e.message);\n});\n\n// write data to request body\nreq.write('data\\n');\nreq.write('data\\n');\nreq.end();</code></pre>\n<!--\nNote that in the example `req.end()` was called. With `http.request()` one\nmust always call `req.end()` to signify that you're done with the request -\neven if there is no data being written to the request body.\n-->\n\n<p>この例で <code>req.end()</code> が呼ばれていることに注意してください。\n<code>http.request()</code> では、リクエストが終了したことを示すために、\n常に <code>req.end()</code> を呼び出さなければなりません\n- リクエストのボディに出力するデータがなかったとしても。\n\n</p>\n<!--\nIf any error is encountered during the request (be that with DNS resolution,\nTCP level errors, or actual HTTP parse errors) an `'error'` event is emitted\non the returned request object.\n-->\n\n<p>リクエスト中に何らかのエラー (DNS 解決、TCP レベルのエラー、HTTP パースエラーなど) が発生すると、戻り値のリクエストオブジェクトで <code>'error'</code> イベントが生成されます。\n\n\n</p>\n<!--\nThere are a few special headers that should be noted.\n-->\n\n<p>いくつかの特別なヘッダに注意が必要です。\n\n</p>\n<!--\n* Sending a 'Connection: keep-alive' will notify Node that the connection to\n  the server should be persisted until the next request.\n\n* Sending a 'Content-length' header will disable the default chunked encoding.\n\n* Sending an 'Expect' header will immediately send the request headers.\n  Usually, when sending 'Expect: 100-continue', you should both set a timeout\n  and listen for the `continue` event. See RFC2616 Section 8.2.3 for more\n  information.\n\n* Sending an Authorization header will override using the `auth` option\n  to compute basic authentication.\n-->\n\n<ul>\n<li><p>'Connection: keep-alive' の送信は、サーバへのコネクションを次のリクエストまで持続することを Node に通知します。</p>\n</li>\n<li><p>'Content-length' ヘッダの送信は、デフォルトのチャンクエンコーディングを無効にします。</p>\n</li>\n<li><p>'Expect' ヘッダの送信は、リクエストヘッダを即時に送信します。\n通常、'Expect: 100-continue' を送信すると、タイムアウトと <code>continue</code> イベントを待ち受けます。詳細は RFC2616 の 8.2.3 節を参照してください。</p>\n</li>\n<li><p>Authorization ヘッダの送信は、<code>auth</code> オプションによるベーシック認証を\n上書きします。</p>\n</li>\n</ul>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "http.get(options, [callback])",
          "type": "method",
          "name": "get",
          "desc": "<!--\nSince most requests are GET requests without bodies, Node provides this\nconvenience method. The only difference between this method and `http.request()`\nis that it sets the method to GET and calls `req.end()` automatically.\n-->\n\n<p>ほとんどのリクエストは本文のない GET リクエストであるため、\nNode は便利なメソッドを提供します。\nこのメソッドと <code>http.request()</code> の間の違いは、メソッドを GET に設定して\n<code>req.end()</code> を自動的に呼び出すことだけです。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>http.get("http://www.google.com/index.html", function(res) {\n  console.log("Got response: " + res.statusCode);\n}).on('error', function(e) {\n  console.log("Got error: " + e.message);\n});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: http.Server",
          "type": "class",
          "name": "http.Server",
          "desc": "<!--\nThis is an [EventEmitter][] with the following events:\n-->\n\n<p>これは以下のイベントを持つ [EventEmitter][] です:\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'request'",
              "type": "event",
              "name": "request",
              "desc": "<p><code>function (request, response) { }</code>\n\n</p>\n<!--\nEmitted each time there is a request. Note that there may be multiple requests\nper connection (in the case of keep-alive connections).\n-->\n\n<p>リクエストの度に生成されます。\nコネクションごとに複数のリクエストがあるかもしれないことに注意してください\n(Keep Alive なコネクションの場合)。\n\n</p>\n<!--\n `request` is an instance of [http.IncomingMessage][] and `response` is\nan instance of [http.ServerResponse][].\n-->\n\n<p><code>request</code> は [http.IncomingMessage][] のインスタンス、\n<code>response</code> は [http.ServerResponse][] のインスタンスです。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'connection'",
              "type": "event",
              "name": "connection",
              "desc": "<p><code>function (socket) { }</code>\n\n</p>\n<!--\n When a new TCP stream is established. `socket` is an object of type\n `net.Socket`. Usually users will not want to access this event. In\n particular, the socket will not emit `readable` events because of how\n the protocol parser attaches to the socket. The `socket` can also be\n accessed at `request.connection`.\n-->\n\n<p>新しい TCP ストリームが確立した時。\n<code>socket</code> は <code>net.Socket</code> 型のオブジェクトです。\n通常の利用者がこのイベントにアクセスしたくなることはないでしょう。\nとりわけ、ソケットはプロトコルパーサにアタッチされるため、\n<code>'readable'</code> イベントを生成しません。\n<code>socket</code> は <code>request.connection</code> からアクセスすることもできます。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<p><code>function () { }</code>\n\n</p>\n<!--\n Emitted when the server closes.\n-->\n\n<p>サーバがクローズした時に生成されます。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'checkContinue'",
              "type": "event",
              "name": "checkContinue",
              "desc": "<p><code>function (request, response) { }</code>\n\n</p>\n<!--\nEmitted each time a request with an http Expect: 100-continue is received.\nIf this event isn't listened for, the server will automatically respond\nwith a 100 Continue as appropriate.\n-->\n\n<p>httpの Expect: 100-continue リクエストを受信する度に生成されます。\nこのイベントが監視されない場合、サーバは自動的に 100 Continue を応答します。\n\n</p>\n<!--\nHandling this event involves calling [response.writeContinue()][] if the client\nshould continue to send the request body, or generating an appropriate HTTP\nresponse (e.g., 400 Bad Request) if the client should not continue to send the\nrequest body.\n-->\n\n<p>このイベントを処理する場合、クライアントがリクエストボディを送信し続けるべきなら\n[response.writeContinue()][] を呼び出す必要があります。\nあるいは、クライアントがリクエストボディを送信し続けるべきでないなら、\n適切な HTTP レスポンス (例えば 400 Bad Request) を生成します。\n\n</p>\n<!--\nNote that when this event is emitted and handled, the `request` event will\nnot be emitted.\n-->\n\n<p>このイベントが生成されて処理された場合、<code>request</code>イベントは生成されないことに注意してください。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'connect'",
              "type": "event",
              "name": "connect",
              "desc": "<p><code>function (request, socket, head) { }</code>\n\n</p>\n<!--\nEmitted each time a client requests a http CONNECT method. If this event isn't\nlistened for, then clients requesting a CONNECT method will have their\nconnections closed.\n-->\n\n<p>クライアントが HTTP の CONNECT メソッドを要求する度に生成されます。\nこのイベントが監視されない場合、CONNECT メソッドを要求したクライアントのコネクションはクローズされます。\n\n</p>\n<!--\n* `request` is the arguments for the http request, as it is in the request\n  event.\n* `socket` is the network socket between the server and client.\n* `head` is an instance of Buffer, the first packet of the tunneling stream,\n  this may be empty.\n-->\n\n<ul>\n<li><code>request</code> はリクエストイベントの引数と同様に HTTP リクエストです。</li>\n<li><code>socket</code> はサーバとクライアントの間のネットワークソケットです。</li>\n<li><code>head</code> はトンネリングストリームの最初のパケットを持つ Buffer のインスタンスで\n空の場合もあります。</li>\n</ul>\n<!--\nAfter this event is emitted, the request's socket will not have a `data`\nevent listener, meaning you will need to bind to it in order to handle data\nsent to the server on that socket.\n-->\n\n<p>このイベントが生成された後、リクエスト元のソケットはもう <code>data</code> イベントリスナーを持ちません。\nこのソケットでサーバへ送られたデータを扱うためにそれをバインドしなければならないことを意味します。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'upgrade'",
              "type": "event",
              "name": "upgrade",
              "desc": "<p><code>function (request, socket, head) { }</code>\n\n</p>\n<!--\nEmitted each time a client requests a http upgrade. If this event isn't\nlistened for, then clients requesting an upgrade will have their connections\nclosed.\n-->\n\n<p>クライアントが HTTP のアップグレードを要求する度に生成されます。\nこのイベントが監視されない場合、アップグレードを要求したクライアントのコネクションはクローズされます。\n\n</p>\n<!--\n* `request` is the arguments for the http request, as it is in the request\n  event.\n* `socket` is the network socket between the server and client.\n* `head` is an instance of Buffer, the first packet of the upgraded stream,\n  this may be empty.\n-->\n\n<ul>\n<li><code>request</code> はリクエストイベントの引数と同様に HTTP リクエストです。</li>\n<li><code>socket</code> はサーバとクライアントの間のネットワークソケットです。</li>\n<li><code>head</code> はアップグレードストリームの最初のパケットを持つ Buffer のインスタンス\n空の場合もあります。</li>\n</ul>\n<!--\nAfter this event is emitted, the request's socket will not have a `data`\nevent listener, meaning you will need to bind to it in order to handle data\nsent to the server on that socket.\n-->\n\n<p>このイベントが生成された後、リクエスト元のソケットはもう <code>data</code> イベントリスナーを持ちません。\nこのソケットでサーバへ送られたデータを扱うためにそれをバインドしなければならないことを意味します。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'clientError'",
              "type": "event",
              "name": "clientError",
              "desc": "<p><code>function (exception, socket) { }</code>\n\n</p>\n<!--\nIf a client connection emits an 'error' event - it will forwarded here.\n-->\n\n<p>クライアントコネクションが 'error' イベントを発した場合 － ここに転送されます。\n\n</p>\n<!--\n`socket` is the `net.Socket` object that the error originated from.\n-->\n\n<p><code>socket</code> はエラーが発生した <code>net.Socket</code> オブジェクトです。\n\n\n</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "server.listen(port, [hostname], [backlog], [callback])",
              "type": "method",
              "name": "listen",
              "desc": "<!--\nBegin accepting connections on the specified port and hostname.  If the\nhostname is omitted, the server will accept connections directed to any\nIPv4 address (`INADDR_ANY`).\n-->\n\n<p>指定されたポートとホスト名でコネクションの受け入れを開始します。\nホスト名が省略されると、サーバはどんな IPv4 アドレスへの接続も受け入れます (<code>INADDR_ANY</code>)。\n\n</p>\n<!--\nTo listen to a unix socket, supply a filename instead of port and hostname.\n-->\n\n<p>UNIX ドメインソケットを待ち受ける場合、ポートとホスト名ではなくファイル名を提供します。\n\n</p>\n<!--\nBacklog is the maximum length of the queue of pending connections.\nThe actual length will be determined by your OS through sysctl settings such as\n`tcp_max_syn_backlog` and `somaxconn` on linux. The default value of this\nparameter is 511 (not 512).\n-->\n\n<p>バックログは保留された接続のキューの最大長です。\n実際の長さは Linux では <code>tcp_max_syn_backlog</code> や <code>somaxconn</code> など、\nsysctl の設定を通じて OS によって決定されます。\nこのパラメータのデフォルト値は 511 (512 ではありません) です。\n\n</p>\n<!--\nThis function is asynchronous. The last parameter `callback` will be added as\na listener for the ['listening'][] event.  See also [net.Server.listen(port)][].\n-->\n\n<p>この関数は非同期です。最後の引数の <code>callback</code> は\n['listening'][] イベントのリスナとして加えられます。\n詳細は [net.Server.listen(port)][] を参照してください。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "port"
                    },
                    {
                      "name": "hostname",
                      "optional": true
                    },
                    {
                      "name": "backlog",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.listen(path, [callback])",
              "type": "method",
              "name": "listen",
              "desc": "<!--\nStart a UNIX socket server listening for connections on the given `path`.\n-->\n\n<p><code>path</code> で与えられたコネクションを待ち受ける UNIX ドメインソケットのサーバを開始します。\n\n</p>\n<!--\nThis function is asynchronous. The last parameter `callback` will be added as\na listener for the ['listening'][] event.  See also [net.Server.listen(path)][].\n-->\n\n<p>この関数は非同期です。最後の引数の <code>callback</code> は\n['listening'][] イベントのリスナとして加えられます。\n詳細は [net.Server.listen(path)][] を参照してください。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.listen(handle, [callback])",
              "type": "method",
              "name": "listen",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`handle` {Object} ",
                      "name": "handle",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "handle"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nThe `handle` object can be set to either a server or socket (anything\nwith an underlying `_handle` member), or a `{fd: <n>}` object.\n-->\n\n<p><code>handle</code> オブジェクトには、サーバまたはソケット (下層の <code>_handle</code> メンバなら\nなんでも) または、 <code>{fd: <n>}</code> オブジェクトを設定することができます。\n\n</p>\n<!--\nThis will cause the server to accept connections on the specified\nhandle, but it is presumed that the file descriptor or handle has\nalready been bound to a port or domain socket.\n-->\n\n<p>これによりサーバは指定したハンドルへの接続を受け付けることになりますが、\nファイル記述子またはハンドルは既にポートまたはドメインソケットに\nバインドされているものと見なされます。\n\n</p>\n<!--\nListening on a file descriptor is not supported on Windows.\n-->\n\n<p>ファイル記述子へのリスニングは Windows ではサポートされません。\n\n</p>\n<!--\nThis function is asynchronous. The last parameter `callback` will be added as\na listener for the ['listening'](net.html#event_listening_) event.\nSee also [net.Server.listen()](net.html#net_server_listen_handle_callback).\n-->\n\n<p>この関数は非同期です。最後の引数の <code>callback</code> は\n<a href="\"net.html#event_listening_\"">'listening'</a> イベントのリスナとして加えられます。\n詳細は <a href="\"net.html#net_server_listen_handle_callback\"">net.Server.listen()</a>\nを参照してください。\n\n</p>\n"
            },
            {
              "textRaw": "server.close([callback])",
              "type": "method",
              "name": "close",
              "desc": "<!--\nStops the server from accepting new connections.  See [net.Server.close()][].\n-->\n\n<p>サーバが新しいコネクションを受け付けるのを終了します。\n[net.Server.close()][] を参照してください。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.setTimeout(msecs, callback)",
              "type": "method",
              "name": "setTimeout",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`msecs` {Number} ",
                      "name": "msecs",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "msecs"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ],
              "desc": "<!--\nSets the timeout value for sockets, and emits a `'timeout'` event on\nthe Server object, passing the socket as an argument, if a timeout\noccurs.\n-->\n\n<p>ソケットにタイムアウト値を設定し、サーバオブジェクト上で <code>'timeout'</code>\nイベントを生成します。\nタイムアウトが発生すると、ソケットが引数として渡されます。\n\n</p>\n<!--\nIf there is a `'timeout'` event listener on the Server object, then it\nwill be called with the timed-out socket as an argument.\n-->\n\n<p>サーバオブジェクトに <code>'timeout'</code> イベントのリスナが存在すると、\nそれはタイムアウトしたソケットを引数として呼び出されます。\n\n</p>\n<!--\nBy default, the Server's timeout value is 2 minutes, and sockets are\ndestroyed automatically if they time out.  However, if you assign a\ncallback to the Server's `'timeout'` event, then you are responsible\nfor handling socket timeouts.\n-->\n\n<p>デフォルトでは、サーバのタイムアウト値は 2 分で、\nタイムアウトしたソケットは自動的に破棄されます。\nしかしながら、<code>'timeout'</code> イベントのコールバックをサーバに割り当てた場合、\nタイムアウトしたソケットのハンドリングはあなたの責務となります。\n\n</p>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "server.maxHeadersCount",
              "name": "maxHeadersCount",
              "desc": "<!--\nLimits maximum incoming headers count, equal to 1000 by default. If set to 0 -\nno limit will be applied.\n-->\n\n<p>受け付けるヘッダ数の上限で、デフォルトは 1000 です。\n0 に設定されると、制限しないことになります。\n\n</p>\n"
            },
            {
              "textRaw": "`timeout` {Number} デフォルト = 120000 (2 分) ",
              "name": "timeout",
              "* {Number} Default": "120000 (2 minutes)",
              "desc": "<!--\nThe number of milliseconds of inactivity before a socket is presumed\nto have timed out.\n-->\n\n<p>不活性なソケットがタイムアウトしたと推定されるまでのミリ秒を表す数値。\n\n</p>\n<!--\nNote that the socket timeout logic is set up on connection, so\nchanging this value only affects *new* connections to the server, not\nany existing connections.\n-->\n\n<p>ソケットのタイムアウト処理は接続のセットアップ時に行われるため、\nこの値の変更は既存の接続ではなく、サーバへの <em>新しい</em> 接続にだけ\n影響することに注意してください。\n\n</p>\n<!--\nSet to 0 to disable any kind of automatic timeout behavior on incoming\nconnections.\n-->\n\n<p>0 を設定すると、到着する接続に対する自動的なタイムアウトの振る舞いは\n無効になります。\n\n</p>\n",
              "shortDesc": "デフォルト = 120000 (2 分)"
            }
          ]
        },
        {
          "textRaw": "Class: http.ServerResponse",
          "type": "class",
          "name": "http.ServerResponse",
          "desc": "<!--\nThis object is created internally by a HTTP server--not by the user. It is\npassed as the second parameter to the `'request'` event.\n\nThe response implements the [Writable Stream][] interface. This is an\n[EventEmitter][] with the following events:\n-->\n\n<p>このオブジェクトは HTTP サーバ内部 － ユーザではなく － で作成されます。\n<code>'request'</code> リスナーの第 2 引数として渡されます。\n\n</p>\n<p>レスポンスは [Writable  Stream][] インタフェースを実装します。\nこれは以下のイベントを持つ [EventEmitter][] です:\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<p><code>function () { }</code>\n\n</p>\n<!--\nIndicates that the underlying connection was terminated before\n[response.end()][] was called or able to flush.\n-->\n\n<p>[response.end()][] が呼び出されたりフラッシュされる前に、\n下層の接続が切断されたことを示します。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'finish'",
              "type": "event",
              "name": "finish",
              "desc": "<p><code>function () { }</code>\n\n</p>\n<!--\nEmitted when the response has been sent. More specifically, this event is\nemitted when the last segment of the response headers and body have been\nhanded off to the operating system for transmission over the network. It\ndoes not imply that the client has received anything yet.\n-->\n\n<p>レスポンスが送信されると生成されます。\nより詳しくは、このイベントはレスポンスヘッダおよびボディの最後のセグメントが\nネットワークに転送されるためOSに渡された時に生成されます。\nこれはクライアントが何かを受信したことを意味しません。\n\n</p>\n<!--\nAfter this event, no more events will be emitted on the response object.\n-->\n\n<p>このイベントの後、レスポンス上ではどんなイベントも生成されません。\n\n</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "response.writeContinue()",
              "type": "method",
              "name": "writeContinue",
              "desc": "<!--\nSends a HTTP/1.1 100 Continue message to the client, indicating that\nthe request body should be sent. See the ['checkContinue'][] event on `Server`.\n-->\n\n<p>HTTP/1.1 の 100 Continue メッセージをクライアントに送信し、\nリクエストボディを送信してもよいことを示します。\n<code>Server</code>の ['checkContinue'][] イベントを参照してください。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "response.writeHead(statusCode, [reasonPhrase], [headers])",
              "type": "method",
              "name": "writeHead",
              "desc": "<!--\nSends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like `404`. The last argument, `headers`, are the response headers.\nOptionally one can give a human-readable `reasonPhrase` as the second\nargument.\n-->\n\n<p>レスポンスヘッダを送信します。\nステータスコードは <code>404</code> のような 3 桁の数字による HTTP ステータスコードです。\n最後の引数 <code>headers</code> は、レスポンスヘッダです。\nオプションとして人に読める形式の <code>reasonPhrase</code> を第 2 引数で与えることができます。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var body = 'hello world';\nresponse.writeHead(200, {\n  'Content-Length': body.length,\n  'Content-Type': 'text/plain' });</code></pre>\n<!--\nThis method must only be called once on a message and it must\nbe called before [response.end()][] is called.\n\nIf you call [response.write()][] or [response.end()][] before calling this, the\nimplicit/mutable headers will be calculated and call this function for you.\n-->\n\n<p>このメソッドはメッセージごとに 1 回だけ呼び出されなくてはならず、\n[response.end()][] の前に呼び出されなければなりません。\n\n</p>\n<p>もしこのメソッドが呼び出される前に [response.write()][] または\n[response.end()][] が呼ばれると、暗黙的に可変のヘッダが算出されて、\nこの関数が呼び出されます。\n\n</p>\n<!--\nNote: that Content-Length is given in bytes not characters. The above example\nworks because the string `'hello world'` contains only single byte characters.\nIf the body contains higher coded characters then `Buffer.byteLength()`\nshould be used to determine the number of bytes in a given encoding.\nAnd Node does not check whether Content-Length and the length of the body\nwhich has been transmitted are equal or not.\n-->\n\n<p>注意: <code>Content-Length</code> は文字数ではなくバイト数で与えられます。\n上の例が動作するのは <code>'hello world'</code> という文字列が単一バイト文字だけを含むためです。\nもしボディがより上位にコード化された文字を含む場合は、\n指定したエンコーディングによるバイト数を得るために <code>Buffer.byteLength()</code> を使うべきです。\nNode は、Content-Length と実際に送信されたレスポンスボディの長さが等しいかどうかチェックしません。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "statusCode"
                    },
                    {
                      "name": "reasonPhrase",
                      "optional": true
                    },
                    {
                      "name": "headers",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.setTimeout(msecs, callback)",
              "type": "method",
              "name": "setTimeout",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`msecs` {Number} ",
                      "name": "msecs",
                      "type": "Number"
                    },
                    {
                      "textRaw": "`callback` {Function} ",
                      "name": "callback",
                      "type": "Function"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "msecs"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ],
              "desc": "<!--\nSets the Socket's timeout value to `msecs`.  If a callback is\nprovided, then it is added as a listener on the `'timeout'` event on\nthe response object.\n-->\n\n<p>ソケットのタイムアウト値を <code>msec</code> に設定します。\nコールバックが与えられると、それはレスポンスオブジェクトの <code>'timeout'</code>\nイベントのリスナとして加えられます。\n\n</p>\n<!--\nIf no `'timeout'` listener is added to the request, the response, or\nthe server, then sockets are destroyed when they time out.  If you\nassign a handler on the request, the response, or the server's\n`'timeout'` events, then it is your responsibility to handle timed out\nsockets.\n-->\n\n<p>リクエスト、レスポンス、そしてサーバのいずれにも <code>'timeout'</code>\nリスナが存在しない場合、タイムアウトしたソケットは破棄されます。\nもしリクエスト、レスポンス、サーバのいずれかに <code>'timeout'</code> イベントを\n設定した場合、タイムアウトしたソケットのハンドリングはあなたの責務となります。\n\n</p>\n"
            },
            {
              "textRaw": "response.setHeader(name, value)",
              "type": "method",
              "name": "setHeader",
              "desc": "<!--\nSets a single header value for implicit headers.  If this header already exists\nin the to-be-sent headers, its value will be replaced.  Use an array of strings\nhere if you need to send multiple headers with the same name.\n-->\n\n<p>暗黙的ヘッダのヘッダ値を設定します。\n送信されようとしているレスポンスヘッダにこのヘッダが既に含まれている場合、\nその値は置き換えられます。\n同じ名前で複数のヘッダを送信したい場合は文字列の配列を使ってください。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>response.setHeader("Content-Type", "text/html");</code></pre>\n<!--\nor\n-->\n\n<p>または\n\n</p>\n<pre><code>response.setHeader("Set-Cookie", ["type=ninja", "language=javascript"]);</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name"
                    },
                    {
                      "name": "value"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.getHeader(name)",
              "type": "method",
              "name": "getHeader",
              "desc": "<!--\nReads out a header that's already been queued but not sent to the client.  Note\nthat the name is case insensitive.  This can only be called before headers get\nimplicitly flushed.\n-->\n\n<p>すでにキューに入れられているが未送信のヘッダを読み上げます．\n名前は大文字小文字を区別しないことに注意してください。\nこれはヘッダが暗黙的にフラッシュされる前だけ呼び出すことができます。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var contentType = response.getHeader('content-type');</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.removeHeader(name)",
              "type": "method",
              "name": "removeHeader",
              "desc": "<!--\nRemoves a header that's queued for implicit sending.\n-->\n\n<p>暗黙的に送信するためキューに入れられたヘッダを削除します。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>response.removeHeader("Content-Encoding");</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "name"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.write(chunk, [encoding])",
              "type": "method",
              "name": "write",
              "desc": "<!--\nIf this method is called and [response.writeHead()][] has not been called,\nit will switch to implicit header mode and flush the implicit headers.\n\nThis sends a chunk of the response body. This method may\nbe called multiple times to provide successive parts of the body.\n-->\n\n<p>このメソッドが呼び出され、[response.writeHead()][] が呼び出されなければ、\n暗黙的ヘッダモードに切り替わり、暗黙的ヘッダはフラッシュされます。\n\n</p>\n<p>これはレスポンスボディのチャンクを送信します。\nこのメソッドはボディの連続した部分を提供するために複数回呼び出されるかもしれません。\n\n</p>\n<!--\n`chunk` can be a string or a buffer. If `chunk` is a string,\nthe second parameter specifies how to encode it into a byte stream.\nBy default the `encoding` is `'utf8'`.\n-->\n\n<p><code>chunk</code> は文字列またはバッファにすることができます。\n<code>chunk</code> が文字列の場合、どのエンコードでバイトストリームにするかを第 2 引数で指定します。\nデフォルトの <code>encoding</code> は <code>'utf8'</code> です。\n\n</p>\n<!--\n**Note**: This is the raw HTTP body and has nothing to do with\nhigher-level multi-part body encodings that may be used.\n-->\n\n<p><strong>注意</strong>: これは生の HTTP ボディで、\n高水準のマルチパートボディエンコーディングで使われるものとは無関係です。\n\n</p>\n<!--\nThe first time `response.write()` is called, it will send the buffered\nheader information and the first body to the client. The second time\n`response.write()` is called, Node assumes you're going to be streaming\ndata, and sends that separately. That is, the response is buffered up to the\nfirst chunk of body.\n-->\n\n<p>初めて <code>response.write()</code> が呼び出されると、\nバッファリングされていたヘッダ情報と最初のボディがクライアントに送信されます。\n2 回目に <code>response.write()</code> が呼ばれると、\nNode はストリーミングデータを分割して送信しようとしていると仮定します。\nすなわち、レスポンスはボディの最初のチャンクまでバッファリングされます。\n\n</p>\n<!--\nReturns `true` if the entire data was flushed successfully to the kernel\nbuffer. Returns `false` if all or part of the data was queued in user memory.\n`'drain'` will be emitted when the buffer is again free.\n-->\n\n<p>データ全体のカーネルバッファへのフラッシュが成功すると <code>true</code> を返します。\nデータ全体または一部がユーザメモリ内のキューに入れられた場合は\n<code>false</code> を返します。\n再びバッファが空いた場合は <code>'drain'</code> イベントが生成されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.addTrailers(headers)",
              "type": "method",
              "name": "addTrailers",
              "desc": "<!--\nThis method adds HTTP trailing headers (a header but at the end of the\nmessage) to the response.\n-->\n\n<p>このメソッドは HTTP トレーラヘッダ (メッセージの最後に置かれるヘッダ) をレスポンスに追加します。\n\n</p>\n<!--\nTrailers will **only** be emitted if chunked encoding is used for the\nresponse; if it is not (e.g., if the request was HTTP/1.0), they will\nbe silently discarded.\n-->\n\n<p>トレーラはレスポンスがチャンク化されたエンコーディングで<strong>のみ</strong>生成されます;\nそうでなければ (例えばリクエストが HTTP/1.0)、黙って破棄されます。\n\n</p>\n<!--\nNote that HTTP requires the `Trailer` header to be sent if you intend to\nemit trailers, with a list of the header fields in its value. E.g.,\n-->\n\n<p>HTTP は、トレーラを生成するならそのヘッダフィールドのリストを値として\n<code>Trailer</code> ヘッダを送信することを要求していることに注意してください。\n\n</p>\n<pre><code>response.writeHead(200, { 'Content-Type': 'text/plain',\n                          'Trailer': 'Content-MD5' });\nresponse.write(fileData);\nresponse.addTrailers({'Content-MD5': "7895bf4b8828b55ceaf47747b4bca667"});\nresponse.end();</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "headers"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "response.end([data], [encoding])",
              "type": "method",
              "name": "end",
              "desc": "<!--\nThis method signals to the server that all of the response headers and body\nhave been sent; that server should consider this message complete.\nThe method, `response.end()`, MUST be called on each\nresponse.\n-->\n\n<p>このメソッドはレスポンスの全てのヘッダとボディを送信したことをサーバに伝えます;\nサーバはメッセージが終了したと考えるべきです。\nこの <code>response.end()</code> メソッドは各レスポンスごとに呼び出さなければ<em>なりません</em>。\n\n</p>\n<!--\nIf `data` is specified, it is equivalent to calling `response.write(data, encoding)`\nfollowed by `response.end()`.\n-->\n\n<p><code>data</code> が指定された場合、\n<code>response.write(data, encoding)</code> に続けて <code>response.end()</code> を呼び出すのと等価です。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "properties": [
            {
              "textRaw": "response.statusCode",
              "name": "statusCode",
              "desc": "<!--\nWhen using implicit headers (not calling [response.writeHead()][] explicitly),\nthis property controls the status code that will be sent to the client when\nthe headers get flushed.\n-->\n\n<p>([response.writeHead()][] が明示的に呼ばれないために) 暗黙的なヘッダが\n使われる場合、このプロパティはヘッダがフラッシュされる時に\nクライアントへ送信されるステータスコードを制御します。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>response.statusCode = 404;</code></pre>\n<!--\nAfter response header was sent to the client, this property indicates the\nstatus code which was sent out.\n-->\n\n<p>レスポンスヘッダがクライアントに送信された後、\nこのプロパティは送信されたステータスコードを示します。\n\n</p>\n"
            },
            {
              "textRaw": "response.headersSent",
              "name": "headersSent",
              "desc": "<!--\nBoolean (read-only). True if headers were sent, false otherwise.\n-->\n\n<p>(読み込み専用の) Boolean。\nヘッダが送信済みなら true、それ以外は false です。\n\n</p>\n"
            },
            {
              "textRaw": "response.sendDate",
              "name": "sendDate",
              "desc": "<!--\nWhen true, the Date header will be automatically generated and sent in\nthe response if it is not already present in the headers. Defaults to true.\n\nThis should only be disabled for testing; HTTP requires the Date header\nin responses.\n-->\n\n<p><code>true</code> の場合、Date ヘッダが自動的に生成され、レスポンスとして送信されます\n(<code>headers</code> にすでに与えられていない場合)。\nデフォルトは <code>true</code> です。\n\n</p>\n<p>これを無効にするのはテストでのみにすべきです。\nHTTP はレスポンスに Date ヘッダを要求します。\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: http.Agent",
          "type": "class",
          "name": "http.Agent",
          "desc": "<!--\nIn node 0.5.3+ there is a new implementation of the HTTP Agent which is used\nfor pooling sockets used in HTTP client requests.\n\nPreviously, a single agent instance helped pool for a single host+port. The\ncurrent implementation now holds sockets for any number of hosts.\n\nThe current HTTP Agent also defaults client requests to using\nConnection:keep-alive. If no pending HTTP requests are waiting on a socket\nto become free the socket is closed. This means that node's pool has the\nbenefit of keep-alive when under load but still does not require developers\nto manually close the HTTP clients using keep-alive.\n\nSockets are removed from the agent's pool when the socket emits either a\n\"close\" event or a special \"agentRemove\" event. This means that if you intend\nto keep one HTTP request open for a long time and don't want it to stay in the\npool you can do something along the lines of:\n-->\n\n<p>Node 0.5.3 以降には、HTTP クライアントリクエストのソケットを\nプーリングするために新しい HTTP Agent の実装が存在します。\n\n</p>\n<p>以前は、エージェントの一つのインスタンスが一つのホスト + ポートのプールを\n助けていましたが、現在の実装では任意の数のホストに対するソケットを\n保持できるようになりました。\n\n</p>\n<p>現在の HTTP Agent では、クライアントリクエストはデフォルトで\nConnection:keep-alive を使うようにもなりました。\nソケットを待ってペンディングになっている HTTP リクエストがなければ、\nソケットはクローズされます。\nこれは、node のプールは高負荷時に keep-alive のメリットを持ちながら、\nkeep-alive を使用する HTTP クライアントを開発者が手動でクローズする\n必要がないことを意味します。\n\n</p>\n<p>ソケットは <code>'close'</code> イベントまたは特別な <code>'agentRemove'</code> イベントが\n生成された時にエージェントのプールから削除されます。\nこれは、一つの HTTP リクエストを長時間オープンしたままにするために、\nプールにソケットがとどまらないことを意図するなら、\n以下のようにすることができることを意味します:\n\n</p>\n<pre><code>http.get(options, function(res) {\n  // Do stuff\n}).on("socket", function (socket) {\n  socket.emit("agentRemove");\n});</code></pre>\n<!--\nAlternatively, you could just opt out of pooling entirely using `agent:false`:\n-->\n\n<p>別の方法として、 <code>agent: false</code> を指定することで、\nプーリングを使用しないこともできます:\n\n</p>\n<pre><code>http.get({hostname:'localhost', port:80, path:'/', agent:false}, function (res) {\n  // Do stuff\n})</code></pre>\n",
          "properties": [
            {
              "textRaw": "agent.maxSockets",
              "name": "maxSockets",
              "desc": "<!--\nBy default set to 5. Determines how many concurrent sockets the agent can have\nopen per origin. Origin is either a 'host:port' or 'host:port:localAddress'\ncombination.\n-->\n\n<p>デフォルトでは 5 に設定されます。\nエージェントがオリジン毎にいくつのソケットを並行にオープンするかを決定します。\nオリジンは <code>'host:port'</code> または <code>'host:port:localAddress'</code>\nの組み合わせのいずれかです。\n\n</p>\n"
            },
            {
              "textRaw": "agent.sockets",
              "name": "sockets",
              "desc": "<!--\nAn object which contains arrays of sockets currently in use by the Agent. Do not\nmodify.\n-->\n\n<p>エージェントが現在使っているソケットの配列です。\n変更しないでください。\n\n</p>\n"
            },
            {
              "textRaw": "agent.requests",
              "name": "requests",
              "desc": "<!--\nAn object which contains queues of requests that have not yet been assigned to\nsockets. Do not modify.\n-->\n\n<p>まだソケットが割り当てられていないリクエストのキューを含むオブジェクトです。\n変更しないでください。\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: http.ClientRequest",
          "type": "class",
          "name": "http.ClientRequest",
          "desc": "<!--\nThis object is created internally and returned from `http.request()`.  It\nrepresents an _in-progress_ request whose header has already been queued.  The\nheader is still mutable using the `setHeader(name, value)`, `getHeader(name)`,\n`removeHeader(name)` API.  The actual header will be sent along with the first\ndata chunk or when closing the connection.\n-->\n\n<p>このオブジェクトは HTTP サーバ内部で作成され、<code>http.request()</code> から返されます。\nそれはヘッダがキューに入れられた <em>進行中</em> のリクエストを表現します。\nヘッダは <code>setHeader(name, value)</code>, <code>getHeader(name)</code>, <code>removeHeader(name)</code> API によってまだ可変のままです。\n実際にヘッダが送信されるのは、最初のデータチャンクが送信される時またはコネクションがクローズされる時です。\n\n</p>\n<!--\nTo get the response, add a listener for `'response'` to the request object.\n`'response'` will be emitted from the request object when the response\nheaders have been received.  The `'response'` event is executed with one\nargument which is an instance of [http.IncomingMessage][].\n-->\n\n<p>レスポンスを取得するには、<code>'response'</code> 用のリスナーをリクエストオブジェクトに加えます。\n<code>'response'</code> イベントはレスポンスヘッダを受信するとリクエストオブジェクトによって生成されます。\n<code>'response'</code> イベントは [http.IncomingMessage][] のインスタンスを\n唯一の引数として実行されます。\n\n</p>\n<!--\nDuring the `'response'` event, one can add listeners to the\nresponse object; particularly to listen for the `'data'` event.\n-->\n\n<p><code>'response'</code> イベントの間、レスポンスオブジェクトにリスナーを加えることができます;\nとりわけ <code>'data'</code> イベントのリスナーです。\n\n</p>\n<!--\nIf no `'response'` handler is added, then the response will be\nentirely discarded.  However, if you add a `'response'` event handler,\nthen you **must** consume the data from the response object, either by\ncalling `response.read()` whenever there is a `'readable'` event, or\nby adding a `'data'` handler, or by calling the `.resume()` method.\nUntil the data is consumed, the `'end'` event will not fire.  Also, until\nthe data is read it will consume memory that can eventually lead to a\n'process out of memory' error.\n-->\n\n<p><code>'response'</code> ハンドラが加えられない場合、レスポンスは完全に捨てられます。\nしかし、<code>'response'</code> イベントハンドラを加えた場合は、\n<code>'readable'</code> イベントが発生した時に <code>response.read()</code> を呼ぶか、\n<code>'data'</code> ハンドラを加えるか、<code>.resume()</code> メソッドを呼び出すかのいずれかにより、\nレスポンスオブジェクトからのデータを消費しなければ <em>なりません</em> 。\nデータが消費されるまで、<code>'end'</code> イベントは生成されません。\nまた、データは読まれるまでメモリを消費し、'process out of memory'\nエラーにつながることになります。\n\n</p>\n<!--\nThis is a `Writable Stream`.\nNote: Node does not check whether Content-Length and the length of the body\nwhich has been transmitted are equal or not.\n\nNote: Node does not check whether Content-Length and the length of the body\nwhich has been transmitted are equal or not.\n-->\n\n<p>これは <code>Writable Stream</code> です。\n注意: Node は Content-Length と実際に送信されたリクエストボディの長さが等しいかどうかチェックしません。\n\n</p>\n<p><code>ServerRequest</code> が <code>'data'</code> イベントを生成した時にリスナが存在しなければ、\n<strong>データは失われる</strong>ことに注意してください。\n\n</p>\n<!--\nThe request implements the [Writable Stream][] interface. This is an\n[EventEmitter][] with the following events:\n-->\n\n<p>リクエストは [Writable  Stream][] インタフェースを実装します。\nこれは以下のイベントを持つ [EventEmitter][] です。\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event 'response'",
              "type": "event",
              "name": "response",
              "desc": "<p><code>function (response) { }</code>\n\n</p>\n<!--\nEmitted when a response is received to this request. This event is emitted only\nonce. The `response` argument will be an instance of [http.IncomingMessage][].\n-->\n\n<p>このリクエストに対するレスポンスを受信した時に生成されます。\nこのイベントは一回だけ生成されます。\n<code>response</code> 引数は [http.IncomingMessage][] のインスタンスです。\n\n</p>\n<!--\nOptions:\n-->\n\n<p>オプション:\n\n</p>\n<!--\n- `host`: A domain name or IP address of the server to issue the request to.\n- `port`: Port of remote server.\n- `socketPath`: Unix Domain Socket (use one of host:port or socketPath)\n-->\n\n<ul>\n<li><code>host</code>: リクエストを発行するサーバのドメイン名または IP アドレス。</li>\n<li><code>port</code>: リモートサーバのポート。</li>\n<li><code>soocketPath</code>: Unix ドメインソケット (host:port または socketPath のどちらか)</li>\n</ul>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'socket'",
              "type": "event",
              "name": "socket",
              "desc": "<p><code>function (socket) { }</code>\n\n</p>\n<!--\nEmitted after a socket is assigned to this request.\n-->\n\n<p>このリクエストにソケットが割り当てられた後に生成されます。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'connect'",
              "type": "event",
              "name": "connect",
              "desc": "<p><code>function (response, socket, head) { }</code>\n\n</p>\n<!--\nEmitted each time a server responds to a request with a CONNECT method. If this\nevent isn't being listened for, clients receiving a CONNECT method will have\ntheir connections closed.\n-->\n\n<p>サーバが CONNECT メソッドの要求に応答する度に生成されます。\nこのイベントが監視されていない場合、クライアントが CONNECT メソッドへの\nレスポンスを受信すると、そのコネクションはクローズされます。\n\n</p>\n<!--\nA client server pair that show you how to listen for the `connect` event.\n-->\n\n<p>どのように <code>connect</code> イベントを監視するかを示すクライアントとサーバのペア:\n\n\n</p>\n<pre><code>var http = require('http');\nvar net = require('net');\nvar url = require('url');\n\n// Create an HTTP tunneling proxy\nvar proxy = http.createServer(function (req, res) {\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('okay');\n});\nproxy.on('connect', function(req, cltSocket, head) {\n  // connect to an origin server\n  var srvUrl = url.parse('http://' + req.url);\n  var srvSocket = net.connect(srvUrl.port, srvUrl.hostname, function() {\n    cltSocket.write('HTTP/1.1 200 Connection Established\\r\\n' +\n                    'Proxy-agent: Node-Proxy\\r\\n' +\n                    '\\r\\n');\n    srvSocket.write(head);\n    srvSocket.pipe(cltSocket);\n    cltSocket.pipe(srvSocket);\n  });\n});\n\n// now that proxy is running\nproxy.listen(1337, '127.0.0.1', function() {\n\n  // make a request to a tunneling proxy\n  var options = {\n    port: 1337,\n    hostname: '127.0.0.1',\n    method: 'CONNECT',\n    path: 'www.google.com:80'\n  };\n\n  var req = http.request(options);\n  req.end();\n\n  req.on('connect', function(res, socket, head) {\n    console.log('got connected!');\n\n    // make a request over an HTTP tunnel\n    socket.write('GET / HTTP/1.1\\r\\n' +\n                 'Host: www.google.com:80\\r\\n' +\n                 'Connection: close\\r\\n' +\n                 '\\r\\n');\n    socket.on('data', function(chunk) {\n      console.log(chunk.toString());\n    });\n    socket.on('end', function() {\n      proxy.close();\n    });\n  });\n});</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'upgrade'",
              "type": "event",
              "name": "upgrade",
              "desc": "<p><code>function (response, socket, head) { }</code>\n\n</p>\n<!--\nEmitted each time a server responds to a request with an upgrade. If this\nevent isn't being listened for, clients receiving an upgrade header will have\ntheir connections closed.\n-->\n\n<p>サーバがアップグレード要求に応答する度に生成されます。\nこのイベントが監視されていない場合、クライアントがアップグレードヘッダを受信するとそのコネクションはクローズされます。\n\n</p>\n<!--\nA client server pair that show you how to listen for the `upgrade` event.\n-->\n\n<p>どのように <code>upgrade</code> イベントを監視するかを示すクライアントとサーバのペア:\n\n</p>\n<pre><code>var http = require('http');\n\n// Create an HTTP server\nvar srv = http.createServer(function (req, res) {\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('okay');\n});\nsrv.on('upgrade', function(req, socket, head) {\n  socket.write('HTTP/1.1 101 Web Socket Protocol Handshake\\r\\n' +\n               'Upgrade: WebSocket\\r\\n' +\n               'Connection: Upgrade\\r\\n' +\n               '\\r\\n');\n\n  socket.pipe(socket); // echo back\n});\n\n// now that server is running\nsrv.listen(1337, '127.0.0.1', function() {\n\n  // make a request\n  var options = {\n    port: 1337,\n    hostname: '127.0.0.1',\n    headers: {\n      'Connection': 'Upgrade',\n      'Upgrade': 'websocket'\n    }\n  };\n\n  var req = http.request(options);\n  req.end();\n\n  req.on('upgrade', function(res, socket, upgradeHead) {\n    console.log('got upgraded!');\n    socket.end();\n    process.exit(0);\n  });\n});</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'continue'",
              "type": "event",
              "name": "continue",
              "desc": "<p><code>function () { }</code>\n\n</p>\n<!--\nEmitted when the server sends a '100 Continue' HTTP response, usually because\nthe request contained 'Expect: 100-continue'. This is an instruction that\nthe client should send the request body.\n-->\n\n<p>通常、リクエストが 'Expect: 100-continue' を含んでいたことにより、\nサーバが '100 Continue' HTTP レスポンスを送信することで生成されます。\nこれはクライアントがリクエストボディを送信すべき事を示します。\n\n</p>\n",
              "params": []
            }
          ],
          "methods": [
            {
              "textRaw": "request.write(chunk, [encoding])",
              "type": "method",
              "name": "write",
              "desc": "<!--\nSends a chunk of the body.  By calling this method\nmany times, the user can stream a request body to a\nserver--in that case it is suggested to use the\n`['Transfer-Encoding', 'chunked']` header line when\ncreating the request.\n-->\n\n<p>ボディのチャンクを送信します。\nこのメソッドを何回も呼び出すと、サーバへのリクエストボディをストリーム化できます － \nこのケースは <code>['Transfer-Encoding', 'chunked']</code> ヘッダでリクエストを生成したことを意味します。\n\n</p>\n<!--\nThe `chunk` argument should be a [Buffer][] or a string.\n-->\n\n<p><code>chunk</code> 引数は [Buffer][] または文字列です。\n\n</p>\n<!--\nThe `encoding` argument is optional and only applies when `chunk` is a string.\nDefaults to `'utf8'`.\n-->\n\n<p><code>encoding</code> 引数はオプションで、<code>chunk</code> が文字列の場合だけ適用されます。\nデフォルトは <code>'utf8'</code> です。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "request.end([data], [encoding])",
              "type": "method",
              "name": "end",
              "desc": "<!--\nFinishes sending the request. If any parts of the body are\nunsent, it will flush them to the stream. If the request is\nchunked, this will send the terminating `'0\\r\\n\\r\\n'`.\n-->\n\n<p>リクエストの送信を終了します。\nボディのいくつかの部分がまだ送信されていない場合、それはストリームにフラッシュされます。\nリクエストがチャンク化されている場合、これは終端の <code>'0\\r\\n\\r\\n'</code> を送信します。\n\n</p>\n<!--\nIf `data` is specified, it is equivalent to calling\n`request.write(data, encoding)` followed by `request.end()`.\n-->\n\n<p><code>data</code> が指定された場合は、\n<code>request.write(data, encoding)</code> に続けて <code>request.end()</code> を呼び出すのと等価です。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "request.abort()",
              "type": "method",
              "name": "abort",
              "desc": "<!--\nAborts a request.  (New since v0.3.8.)\n-->\n\n<p>リクエストをアボートします (v0.3.8 からの新機能)\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "request.setTimeout(timeout, [callback])",
              "type": "method",
              "name": "setTimeout",
              "desc": "<!--\nOnce a socket is assigned to this request and is connected\n[socket.setTimeout()][] will be called.\n-->\n\n<p>このリクエストにソケットが割り当てられて接続した際に、\n[socket.setTimeout()][] が呼び出されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "timeout"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "request.setNoDelay([noDelay])",
              "type": "method",
              "name": "setNoDelay",
              "desc": "<!--\nOnce a socket is assigned to this request and is connected\n[socket.setNoDelay()][] will be called.\n-->\n\n<p>このリクエストにソケットが割り当てられて接続した際に、\n[socket.setNoDelay()][] が呼び出されます。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "noDelay",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "request.setSocketKeepAlive([enable], [initialDelay])",
              "type": "method",
              "name": "setSocketKeepAlive",
              "desc": "<!--\nOnce a socket is assigned to this request and is connected\n[socket.setKeepAlive()][] will be called.\n-->\n\n<p>このリクエストにソケットが割り当てられて接続した際に、\n[socket.setKeepAlive()][] が呼び出されます。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "enable",
                      "optional": true
                    },
                    {
                      "name": "initialDelay",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "HTTP"
    },
    {
      "textRaw": "HTTPS",
      "name": "https",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<!--\nHTTPS is the HTTP protocol over TLS/SSL. In Node this is implemented as a\nseparate module.\n-->\n\n<p>HTTPS は TLS/SSL 上の HTTP プロトコルです。\nNode ではこれらは別のモジュールとして実装されています。\n\n</p>\n",
      "classes": [
        {
          "textRaw": "Class: https.Server",
          "type": "class",
          "name": "https.Server",
          "desc": "<!--\nThis class is a subclass of `tls.Server` and emits events same as\n`http.Server`. See `http.Server` for more information.\n-->\n\n<p>このクラスは <code>tls.Server</code> のサブクラスで、<code>http.Server</code> と同様のイベントを生成します。\nより詳しくは <code>http.Server</code> を参照してください。\n\n</p>\n"
        },
        {
          "textRaw": "Class: https.Agent",
          "type": "class",
          "name": "https.Agent",
          "desc": "<!--\nAn Agent object for HTTPS similar to [http.Agent][].  See [https.request()][]\nfor more information.\n-->\n\n<p>HTTPS 用の Agent オブジェクトで，[http.Agent][] と同様です。\n詳細は [https.request()][] を参照してください。\n\n</p>\n"
        }
      ],
      "methods": [
        {
          "textRaw": "https.createServer(options, [requestListener])",
          "type": "method",
          "name": "createServer",
          "desc": "<!--\nReturns a new HTTPS web server object. The `options` is similar to\n[tls.createServer()][].  The `requestListener` is a function which is\nautomatically added to the `'request'` event.\n-->\n\n<p>新しい HTTPS Web サーバオブジェクトを返します。\n<code>option</code> は [tls.createServer()][] と同じです。\n<code>requestListener</code> は関数で、 <code>'request'</code> イベントに自動的に追加されます。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>// curl -k https://localhost:8000/\nvar https = require('https');\nvar fs = require('fs');\n\nvar options = {\n  key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),\n  cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem')\n};\n\nhttps.createServer(options, function (req, res) {\n  res.writeHead(200);\n  res.end("hello world\\n");\n}).listen(8000);</code></pre>\n<!--\nOr\n-->\n\n<p>または:\n\n</p>\n<pre><code>var https = require('https');\nvar fs = require('fs');\n\nvar options = {\n  pfx: fs.readFileSync('server.pfx')\n};\n\nhttps.createServer(options, function (req, res) {\n  res.writeHead(200);\n  res.end("hello world\\n");\n}).listen(8000);</code></pre>\n",
          "methods": [
            {
              "textRaw": "server.listen(path, [callback])",
              "type": "method",
              "name": "listen",
              "desc": "<!--\nSee [http.listen()][] for details.\n-->\n\n<p>詳細は [http.listen()][] を参照してください。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "handle"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "path"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.listen(handle, [callback])",
              "type": "method",
              "name": "listen",
              "desc": "<!--\nSee [http.listen()][] for details.\n-->\n\n<p>詳細は [http.listen()][] を参照してください。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "handle"
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "server.close([callback])",
              "type": "method",
              "name": "close",
              "desc": "<p>See [http.close()][] for details.\n\n</p>\n<p>詳細は [http.close()][] を参照してください。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "requestListener",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "https.request(options, callback)",
          "type": "method",
          "name": "request",
          "desc": "<!--\nMakes a request to a secure web server.\n-->\n\n<p>セキュアな Web サーバへのリクエストを作成します。\n\n</p>\n<!--\n`options` can be an object or a string. If `options` is a string, it is\nautomatically parsed with [url.parse()](url.html#url.parse).\n-->\n\n<p><code>options</code> はオブジェクトまたは文字列です。\n<code>options</code> が文字列なら、それは自動的に <a href="\"url.html#url.parse\"">url.parse()</a>\nによって解析されます。\n\n</p>\n<!--\nAll options from [http.request()][] are valid.\n-->\n\n<p>[http.request()][] の全てと同様のオプションが指定できます。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var https = require('https');\n\nvar options = {\n  hostname: 'encrypted.google.com',\n  port: 443,\n  path: '/',\n  method: 'GET'\n};\n\nvar req = https.request(options, function(res) {\n  console.log("statusCode: ", res.statusCode);\n  console.log("headers: ", res.headers);\n\n  res.on('data', function(d) {\n    process.stdout.write(d);\n  });\n});\nreq.end();\n\nreq.on('error', function(e) {\n  console.error(e);\n});</code></pre>\n<!--\nThe options argument has the following options\n-->\n\n<p><code>options</code> 引数は以下のオプションを持ちます。\n\n</p>\n<!--\n- `host`: A domain name or IP address of the server to issue the request to.\n  Defaults to `'localhost'`.\n- `hostname`: To support `url.parse()` `hostname` is preferred over `host`\n- `port`: Port of remote server. Defaults to 443.\n- `method`: A string specifying the HTTP request method. Defaults to `'GET'`.\n- `path`: Request path. Defaults to `'/'`. Should include query string if any.\n  E.G. `'/index.html?page=12'`\n- `headers`: An object containing request headers.\n- `auth`: Basic authentication i.e. `'user:password'` to compute an\n  Authorization header.\n- `agent`: Controls [Agent][] behavior. When an Agent is used request will\n  default to `Connection: keep-alive`. Possible values:\n - `undefined` (default): use [globalAgent][] for this host and port.\n - `Agent` object: explicitly use the passed in `Agent`.\n - `false`: opts out of connection pooling with an Agent, defaults request to\n   `Connection: close`.\n-->\n\n<ul>\n<li><code>host</code>: リクエストを発行するサーバのドメイン名または IP アドレス。</li>\n<li><code>hostname</code>: <code>url.parse()</code> で扱える文字列をサポートします。\n<code>hostname</code> は <code>host</code> を上書きします。</li>\n<li><code>port</code>: リモートサーバのポート。デフォルトは 443 です。</li>\n<li><code>method</code>: HTTPS リクエストのメソッドの文字列。デフォルトは <code>'GET'</code> です。</li>\n<li><code>path</code>: リクエストのパス。デフォルトは <code>'/'</code> です。\n必要なら問い合わせ文字列を含めるべきです．\n例 <code>'/index.html?page=12'</code></li>\n<li><code>headers</code>: リクエストヘッダを含むオブジェクト。</li>\n<li><code>auth</code>: べーしく認証すなわち Authorization ヘッダのための <code>'user:password'</code>。</li>\n<li><code>agent</code>: [Agent][] の振る舞いを制御します。\nエージェントが使われる場合、<code>Connection:keep-alive</code> がデフォルトになります。\n可能な値は:<ul>\n<li><code>undefined</code> (デフォルト): ホストとポートで [globalAgent][] を使用します。</li>\n<li><code>Agent</code> オブジェクト: 明示的に渡された <code>Agent</code> を使用します。</li>\n<li><code>false</code>: Agent によるコネクションプーリングを使用しません。\n<code>Connection:close</code> の場合のデフォルトです。</li>\n</ul>\n</li>\n</ul>\n<!--\nThe following options from [tls.connect()][] can also be specified. However, a\n[globalAgent][] silently ignores these.\n-->\n\n<p>以下の [tls.connect()][] 由来のオプションを指定することもできますが、\nグローバル [globalAgent][] はこれらを無視します。\n\n</p>\n<!--\n- `pfx`: Certificate, Private key and CA certificates to use for SSL. Default `null`.\n- `key`: Private key to use for SSL. Default `null`.\n- `passphrase`: A string of passphrase for the private key or pfx. Default `null`.\n- `cert`: Public x509 certificate to use. Default `null`.\n- `ca`: An authority certificate or array of authority certificates to check\n  the remote host against.\n- `ciphers`: A string describing the ciphers to use or exclude. Consult\n  <http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT> for\n  details on the format.\n- `rejectUnauthorized`: If `true`, the server certificate is verified against\n  the list of supplied CAs. An `'error'` event is emitted if verification\n  fails. Verification happens at the connection level, *before* the HTTP\n  request is sent. Default `true`.\n- `secureProtocol`: The SSL method to use, e.g. `SSLv3_method` to force\n  SSL version 3. The possible values depend on your installation of\n  OpenSSL and are defined in the constant [SSL_METHODS][].\n-->\n\n<ul>\n<li><code>pfx</code>: SSL で使用する証明書、秘密鍵、認証局の証明書。\n デフォルトは <code>null</code> です。</li>\n<li><code>key</code>: SSL で使用する秘密鍵。デフォルトは <code>null</code> です。</li>\n<li><code>passphrase</code>: 秘密鍵または pfx のパスフレーズを表す文字列。\n デフォルトは <code>null</code> です。</li>\n<li><code>cert</code>: x509公開証明書。デフォルトは <code>null</code> です。</li>\n<li><code>ca</code>: リモートホストをチェックする信頼できる認証局または認証局の配列。</li>\n<li><code>ciphers</code>: 使用または除外する暗号を記述した文字列。\n詳細は <a href="\"http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT\"">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>\nを参照してください。</li>\n<li><code>rejectUnauthorized</code>: <code>true</code> の場合、サーバ証明書は提供された認証局の\nリストによって検証されます。\n認証されなかった場合は <code>'error'</code> イベントが生成されます。\n認証は HTTP リクエストが送信される <em>前</em> にコネクションレベルで行われます。\nデフォルトは <code>true</code> です。</li>\n<li><code>secureProtocol</code>: 使用する SSL 方式、たとえば <code>SSLv3_method</code> は\nSSL バージョン 3 を強制します。可能な値はインストールされている OpenSSL と、\nその定数 [SSL_METHODS][] の定義に依存します。</li>\n</ul>\n<!--\nIn order to specify these options, use a custom `Agent`.\n-->\n\n<p>これらのオプションを指定するには、カスタムエージェントを使用します。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var options = {\n  hostname: 'encrypted.google.com',\n  port: 443,\n  path: '/',\n  method: 'GET',\n  key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),\n  cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem')\n};\noptions.agent = new https.Agent(options);\n\nvar req = https.request(options, function(res) {\n  ...\n}</code></pre>\n<!--\nOr does not use an `Agent`.\n-->\n\n<p>あるいは、エージェントを使用しません。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var options = {\n  hostname: 'encrypted.google.com',\n  port: 443,\n  path: '/',\n  method: 'GET',\n  key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),\n  cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem'),\n  agent: false\n};\n\nvar req = https.request(options, function(res) {\n  ...\n}</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "https.get(options, callback)",
          "type": "method",
          "name": "get",
          "desc": "<!--\nLike `http.get()` but for HTTPS.\n-->\n\n<p><code>http.get()</code> と同様ですが HTTPS です。\n\n</p>\n<!--\n`options` can be an object or a string. If `options` is a string, it is\nautomatically parsed with [url.parse()](url.html#url.parse).\n-->\n\n<p><code>options</code> はオブジェクトまたは文字列です。\n<code>options</code> が文字列なら、それは自動的に <a href="\"url.html#url.parse\"">url.parse()</a>\nによって解析されます。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var https = require('https');\n\nhttps.get('https://encrypted.google.com/', function(res) {\n  console.log("statusCode: ", res.statusCode);\n  console.log("headers: ", res.headers);\n\n  res.on('data', function(d) {\n    process.stdout.write(d);\n  });\n\n}).on('error', function(e) {\n  console.error(e);\n});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "https.globalAgent",
          "name": "globalAgent",
          "desc": "<!--\nGlobal instance of [https.Agent][] for all HTTPS client requests.\n-->\n\n<p>全ての HTTPS クライアントリクエストで使用される、デフォルトの\n[https.Agent][] のインスタンスです。\n\n</p>\n"
        }
      ],
      "type": "module",
      "displayName": "HTTPS"
    },
    {
      "textRaw": "URL",
      "name": "url",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<!--\nThis module has utilities for URL resolution and parsing.\nCall `require('url')` to use it.\n-->\n\n<p>このモジュールはURLの解決や解析の為のユーティリティを持ちます。\n利用するには <code>require('url')</code> を呼び出してください。\n\n</p>\n<!--\nParsed URL objects have some or all of the following fields, depending on\nwhether or not they exist in the URL string. Any parts that are not in the URL\nstring will not be in the parsed object. Examples are shown for the URL\n-->\n\n<p>解析されたURLオブジェクトは、URL文字列の中に存在するかどうかに応じて\n次に示すフィールドをいくつかもしくは全てを持ちます。\nURL文字列に含まれないフィールドは解析結果のオブジェクトに含まれません。\n次のURLで例を示します。\n\n</p>\n<p><code>'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</code>\n\n</p>\n<!--\n* `href`: The full URL that was originally parsed. Both the protocol and host are lowercased.\n\n    Example: `'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'`\n\n* `protocol`: The request protocol, lowercased.\n\n    Example: `'http:'`\n\n* `host`: The full lowercased host portion of the URL, including port\n  information.\n\n    Example: `'host.com:8080'`\n\n* `auth`: The authentication information portion of a URL.\n\n    Example: `'user:pass'`\n\n* `hostname`: Just the lowercased hostname portion of the host.\n\n    Example: `'host.com'`\n\n* `port`: The port number portion of the host.\n\n    Example: `'8080'`\n\n* `pathname`: The path section of the URL, that comes after the host and\n  before the query, including the initial slash if present.\n\n    Example: `'/p/a/t/h'`\n\n* `search`: The 'query string' portion of the URL, including the leading\n  question mark.\n\n    Example: `'?query=string'`\n\n* `path`: Concatenation of `pathname` and `search`.\n\n    Example: `'/p/a/t/h?query=string'`\n\n* `query`: Either the 'params' portion of the query string, or a\n  querystring-parsed object.\n\n    Example: `'query=string'` or `{'query':'string'}`\n\n* `hash`: The 'fragment' portion of the URL including the pound-sign.\n\n    Example: `'#hash'`\n-->\n\n<ul>\n<li><p><code>href</code>: 解析する前の完全な URL。protocol と host はどちらも小文字化されます。</p>\n<p>  例: <code>'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</code></p>\n</li>\n<li><p><code>protocol</code>: リクエストのプロトコル。小文字化されます。</p>\n<p>  例: <code>'http:'</code></p>\n</li>\n<li><p><code>host</code>: URL の完全で小文字化されたホスト情報。ポート番号を含みます。</p>\n<p>  例: <code>'host.com:8080'</code></p>\n</li>\n<li><p><code>auth</code>: URL の認証情報。</p>\n<p>  例: <code>'user:pass'</code></p>\n</li>\n<li><p><code>hostname</code>: ホスト情報の中の小文字化されたホスト名。</p>\n<p>  例: <code>'host.com'</code></p>\n</li>\n<li><p><code>port</code>: ホスト情報の中のポート番号。</p>\n<p>  例: <code>'8080'</code></p>\n</li>\n<li><p><code>pathname</code>: URL のパス部分。ホスト情報からクエリまでの間に位置し、\n最初にスラッシュが存在する場合はそれも含みます。</p>\n<p>  例: <code>'/p/a/t/h'</code></p>\n</li>\n<li><p><code>search</code>: URL のクエリ文字列。先頭の ? マークも含みます。</p>\n<p>  例: <code>'?query=string'</code></p>\n</li>\n<li><p><code>path</code>: <code>pathname</code> と <code>search</code> を連結した文字列。</p>\n<p>  例: <code>'/p/a/t/h?query=string'</code></p>\n</li>\n<li><p><code>query</code>: クエリの変数部分の文字列、もしくはクエリ文字列を解析した\nオブジェクト。</p>\n<p>  例: <code>'query=string'</code> or <code>{'query':'string'}</code></p>\n</li>\n<li><p><code>hash</code>: URL の # マークを含む部分。</p>\n<p>  例: <code>'#hash'</code></p>\n</li>\n</ul>\n<!--\nThe following methods are provided by the URL module:\n-->\n\n<p>以下のメソッドはURLモジュールにより提供されます:\n\n</p>\n",
      "methods": [
        {
          "textRaw": "url.parse(urlStr, [parseQueryString], [slashesDenoteHost])",
          "type": "method",
          "name": "parse",
          "desc": "<!--\nTake a URL string, and return an object.\n\nPass `true` as the second argument to also parse\nthe query string using the `querystring` module.\nDefaults to `false`.\n\nPass `true` as the third argument to treat `//foo/bar` as\n`{ host: 'foo', pathname: '/bar' }` rather than\n`{ pathname: '//foo/bar' }`. Defaults to `false`.\n-->\n\n<p>URL文字列を引数に取り、解析結果のオブジェクトを返します。\n\n</p>\n<p><code>querystring</code> モジュールを使ってクエリ文字列も解析したい場合は、\n第 2 引数に <code>true</code> を渡してください。\nデフォルトは <code>false</code> です。\n\n</p>\n<p><code>//foo/bar</code> を <code>{ pathname: '//foo/bar' }</code> ではなく\n<code>{ host: 'foo', pathname: '/bar' }</code> としたい場合は、\n第 3 引数に <code>true</code> を渡してください。\nデフォルトは <code>false</code> です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "urlStr"
                },
                {
                  "name": "parseQueryString",
                  "optional": true
                },
                {
                  "name": "slashesDenoteHost",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "url.format(urlObj)",
          "type": "method",
          "name": "format",
          "desc": "<!--\nTake a parsed URL object, and return a formatted URL string.\n-->\n\n<p>URL オブジェクトを引数に取り、フォーマットした URL 文字列を返します。\n\n</p>\n<!--\n* `href` will be ignored.\n* `protocol`is treated the same with or without the trailing `:` (colon).\n  * The protocols `http`, `https`, `ftp`, `gopher`, `file` will be\n    postfixed with `://` (colon-slash-slash).\n  * All other protocols `mailto`, `xmpp`, `aim`, `sftp`, `foo`, etc will\n    be postfixed with `:` (colon)\n* `auth` will be used if present.\n* `hostname` will only be used if `host` is absent.\n* `port` will only be used if `host` is absent.\n* `host` will be used in place of `hostname` and `port`\n* `pathname` is treated the same with or without the leading `/` (slash)\n* `search` will be used in place of `query`\n* `query` (object; see `querystring`) will only be used if `search` is absent.\n* `search` is treated the same with or without the leading `?` (question mark)\n* `hash` is treated the same with or without the leading `#` (pound sign, anchor)\n-->\n\n<ul>\n<li><code>href</code> は無視されます。</li>\n<li><code>protocol</code> の末尾に <code>:</code> (コロン) があってもなくても同じように扱われます。<ul>\n<li><code>http</code>、<code>https</code>、<code>ftp</code>、<code>gopher</code>、<code>file</code> は末尾に <code>://</code>\n(コロン、スラッシュ、スラッシュ) が付けられます。</li>\n<li><code>mailto</code>、<code>xmpp</code>、<code>aim</code>、<code>sftp</code>、<code>foo</code> など、その他のプロトコルは末尾に <code>:</code>\n(コロン) が付けられます。</li>\n</ul>\n</li>\n<li><code>auth</code> が与えられると使われます。</li>\n<li><code>hostname</code> は <code>host</code> が与えられなかった場合だけ使われます。</li>\n<li><code>port</code> は <code>host</code> が与えられなかった場合だけ使われます。</li>\n<li><code>host</code> は <code>hostname</code>、<code>port</code> の位置で使われます。</li>\n<li><code>pathname</code> の先頭に <code>/</code> (スラッシュ) があってもなくても同じように扱われます。</li>\n<li><code>search</code> は <code>query</code> の位置で使われます。</li>\n<li><code>query</code> (文字列ではなくオブジェクトです; <code>querystring</code> を参照してください) は <code>search</code> が与えられなかった場合だけ使われます。</li>\n<li><code>search</code> の先頭に <code>?</code> (クエスチョンマーク) があってもなくても同じように扱われます。</li>\n<li><code>hash</code> の先頭に <code>#</code> (シャープ, アンカー) があってもなくても同じように扱われます。</li>\n</ul>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "urlObj"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "url.resolve(from, to)",
          "type": "method",
          "name": "resolve",
          "desc": "<!--\nTake a base URL, and a href URL, and resolve them as a browser would for\nan anchor tag.  Examples:\n-->\n\n<p>ベースとなる URL と相対 URL を引数に取り、ブラウザがアンカータグに対して行うのと同様に URL を解決します。例:\n\n</p>\n<pre><code>url.resolve('/one/two/three', 'four')         // '/one/two/four'\nurl.resolve('http://example.com/', '/one')    // 'http://example.com/one'\nurl.resolve('http://example.com/one', '/two') // 'http://example.com/two'</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "from"
                },
                {
                  "name": "to"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "URL"
    },
    {
      "textRaw": "Query String",
      "name": "querystring",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<!--\nThis module provides utilities for dealing with query strings.\nIt provides the following methods:\n-->\n\n<p>このモジュールはクエリ文字列を処理するユーティリティを提供します。 以下のメソッドから成ります:\n\n</p>\n",
      "methods": [
        {
          "textRaw": "querystring.stringify(obj, [sep], [eq])",
          "type": "method",
          "name": "stringify",
          "Serialize an object to a query string.\nOptionally override the default separator (`'&'`) and assignment (`'": "'`)\ncharacters.",
          "desc": "<p>クエリオブジェクトを文字列へ直列化します。\nオプションとしてデフォルトの区切り文字 (デフォルトは <code>'&'</code>) と代入文字\n(デフォルトは <code>'='</code>) を上書き指定できます。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>querystring.stringify({ foo: 'bar', baz: ['qux', 'quux'], corge: '' })\n// returns\n'foo=bar&baz=qux&baz=quux&corge='\n\nquerystring.stringify({foo: 'bar', baz: 'qux'}, ';', ':')\n// returns\n'foo:bar;baz:qux'</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "obj"
                },
                {
                  "name": "sep",
                  "optional": true
                },
                {
                  "name": "eq",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "querystring.parse(str, [sep], [eq], [options])",
          "type": "method",
          "name": "parse",
          "Deserialize a query string to an object.\nOptionally override the default separator (`'&'`) and assignment (`'": "'`)\ncharacters.\n\nOptions object may contain `maxKeys` property (equal to 1000 by default), it'll\nbe used to limit processed keys. Set it to 0 to remove key count limitation.",
          "desc": "<p>クエリ文字列をオブジェクトに復元します。\nオプションとしてデフォルトの区切り文字 (<code>'&'</code>) と代入文字 (<code>'='</code>)\nを上書き指定できます。\n\n</p>\n<p>オプションオブジェクトは <code>maxKeys</code> を含むことができます (デフォルトは\n1000 です)。それはキーを処理する上限として使われます。\n0 を設定すると制限は取り除かれます。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>querystring.parse('foo=bar&baz=qux&baz=quux&corge')\n// returns\n{ foo: 'bar', baz: ['qux', 'quux'], corge: '' }</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "str"
                },
                {
                  "name": "sep",
                  "optional": true
                },
                {
                  "name": "eq",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "querystring.escape",
          "name": "escape",
          "desc": "<!--\nThe escape function used by `querystring.stringify`,\nprovided so that it could be overridden if necessary.\n-->\n\n<p>escape 関数は <code>querystring.stringify</code> で使用されていて、必要な場合にオーバーライドできるよう提供されています。\n\n</p>\n"
        },
        {
          "textRaw": "querystring.unescape",
          "name": "unescape",
          "desc": "<!--\nThe unescape function used by `querystring.parse`,\nprovided so that it could be overridden if necessary.\n-->\n\n<p>unescape関数は <code>querystring.parse</code> で使用されていて、必要な場合にオーバーライドできるよう提供されています。\n\n</p>\n"
        }
      ],
      "type": "module",
      "displayName": "querystring"
    },
    {
      "textRaw": "punycode",
      "name": "punycode",
      "stability": 2,
      "stabilityText": "Unstable",
      "desc": "<!--\n[Punycode.js](http://mths.be/punycode) is bundled with Node.js v0.6.2+. Use\n`require('punycode')` to access it. (To use it with other Node.js versions,\nuse npm to install the `punycode` module first.)\n-->\n\n<p><a href="\"http://mths.be/punycode\"">Punycode.js</a> は Node.js v0.6.2 以降に\nバンドルされています。\nアクセスするには <code>require('punycode')</code> を使用します\n(他のバージョンの Node.js でこれを使用するには、先に npm を使用して <code>punycode</code>\nモジュールをインストールしてください)。\n\n</p>\n",
      "methods": [
        {
          "textRaw": "punycode.decode(string)",
          "type": "method",
          "name": "decode",
          "desc": "<!--\nConverts a Punycode string of ASCII code points to a string of Unicode code\npoints.\n-->\n\n<p>ASCII コードポイントによる Punycode 文字列を Unicode コードポイントに\n変換します。\n\n</p>\n<pre><code>// decode domain name parts\npunycode.decode('maana-pta'); // 'mañana'\npunycode.decode('--dqo34k'); // '☃-⌘'</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "string"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "punycode.encode(string)",
          "type": "method",
          "name": "encode",
          "desc": "<!--\nConverts a string of Unicode code points to a Punycode string of ASCII code\npoints.\n-->\n\n<p>Unicode コードポイントを ASCII コードポイントによる Punycode 文字列に\n変換します。\n\n</p>\n<pre><code>// encode domain name parts\npunycode.encode('mañana'); // 'maana-pta'\npunycode.encode('☃-⌘'); // '--dqo34k'</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "string"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "punycode.toUnicode(domain)",
          "type": "method",
          "name": "toUnicode",
          "desc": "<!--\nConverts a Punycode string representing a domain name to Unicode. Only the\nPunycoded parts of the domain name will be converted, i.e. it doesn't matter if\nyou call it on a string that has already been converted to Unicode.\n-->\n\n<p>Punycode 文字列で表現されたドメイン名を Unicode に変換します。\nドメイン名の中の Punycode 化された文字列だけが変換されます。\nそのため、すでに Unicode に変換された文字列でも気にせずに渡すことができます。\n\n</p>\n<pre><code>// decode domain names\npunycode.toUnicode('xn--maana-pta.com'); // 'mañana.com'\npunycode.toUnicode('xn----dqo34k.com'); // '☃-⌘.com'</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "punycode.toASCII(domain)",
          "type": "method",
          "name": "toASCII",
          "desc": "<!--\nConverts a Unicode string representing a domain name to Punycode. Only the\nnon-ASCII parts of the domain name will be converted, i.e. it doesn't matter if\nyou call it with a domain that's already in ASCII.\n-->\n\n<p>Unicode 文字列で表現されたドメイン名を Punycode に変換します。\nドメイン名の中の非 ASCII 文字だけが変換されます。\nすなわち、すでに ASCII 化されたドメインでも気にせずに渡すことができます。\n\n</p>\n<pre><code>// encode domain names\npunycode.toASCII('mañana.com'); // 'xn--maana-pta.com'\npunycode.toASCII('☃-⌘.com'); // 'xn----dqo34k.com'</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "domain"
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "punycode.ucs2",
          "name": "ucs2",
          "modules": [
            {
              "textRaw": "punycode.ucs2.decode(string)",
              "name": "punycode.ucs2.decode(string)",
              "desc": "<!--\nCreates an array containing the decimal code points of each Unicode character\nin the string. While [JavaScript uses UCS-2\ninternally](http://mathiasbynens.be/notes/javascript-encoding), this function\nwill convert a pair of surrogate halves (each of which UCS-2 exposes as\nseparate characters) into a single code point, matching UTF-16.\n-->\n\n<p>文字列中の Unicode 文字のコードポイントに対応する数値を含む配列を作成します。\n<a href="\"http://mathiasbynens.be/notes/javascript-encoding\"">JavaScript uses UCS-2 internally</a>\nのように、この関数はサロゲートペア (それぞれは UCS-2 の独立した文字) を\nUTF-16 にマッチする一つのコードポイントに変換します。\n\n</p>\n<pre><code>punycode.ucs2.decode('abc'); // [97, 98, 99]\n// surrogate pair for U+1D306 tetragram for centre:\npunycode.ucs2.decode('\\uD834\\uDF06'); // [0x1D306]</code></pre>\n",
              "type": "module",
              "displayName": "punycode.ucs2.decode(string)"
            },
            {
              "textRaw": "punycode.ucs2.encode(codePoints)",
              "name": "punycode.ucs2.encode(codepoints)",
              "desc": "<!--\nCreates a string based on an array of decimal code points.\n-->\n\n<p>コードポイントの数値を含む配列を元に文字列を作成します。\n\n</p>\n<pre><code>punycode.ucs2.encode([97, 98, 99]); // 'abc'\npunycode.ucs2.encode([0x1D306]); // '\\uD834\\uDF06'</code></pre>\n",
              "type": "module",
              "displayName": "punycode.ucs2.encode(codePoints)"
            }
          ]
        },
        {
          "textRaw": "punycode.version",
          "name": "version",
          "desc": "<!--\nA string representing the current Punycode.js version number.\n-->\n\n<p>現在の Punycode.js のバージョン番号を表す文字列です。\n\n</p>\n"
        }
      ],
      "type": "module",
      "displayName": "punycode"
    },
    {
      "textRaw": "Readline",
      "name": "readline",
      "stability": 2,
      "stabilityText": "Unstable",
      "desc": "<!--\nTo use this module, do `require('readline')`. Readline allows reading of a\nstream (such as `process.stdin`) on a line-by-line basis.\n-->\n\n<p>このモジュールを使用するには、<code>require('readline')</code> をします。\nReadline はストリーム (たとえば <code>process.stdin</code>)\nを行ごとに読み込むことを可能にします。\n\n</p>\n<!--\nNote that once you've invoked this module, your node program will not\nterminate until you've closed the interface. Here's how to allow your\nprogram to gracefully exit:\n-->\n\n<p>このモジュールを一度起動すると、このインタフェースを\nクローズするまで node プログラムは終了しないことに注意してください。\nプログラムをスムーズに終了する方法を以下に示します:\n\n</p>\n<pre><code>var readline = require('readline');\n\nvar rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.question("What do you think of node.js? ", function(answer) {\n  // TODO: Log the answer in a database\n  console.log("Thank you for your valuable feedback:", answer);\n\n  rl.close();\n});</code></pre>\n",
      "methods": [
        {
          "textRaw": "readline.createInterface(options)",
          "type": "method",
          "name": "createInterface",
          "desc": "<!--\nCreates a readline `Interface` instance. Accepts an \"options\" Object that takes\nthe following values:\n-->\n\n<p>行を読み込む <code>Interface</code> のインスタンスを作成します。\n以下の値を含む <code>options</code> オブジェクトを受け取ります。\n\n</p>\n<!--\n - `input` - the readable stream to listen to (Required).\n\n - `output` - the writable stream to write readline data to (Required).\n\n - `completer` - an optional function that is used for Tab autocompletion. See\n   below for an example of using this.\n\n - `terminal` - pass `true` if the `input` and `output` streams should be\n   treated like a TTY, and have ANSI/VT100 escape codes written to it.\n   Defaults to checking `isTTY` on the `output` stream upon instantiation.\n-->\n\n<ul>\n<li><p><code>input</code> - 監視する入力ストリーム (必須)。</p>\n</li>\n<li><p><code>output</code> - 読み込んだデータを書くための出力ストリーム (必須)。</p>\n</li>\n<li><p><code>completer</code> - タブによる自動補完のための関数 (オプション)。\n後述の例を参照してください。</p>\n</li>\n<li><p><code>terminal</code> - <code>input</code> および <code>output</code> ストリームが TTY デバイスで、\nANSI/VT100 エスケープコードを出力する場合は <code>true</code> を渡します。\nデフォルトはインスタンス生成時に <code>output</code> に対して\n<code>isTTY</code> でチェックします。</p>\n</li>\n</ul>\n<!--\nThe `completer` function is given the current line entered by the user, and\nis supposed to return an Array with 2 entries:\n-->\n\n<p><code>completer</code> 関数にはユーザが入力した現在の行が与えられ、\n2 つのエントリを含む配列を返すことが期待されます:\n\n</p>\n<!--\n 1. An Array with matching entries for the completion.\n\n 2. The substring that was used for the matching.\n-->\n\n<ol>\n<li><p>補完によってマッチするエントリの配列。</p>\n</li>\n<li><p>マッチングに使用された部分文字列。</p>\n</li>\n</ol>\n<!--\nWhich ends up looking something like:\n`[[substr1, substr2, ...], originalsubstring]`.\n-->\n\n<p>それは次のようになります:\n<code>[[substr1, substr2, ...], originalsubstring]</code>。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>function completer(line) {\n  var completions = '.help .error .exit .quit .q'.split(' ')\n  var hits = completions.filter(function(c) { return c.indexOf(line) == 0 })\n  // show all completions if none found\n  return [hits.length ? hits : completions, line]\n}</code></pre>\n<!--\nAlso `completer` can be run in async mode if it accepts two arguments:\n-->\n\n<p><code>completer</code> が二つの引数を持つなら、それは非同期モードで実行されます。\n\n</p>\n<pre><code>function completer(linePartial, callback) {\n  callback(null, [['123'], linePartial]);\n}</code></pre>\n<!--\n`createInterface` is commonly used with `process.stdin` and\n`process.stdout` in order to accept user input:\n-->\n\n<p><code>createInterface</code> には通常、ユーザからの入力を受け取るために <code>process.stdin</code> と\n<code>process.stdout</code> が使用されます。\n\n</p>\n<pre><code>var readline = require('readline');\nvar rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});</code></pre>\n<!--\nOnce you have a readline instance, you most commonly listen for the\n`\"line\"` event.\n-->\n\n<p>readline のインスタンスを作成すると、ほとんどの場合 <code>'line'</code> イベントを\n監視することになります。\n\n</p>\n<!--\nIf `terminal` is `true` for this instance then the `output` stream will get\nthe best compatibility if it defines an `output.columns` property, and fires\na `\"resize\"` event on the `output` if/when the columns ever change\n(`process.stdout` does this automatically when it is a TTY).\n-->\n\n<p>もしこのインスタンスの <code>terminal</code> が <code>true</code> の場合、\n<code>output</code> ストリームはもし <code>outout.columns</code> プロパティが定義されていれば\nそれに適合し、カラム幅が変更されると <code>output</code> 上で\n<code>'resize'</code> イベントが生成されます\n(<code>process.stdout</code> が TTY の場合、それは自動的に行われます)。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "readline.cursorTo(stream, x, y)",
          "type": "method",
          "name": "cursorTo",
          "desc": "<!--\nMove cursor to the specified position in a given TTY stream.\n-->\n\n<p>カーソルを与えられた TTY スクリーンの指定の位置に移動します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "stream"
                },
                {
                  "name": "x"
                },
                {
                  "name": "y"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "readline.moveCursor(stream, dx, dy)",
          "type": "method",
          "name": "moveCursor",
          "desc": "<!--\nMove cursor relative to it's current position in a given TTY stream.\n-->\n\n<p>カーソルを与えられた TTY スクリーンの現在の位置からの相対位置に移動します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "stream"
                },
                {
                  "name": "dx"
                },
                {
                  "name": "dy"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "readline.clearLine(stream, dir)",
          "type": "method",
          "name": "clearLine",
          "desc": "<!--\nClears current line of given TTY stream in a specified direction.\n`dir` should have one of following values:\n-->\n\n<p>与えられた TTY スクリーンの現在の行を指定された方向に消去します。\n<code>dir</code> は以下の値のいずれか:\n\n</p>\n<!--\n* `-1` - to the left from cursor\n* `1` - to the right from cursor\n* `0` - the entire line\n-->\n\n<ul>\n<li><code>-1</code> - カーソルから左方向</li>\n<li><code>1</code> - カーソルから右方向</li>\n<li><code>0</code> - 行全体</li>\n</ul>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "stream"
                },
                {
                  "name": "dir"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "readline.clearScreenDown(stream)",
          "type": "method",
          "name": "clearScreenDown",
          "desc": "<!--\nClears the screen from the current position of the cursor down.\n-->\n\n<p>スクリーンのカーソルより下を消去します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "stream"
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Interface",
          "type": "class",
          "name": "Interface",
          "desc": "<!--\nThe class that represents a readline interface with an input and output\nstream.\n-->\n\n<p>入力と出力を持つ readline インタフェースを表現するクラスです。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "rl.setPrompt(prompt, length)",
              "type": "method",
              "name": "setPrompt",
              "desc": "<!--\nSets the prompt, for example when you run `node` on the command line, you see\n`> `, which is node's prompt.\n-->\n\n<p>プロンプトを設定します。\nたとえば、コマンドプロンプトで <code>node</code> コマンドを実行すると、\n<code>> </code> を見ることができます。これが Node のプロンプトです。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "prompt"
                    },
                    {
                      "name": "length"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "rl.prompt([preserveCursor])",
              "type": "method",
              "name": "prompt",
              "desc": "<!--\nReadies readline for input from the user, putting the current `setPrompt`\noptions on a new line, giving the user a new spot to write. Set `preserveCursor`\nto `true` to prevent the cursor placement being reset to `0`.\n\nThis will also resume the `input` stream used with `createInterface` if it has\nbeen paused.\n-->\n\n<p>ユーザからの入力を 1 行読み込みます。\n現在の <code>setPrompt()</code> の値を新しい行に出力し、\nユーザに新しい入力エリアを与えます。\n<code>preserveCursor</code> を <code>true</code> に設定すると、カーソル位置が\n<code>0</code> にリセットされなくなります。\n\n</p>\n<p>これは、 <code>createInterface()</code> によって使われる <code>input</code> ストリームが\n中断されていれば再開します。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "preserveCursor",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "rl.question(query, callback)",
              "type": "method",
              "name": "question",
              "desc": "<!--\nPrepends the prompt with `query` and invokes `callback` with the user's\nresponse. Displays the query to the user, and then invokes `callback`\nwith the user's response after it has been typed.\n\nThis will also resume the `input` stream used with `createInterface` if\nit has been paused.\n-->\n\n<p><code>query</code> をプロンプトとして、ユーザが応答すると <code>callback</code> を起動します。\nユーザに質問を表示し、ユーザが応答をタイプすると、<code>callback</code> が起動されます。\n\n</p>\n<p>これは、 <code>createInterface()</code> によって使われる <code>input</code> ストリームが\n中断されていれば再開します。\n\n</p>\n<!--\nExample usage:\n-->\n\n<p>使用例:\n\n</p>\n<pre><code>interface.question('What is your favorite food?', function(answer) {\n  console.log('Oh, so your favorite food is ' + answer);\n});</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "query"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "rl.pause()",
              "type": "method",
              "name": "pause",
              "desc": "<!--\nPauses the readline `in` stream, allowing it to be resumed later if needed.\nPauses the readline `input` stream, allowing it to be resumed later if needed.\n-->\n\n<p><code>input</code> ストリームからの入力を中断します。\n必要なら後で再開することができます。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "rl.resume()",
              "type": "method",
              "name": "resume",
              "desc": "<!--\nResumes the readline `input` stream.\n-->\n\n<p><code>input</code> ストリームからの入力を再開します。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "rl.close()",
              "type": "method",
              "name": "close",
              "desc": "<!--\nCloses the `Interface` instance, relinquishing control on the `input` and\n`output` streams. The \"close\" event will also be emitted.\n-->\n\n<p><code>Interface</code> のインスタンスをクローズし、<code>input</code> および <code>output</code> ストリームの\n制御を解放します。<code>'close'</code> イベントも生成されます。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "rl.write(data, [key])",
              "type": "method",
              "name": "write",
              "desc": "<!--\nWrites `data` to `output` stream. `key` is an object literal to represent a key\nsequence; available if the terminal is a TTY.\n-->\n\n<p><code>data</code> を <code>output</code> ストリームに出力します。\n<code>key</code> はキーシーケンスを表現するオブジェクトリテラルです;\nターミナルが TTY の場合に有効です。\n\n</p>\n<!--\nThis will also resume the `input` stream if it has been paused.\n-->\n\n<p>これは、<code>input</code> ストリームが中断されていれば再開します。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>rl.write('Delete me!');\n// Simulate ctrl+u to delete the line written previously\nrl.write(null, {ctrl: true, name: 'u'});</code></pre>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "key",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "modules": [
        {
          "textRaw": "Events",
          "name": "events",
          "events": [
            {
              "textRaw": "Event: 'line'",
              "type": "event",
              "name": "line",
              "desc": "<p><code>function (line) {}</code>\n\n</p>\n<!--\nEmitted whenever the `input` stream receives a `\\n`, usually received when the\nuser hits enter, or return. This is a good hook to listen for user input.\n-->\n\n<p><code>input</code> ストリームから <code>\\n</code> を読み込むごとに生成されます。\n通常、ユーザがエンターまたはリターンを打つごとに受信します。\nこれはユーザ入力のよいフックとなります。\n\n</p>\n<!--\nExample of listening for `line`:\n-->\n\n<p><code>line</code> を監視する例:\n\n</p>\n<pre><code>rl.on('line', function (cmd) {\n  console.log('You just typed: '+cmd);\n});</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'pause'",
              "type": "event",
              "name": "pause",
              "desc": "<p><code>function () {}</code>\n\n</p>\n<!--\nEmitted whenever the `input` stream is paused.\n-->\n\n<p><code>input</code> ストリームが中断されたときに生成されます。\n\n</p>\n<!--\nAlso emitted whenever the `input` stream is not paused and receives the\n`SIGCONT` event. (See events `SIGTSTP` and `SIGCONT`)\n-->\n\n<p><code>input</code> ストリームが中断されていない時に <code>SIGCONT</code> イベントを受信した際にも\n生成されます (<code>SIGTSTP</code> および <code>SIGCONT</code> も参照してください)。\n\n</p>\n<!--\nExample of listening for `pause`:\n-->\n\n<p><code>'pause'</code> を監視する例:\n\n</p>\n<pre><code>rl.on('pause', function() {\n  console.log('Readline paused.');\n});</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'resume'",
              "type": "event",
              "name": "resume",
              "desc": "<p><code>function () {}</code>\n\n</p>\n<!--\nEmitted whenever the `input` stream is resumed.\n\nExample of listening for `resume`:\n-->\n\n<p><code>input</code> ストリームが再開された時に生成されます。\n\n</p>\n<p><code>'resume'</code> を監視する例:\n\n</p>\n<pre><code>rl.on('resume', function() {\n  console.log('Readline resumed.');\n});</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<p><code>function () {}</code>\n\n</p>\n<!--\nEmitted when `close()` is called.\n-->\n\n<p><code>close()</code> が呼ばれた場合に生成されます。\n\n</p>\n<!--\nAlso emitted when the `input` stream receives its \"end\" event. The `Interface`\ninstance should be considered \"finished\" once this is emitted. For example, when\nthe `input` stream receives `^D`, respectively known as `EOT`.\n-->\n\n<p><code>input</code> ストリームが <code>'end'</code> イベントを受け取った場合にも生成されます。\nこれが生成された後、<code>Interface</code> インスタンスは完了したと考えられるべきです。\n例えば、<code>input</code> ストリームが <code>EOT</code> として知られる <code>^D</code> を受け取った場合。\n\n</p>\n<!--\nThis event is also called if there is no `SIGINT` event listener present when\nthe `input` stream receives a `^C`, respectively known as `SIGINT`.\n-->\n\n<p>このイベントは <code>SIGINT</code> イベントリスナが与えられていない場合に、\n<code>input</code> ストリームが <code>SIGINT</code> として知られる <code>^C</code> を受け取った場合にも\n生成されます。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'SIGINT'",
              "type": "event",
              "name": "SIGINT",
              "desc": "<p><code>function () {}</code>\n\n</p>\n<!--\nEmitted whenever the `input` stream receives a `^C`, respectively known as\n`SIGINT`. If there is no `SIGINT` event listener present when the `input`\nstream receives a `SIGINT`, `pause` will be triggered.\n\nExample of listening for `SIGINT`:\n-->\n\n<p><code>input</code> ストリームが <code>SIGINT</code> として知られる <code>^C</code> を受信した場合に\n生成されます。\nもし <code>input</code> ストリームが <code>SIGINT</code> を受信した時に <code>'SIGINT'</code> イベントの\nリスナが存在しなければ、<code>'pause'</code> イベントがトリガされます。\n\n</p>\n<p><code>'SIGINT'</code> を監視する例:\n\n</p>\n<pre><code>rl.on('SIGINT', function() {\n  rl.question('Are you sure you want to exit?', function(answer) {\n    if (answer.match(/^y(es)?$/i)) rl.pause();\n  });\n});</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'SIGTSTP'",
              "type": "event",
              "name": "SIGTSTP",
              "desc": "<p><code>function () {}</code>\n\n</p>\n<!--\n**This does not work on Windows.**\n\nEmitted whenever the `input` stream receives a `^Z`, respectively known as\n`SIGTSTP`. If there is no `SIGTSTP` event listener present when the `input`\nstream receives a `SIGTSTP`, the program will be sent to the background.\n\nWhen the program is resumed with `fg`, the `pause` and `SIGCONT` events will be\nemitted. You can use either to resume the stream.\n\nThe `pause` and `SIGCONT` events will not be triggered if the stream was paused\nbefore the program was sent to the background.\n\nExample of listening for `SIGTSTP`:\n-->\n\n<p><strong>これは Windows では動作しません。</strong>\n\n</p>\n<p><code>input</code> ストリームが <code>SIGTSTP</code> として知られる <code>^Z</code> を受信した場合に\n生成されます。\nもし <code>input</code> ストリームが <code>SIGTSTP</code> を受信した時に <code>'SIGTSTP'</code> イベントの\nリスナが存在しなければ、プログラムはバックグラウンドに送られます。\n\n</p>\n<p>プログラムが <code>fg</code> により再開されると、<code>'pause'</code> および <code>'SIGCONT'</code> イベントが\n生成されます。どちらもストリームを再開するために使うことができます。\n\n</p>\n<p>プログラムがバックグラウンドに送られる前にストリームが中断されていると、\n<code>'pause'</code> および <code>'SIGCONT'</code> イベントは生成されません。\n\n</p>\n<p><code>'SIGTSTP'</code> を監視する例:\n\n</p>\n<pre><code>rl.on('SIGTSTP', function() {\n  // This will override SIGTSTP and prevent the program from going to the\n  // background.\n  console.log('Caught SIGTSTP.');\n});</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'SIGCONT'",
              "type": "event",
              "name": "SIGCONT",
              "desc": "<p><code>function () {}</code>\n\n</p>\n<!--\n**This does not work on Windows.**\n\nEmitted whenever the `input` stream is sent to the background with `^Z`,\nrespectively known as `SIGTSTP`, and then continued with `fg(1)`. This event\nonly emits if the stream was not paused before sending the program to the\nbackground.\n\nExample of listening for `SIGCONT`:\n-->\n\n<p><strong>これは Windows では動作しません。</strong>\n\n</p>\n<p><code>input</code> ストリームが <code>SIGTSTP</code> として知られる <code>^Z</code> によってバックグラウンドに\n送られた後で、<code>fg(1)</code> によって再開されるた場合に生成されます。\nこのイベントはプログラムがバックグラウンドに送られる前にストリームが中断されていなかった場合にのみ生成されます。\n\n</p>\n<p><code>'SIGCONT'</code> を監視する例:\n\n</p>\n<pre><code>rl.on('SIGCONT', function() {\n  // `prompt` will automatically resume the stream\n  rl.prompt();\n});</code></pre>\n<h2>Example: Tiny CLI</h2>\n<!--\nHere's an example of how to use all these together to craft a tiny command\nline interface:\n-->\n\n<p>全てを一緒に使う、小さなコマンドラインインタフェースの例:\n\n</p>\n<pre><code>var readline = require('readline'),\n    rl = readline.createInterface(process.stdin, process.stdout);\n\nrl.setPrompt('OHAI> ');\nrl.prompt();\n\nrl.on('line', function(line) {\n  switch(line.trim()) {\n    case 'hello':\n      console.log('world!');\n      break;\n    default:\n      console.log('Say what? I might have heard `' + line.trim() + '`');\n      break;\n  }\n  rl.prompt();\n}).on('close', function() {\n  console.log('Have a great day!');\n  process.exit(0);\n});</code></pre>\n",
              "params": []
            }
          ],
          "type": "module",
          "displayName": "Events"
        }
      ],
      "type": "module",
      "displayName": "Readline"
    },
    {
      "textRaw": "REPL",
      "name": "repl",
      "desc": "<!--\nA Read-Eval-Print-Loop (REPL) is available both as a standalone program and\neasily includable in other programs. The REPL provides a way to interactively\nrun JavaScript and see the results.  It can be used for debugging, testing, or\njust trying things out.\n-->\n\n<p>Read-Eval-Print-Loop (REPL) は単独のプログラムとしても他のプログラムに手軽に取り込む形でも利用することができます。\nREPL は対話的に JavaScript を実行して結果を確認する手段を提供します。 \nデバッグやテストやその他の様々なことを試す用途で利用されます。\n\n</p>\n<!--\nBy executing `node` without any arguments from the command-line you will be\ndropped into the REPL. It has simplistic emacs line-editing.\n-->\n\n<p>コマンドラインから <code>node</code> を引数無しで実行することで、REPL プログラムに入ります。\nREPL は Emacs 風の簡易な行編集機能を備えています。\n\n</p>\n<pre><code>mjr:~$ node\nType '.help' for options.\n> a = [ 1, 2, 3];\n[ 1, 2, 3 ]\n> a.forEach(function (v) {\n...   console.log(v);\n...   });\n1\n2\n3</code></pre>\n<p>より進んだ行編集を行うには、環境変数に <code>NODE_NO_READLINE=1</code>\nを設定してnodeを起動してください。\nこれによって main とデバッガ REPL を正規の端末設定で起動し、\n<code>rlwrap</code> を利用することができます。\n\n</p>\n<!--\nFor example, you could add this to your bashrc file:\n-->\n\n<p>例として、bashrc ファイルに以下のように設定を追加します:\n\n</p>\n<pre><code>alias node="env NODE_NO_READLINE=1 rlwrap node"</code></pre>\n",
      "For advanced line-editors, start node with the environmental variable\n`NODE_NO_READLINE": "1`. This will start the main and debugger REPL in canonical\nterminal settings which will allow you to use with `rlwrap`.",
      "methods": [
        {
          "textRaw": "repl.start(options)",
          "type": "method",
          "name": "start",
          "desc": "<!--\nReturns and starts a `REPLServer` instance. Accepts an \"options\" Object that\ntakes the following values:\n-->\n<code>REPLServer</code> インスタンスを作成して返します。\n以下の値を含む "options" オブジェクトを受け取ります。\n\n<!--\n - `prompt` - the prompt and `stream` for all I/O. Defaults to `> `.\n\n - `input` - the readable stream to listen to. Defaults to `process.stdin`.\n\n - `output` - the writable stream to write readline data to. Defaults to\n   `process.stdout`.\n\n - `terminal` - pass `true` if the `stream` should be treated like a TTY, and\n   have ANSI/VT100 escape codes written to it. Defaults to checking `isTTY`\n   on the `output` stream upon instantiation.\n\n - `eval` - function that will be used to eval each given line. Defaults to\n   an async wrapper for `eval()`. See below for an example of a custom `eval`.\n\n - `useColors` - a boolean which specifies whether or not the `writer` function\n   should output colors. If a different `writer` function is set then this does\n   nothing. Defaults to the repl's `terminal` value.\n\n - `useGlobal` - if set to `true`, then the repl will use the `global` object,\n   instead of running scripts in a separate context. Defaults to `false`.\n\n - `ignoreUndefined` - if set to `true`, then the repl will not output the\n   return value of command if it's `undefined`. Defaults to `false`.\n\n - `writer` - the function to invoke for each command that gets evaluated which\n   returns the formatting (including coloring) to display. Defaults to\n   `util.inspect`.\n-->\n\n<ul>\n<li><p><code>prompt</code> - プロンプト。デフォルトは <code>> </code> です。</p>\n</li>\n<li><p><code>input</code> - 監視する入力ストリーム。デフォルトは <code>process.stdin</code> です。</p>\n</li>\n<li><p><code>output</code> - 読み込んだデータを書き込む出力ストリーム。\nデフォルトは <code>process.stdout</code> です。</p>\n</li>\n<li><p><code>terminal</code> - もし <code>stream</code> が TTY で、ANSI/VT100 エスケープコードを\n出力するなら <code>true</code>。デフォルトはインスタンス作成時に <code>output</code>\nストリームを <code>isTTY</code> でチェックします。</p>\n</li>\n<li><p><code>eval</code> - 各行を評価するために使われる関数。デフォルトは <code>eval()</code> を\n非同期にラップした関数です。\n<code>eval</code> をカスタマイズする例は下記を参照してください。</p>\n</li>\n<li><p><code>useColors</code> - <code>write</code> 関数が色を付けるかどうかを指定するブーリアン値。\n<code>writer</code> に異なる関数が設定された場合、これは何もしません。\nデフォルトは repl の <code>terminal</code> の値です。</p>\n</li>\n<li><p><code>useGlobal</code> - もし <code>true</code> に設定されると、repl は独立したコンテキストを\n使う代わりに <code>global</code> オブジェクトを使用します。デフォルトは <code>false</code> です。</p>\n</li>\n<li><p><code>ignoreUndefined</code> - もし <code>true</code> に設定されると、repl はコマンドの戻り値が\n<code>undefined</code> だった場合にそれを出力しません。デフォルトは <code>false</code> です。</p>\n</li>\n<li><p><code>writer</code> - コマンドが評価されるごとに実行される関数で、表示するために\nフォーマット (色づけも含みます) して返します。\nデフォルトは <code>util.inspect</code> です。</p>\n</li>\n</ul>\n<!--\nYou can use your own `eval` function if it has following signature:\n-->\n\n<p>以下のシグネチャを持つ独自の <code>eval()</code> 関数を使うことができます。\n\n</p>\n<pre><code>function eval(cmd, context, filename, callback) {\n  callback(null, result);\n}</code></pre>\n<!--\nMultiple REPLs may be started against the same running instance of node.  Each\nwill share the same global object but will have unique I/O.\n-->\n\n<p>複数の REPL を起動した場合、同一の node インスタンスが実行されないことがあります。\nそれぞれの REPL はグローバルオブジェクトを共有しますが、I/O は固有のものを持ちます。\n\n</p>\n<!--\nHere is an example that starts a REPL on stdin, a Unix socket, and a TCP socket:\n-->\n\n<p>REPL を標準入力、Unix ドメインソケット、TCP ソケットのもとで起動する例を示します:\n\n</p>\n<pre><code>var net = require("net"),\n    repl = require("repl");\n\nconnections = 0;\n\nrepl.start({\n  prompt: "node via stdin> ",\n  input: process.stdin,\n  output: process.stdout\n});\n\nnet.createServer(function (socket) {\n  connections += 1;\n  repl.start({\n    prompt: "node via Unix socket> ",\n    input: socket,\n    output: socket\n  }).on('exit', function() {\n    socket.end();\n  })\n}).listen("/tmp/node-repl-sock");\n\nnet.createServer(function (socket) {\n  connections += 1;\n  repl.start({\n    prompt: "node via TCP socket> ",\n    input: socket,\n    output: socket\n  }).on('exit', function() {\n    socket.end();\n  });\n}).listen(5001);</code></pre>\n<!--\nRunning this program from the command line will start a REPL on stdin.  Other\nREPL clients may connect through the Unix socket or TCP socket. `telnet` is useful\nfor connecting to TCP sockets, and `socat` can be used to connect to both Unix and\nTCP sockets.\n-->\n\n<p>このプログラムをコマンドラインから実行すると、標準入力のもとで REPL が起動します。\n他の REPL クライアントは Unix ドメインソケットか TCP ソケットを介して接続することができます。\n<code>telnet</code> が TCP ソケットへの接続に便利です。\n<code>socat</code> は Unix ドメイン /TCP 両方のソケットへの接続に利用できます。\n\n</p>\n<!--\nBy starting a REPL from a Unix socket-based server instead of stdin, you can\nconnect to a long-running node process without restarting it.\n\nFor an example of running a \"full-featured\" (`terminal`) REPL over\na `net.Server` and `net.Socket` instance, see: https://gist.github.com/2209310\n\nFor an example of running a REPL instance over `curl(1)`,\nsee: https://gist.github.com/2053342\n-->\n\n<p>標準入力の代わりに Unix ドメインソケットをベースとしたサーバから REPL を起動することによって、\n再起動することなく node の常駐プロセスへ接続することができます。\n\n</p>\n<p><code>net.Server</code> および <code>net.Socket</code> インスタンス上の "フル機能の" (<code>terminal</code>)\nREPL を実行する例は、<a href="\"https://gist.github.com/2209310\"">https://gist.github.com/2209310</a> を参照してください。\n\n</p>\n<p><code>curl(1)</code> 上で REPL インスタンスを実行する例は、\n<a href="\"https://gist.github.com/2053342\"">https://gist.github.com/2053342</a> を参照してください。\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event: 'exit'",
              "type": "event",
              "name": "exit",
              "desc": "<p><code>function () {}</code>\n\n</p>\n<!--\nEmitted when the user exits the REPL in any of the defined ways. Namely, typing\n`.exit` at the repl, pressing Ctrl+C twice to signal SIGINT, or pressing Ctrl+D\nto signal \"end\" on the `input` stream.\n-->\n\n<p>何らかの方法でユーザが REPL を終了した場合に生成されます。\nすなわち、repl で <code>.exit</code> をタイプする、Ctrl+C を 2 回推して\nSIGINT を生成する、あるいは Ctrl+D を推して <code>input</code> ストリームで <code>'end'</code> を\n知らせるなどです。\n\n</p>\n<!--\nExample of listening for `exit`:\n-->\n\n<p><code>'exit'</code> を監視する例:\n\n</p>\n<pre><code>r.on('exit', function () {\n  console.log('Got "exit" event from repl!');\n  process.exit();\n});</code></pre>\n",
              "params": []
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "name": "options"
                }
              ]
            }
          ]
        }
      ],
      "miscs": [
        {
          "textRaw": "REPL Features",
          "name": "REPL Features",
          "type": "misc",
          "desc": "<!--\nInside the REPL, Control+D will exit.  Multi-line expressions can be input.\nTab completion is supported for both global and local variables.\n-->\n\n<p>REPL の中で Control+D を実行すると終了します。複数行に渡る式を入力とすることができます。\n\n</p>\n<!--\nThe special variable `_` (underscore) contains the result of the last expression.\n-->\n\n<p>特別な変数である <code>_</code> (アンダースコア) は一番最後の式の結果を保持します。\n\n</p>\n<pre><code>> [ "a", "b", "c" ]\n[ 'a', 'b', 'c' ]\n> _.length\n3\n> _ += 1\n4</code></pre>\n<!--\nThe REPL provides access to any variables in the global scope. You can expose\na variable to the REPL explicitly by assigning it to the `context` object\nassociated with each `REPLServer`.  For example:\n-->\n\n<p>REPL はグローバルスコープに存在する全ての変数にアクセス可能です。\nそれぞれの <code>REPLServer</code> に紐づく <code>context</code> オブジェクトに変数を付与することで、\n明示的に変数を公開させることが可能です。 例:\n\n</p>\n<pre><code>// repl_test.js\nvar repl = require("repl"),\n    msg = "message";\n\nrepl.start("> ").context.m = msg;</code></pre>\n<!--\nThings in the `context` object appear as local within the REPL:\n-->\n\n<p><code>context</code> オブジェクトに設定された変数は、REPL の中ではローカルな変数として現れます:\n\n</p>\n<pre><code>mjr:~$ node repl_test.js\n> m\n'message'</code></pre>\n<!--\nThere are a few special REPL commands:\n-->\n\n<p>特別な REPL コマンドがいくつかあります:\n\n</p>\n<!--\n  - `.break` - While inputting a multi-line expression, sometimes you get lost\n    or just don't care about completing it. `.break` will start over.\n  - `.clear` - Resets the `context` object to an empty object and clears any\n    multi-line expression.\n  - `.exit` - Close the I/O stream, which will cause the REPL to exit.\n  - `.help` - Show this list of special commands.\n  - `.save` - Save the current REPL session to a file\n    >.save ./file/to/save.js\n  - `.load` - Load a file into the current REPL session.\n    >.load ./file/to/load.js\n-->\n\n<ul>\n<li><code>.break</code> - 複数行に渡って式を入力している間に、途中で分からなくなったり完了させなくても良くなることがあります。<code>.break</code> で最初からやり直します。</li>\n<li><code>.clear</code> - <code>context</code> オブジェクトを空の状態にリセットし、複数行に入力している式をクリアします。</li>\n<li><code>.exit</code> - I/Oストリームを閉じ、REPLを終了させます。</li>\n<li><code>.help</code> - このコマンドの一覧を表示します。</li>\n<li><code>.save</code> - 現在の REPL セッションをファイルに保存します。<blockquote>\n<p>.save ./file/to/save.js</p>\n</blockquote>\n</li>\n<li><code>.load</code> - 現在の REPL セッションにファイルをロードします。<blockquote>\n<p>.load ./file/to/load.js</p>\n</blockquote>\n</li>\n</ul>\n<!--\nThe following key combinations in the REPL have these special effects:\n-->\n\n<p>REPL では、以下のキーコンビネーションは特別な効果を持ちます\n\n</p>\n<!--\n  - `<ctrl>C` - Similar to the `.break` keyword.  Terminates the current\n    command.  Press twice on a blank line to forcibly exit.\n  - `<ctrl>D` - Similar to the `.exit` keyword.\n-->\n\n<ul>\n<li><code><ctrl>C</code> - <code>.break</code> キーワードと同様です。\n現在のコマンドを終了します。\n強制的に終了したければ空の行で 2 回押してください。</li>\n<li><code><ctrl>D</code> - <code>.exit</code> キーワードと同様です。</li>\n</ul>\n"
        }
      ],
      "type": "module",
      "displayName": "REPL"
    },
    {
      "textRaw": "Executing JavaScript",
      "name": "vm",
      "stability": 2,
      "stabilityText": "Unstable. See Caveats, below.",
      "desc": "<!--\nYou can access this module with:\n-->\n\n<p>次のようにすることで、このモジュールにアクセスすることができます:\n\n</p>\n<pre><code>var vm = require('vm');</code></pre>\n<!--\nJavaScript code can be compiled and run immediately or compiled, saved, and run later.\n-->\n\n<p>JavaScript コードは、コンパイルされてすぐに実行されるか、コンパイルおよび保存されて後から実行されます。\n\n</p>\n",
      "modules": [
        {
          "textRaw": "Caveats",
          "name": "caveats",
          "The `vm` module has many known issues and edge cases. If you run into\nissues or unexpected behavior, please consult [the open issues on\nGitHub](https://github.com/joyent/node/issues?labels": "vm&state=open).\nSome of the biggest problems are described below.",
          "desc": "<p><code>vm</code> モジュールには既知の課題や特殊ケースがたくさんあります。\nもし問題や期待と異なる振る舞いを見つけた場合は、\n<a href="\"https://github.com/joyent/node/issues?labels=vm&state=open\"">GitHub 上の課題</a>\nに相談してください。大きな問題のいくつかは以下に示されます。\n\n</p>\n",
          "modules": [
            {
              "textRaw": "Sandboxes",
              "name": "sandboxes",
              "desc": "<!--\nThe `sandbox` argument to `vm.runInNewContext` and `vm.createContext`,\nalong with the `initSandbox` argument to `vm.createContext`, do not\nbehave as one might normally expect and their behavior varies\nbetween different versions of Node.\n-->\n\n<p><code>vm.runInNewContext</code> と、<code>vm.createContext</code> に <code>initSandbox</code> と共に渡される\n<code>sandbox</code> 引数は、通常期待される振る舞いをせず、それは Node のバージョン間で\n異なった振る舞いをします。\n\n</p>\n<!--\nThe key issue to be aware of is that V8 provides no way to directly\ncontrol the global object used within a context. As a result, while\nproperties of your `sandbox` object will be available in the context,\nany properties from the `prototype`s of the `sandbox` may not be\navailable. Furthermore, the `this` expression within the global scope\nof the context evaluates to the empty object (`{}`) instead of to\nyour sandbox.\n-->\n\n<p>知られている重要問題は、コンテキスト内で使用されるグローバルオブジェクトを\n直接制御する方法を V8 が提供しないことです。\nその結果、<code>sandbox</code> オブジェクトのプロパティがコンテキストから\n利用可能な間、<code>sandbox</code> のプロトタイプのプロパティを利用することが\nできないかもしれません。\nさらには、コンテキスト内のグローバルスコープにおける <code>this</code> が\nサンドボックスではなく、空のオブジェクト (<code>{}</code>) に評価されます。\n\n</p>\n<!--\nYour sandbox's properties are also not shared directly with the script.\nInstead, the properties of the sandbox are copied into the context at\nthe beginning of execution, and then after execution, the properties\nare copied back out in an attempt to propagate any changes.\n-->\n\n<p>サンドボックスのプロパティはまた、スクリプトに直接共有されません。\n代わりに、サンドボックスのプロパティは実行前にコンテキストにコピーされ、\n実行後、変更を伝播するためにプロパティはサンドボックスにコピーされます。\n\n</p>\n",
              "type": "module",
              "displayName": "Sandboxes"
            },
            {
              "textRaw": "Globals",
              "name": "globals",
              "Properties of the global object, like `Array` and `String`, have\ndifferent values inside of a context. This means that common\nexpressions like `[] instanceof Array` or\n`Object.getPrototypeOf([])": "== Array.prototype` may not produce\nexpected results when used inside of scripts evaluated via the `vm` module.",
              "desc": "<p><code>Array</code> や <code>String</code> などのグローバルオブジェクトのプロパティは、\nコンテキストの中では異なる値を持ちます。\nこれは  <code>[] instanceof Array</code> や\n<code>Object.getPrototypeOf([]) === Array.prototype</code> などのよくある式は、\n<code>vm</code> モジュールによって評価されるスクリプトの中で使われると、\n期待した結果にならないことを意味します。\n\n</p>\n<!--\nSome of these problems have known workarounds listed in the issues for\n`vm` on GitHub. for example, `Array.isArray` works around\nthe example problem with `Array`.\n-->\n\n<p>GitHub 上の <code>vm</code> に関する課題には、これらの問題に対する回避策があります。\n例えば、<code>Array.isArray</code> は <code>Array</code> に関する問題の例でもうまく動きます。\n\n</p>\n",
              "type": "module",
              "displayName": "Globals"
            }
          ],
          "type": "module",
          "displayName": "Caveats"
        }
      ],
      "methods": [
        {
          "textRaw": "vm.runInThisContext(code, [filename])",
          "type": "method",
          "name": "runInThisContext",
          "desc": "<!--\n`vm.runInThisContext()` compiles `code`, runs it and returns the result. Running\ncode does not have access to local scope. `filename` is optional, it's used only\nin stack traces.\n-->\n\n<p><code>vm.runInThisContext()</code> は <code>code</code> をコンパイルして実行し、結果を返します。\n実行されるコードはローカルスコープにアクセスしません。\n<code>filename</code> はオプションで、スタックトレースでのみ使用されます。\n\n</p>\n<!--\nExample of using `vm.runInThisContext` and `eval` to run the same code:\n-->\n\n<p><code>vm.runInThisContext</code> と <code>eval</code> で同じコードを実行する例:\n\n</p>\n<pre><code>var localVar = 123,\n    usingscript, evaled,\n    vm = require('vm');\n\nusingscript = vm.runInThisContext('localVar = 1;',\n  'myfile.vm');\nconsole.log('localVar: ' + localVar + ', usingscript: ' +\n  usingscript);\nevaled = eval('localVar = 1;');\nconsole.log('localVar: ' + localVar + ', evaled: ' +\n  evaled);\n\n// localVar: 123, usingscript: 1\n// localVar: 1, evaled: 1</code></pre>\n<!--\n`vm.runInThisContext` does not have access to the local scope, so `localVar` is unchanged.\n`eval` does have access to the local scope, so `localVar` is changed.\n-->\n\n<p><code>vm.runInThisContext</code> はローカルスコープにアクセスしないので、<code>localVar</code> は変更されません。\n<code>eval</code> はローカルスコープにアクセスするので、<code>localVar</code> は変更されます。\n\n</p>\n<!--\nIn case of syntax error in `code`, `vm.runInThisContext` emits the syntax error to stderr\nand throws an exception.\n-->\n\n<p><code>code</code> が文法エラーとなるケースでは、<code>vm.runInThisContext</code> は標準エラーに文法エラーを出力し、\n例外をスローします。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "code"
                },
                {
                  "name": "filename",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "vm.runInNewContext(code, [sandbox], [filename])",
          "type": "method",
          "name": "runInNewContext",
          "desc": "<!--\n`vm.runInNewContext` compiles `code`, then runs it in `sandbox` and returns the\nresult. Running code does not have access to local scope. The object `sandbox`\nwill be used as the global object for `code`.\n`sandbox` and `filename` are optional, `filename` is only used in stack traces.\n-->\n\n<p><code>vm.runInNewContext</code> は <code>code</code> をコンパイルし、それを <code>sandbox</code> の中で実行して\n結果を返します。\n実行されるコードはローカルスコープにアクセスしません。\n<code>sandbox</code> が <code>code</code> にとってのグローバルオブジェクトとして使われます。\n<code>sandbox</code> および <code>filename</code> はオプションで、<code>filename</code> \nスタックトレースでのみ使用されます。\n\n</p>\n<!--\nExample: compile and execute code that increments a global variable and sets a new one.\nThese globals are contained in the sandbox.\n-->\n\n<p>例: グローバル変数をインクリメントして新しい値をセットするコードをコンパイルおよび実行します。\nこれらのグローバル変数はサンドボックスに含まれます。\n\n</p>\n<pre><code>var util = require('util'),\n    vm = require('vm'),\n    sandbox = {\n      animal: 'cat',\n      count: 2\n    };\n\nvm.runInNewContext('count += 1; name = "kitty"', sandbox, 'myfile.vm');\nconsole.log(util.inspect(sandbox));\n\n// { animal: 'cat', count: 3, name: 'kitty' }</code></pre>\n<!--\nNote that running untrusted code is a tricky business requiring great care.  To prevent accidental\nglobal variable leakage, `vm.runInNewContext` is quite useful, but safely running untrusted code\nrequires a separate process.\n-->\n\n<p>慎重を要するビジネスでは、信頼できないコードの実行は細心の注意が求められることに注意してください。\n偶然グローバル変数が漏れてしまうことを防ぐために、<code>vm.runInNewContext</code> はとても役立ちますが、\n信頼できないコードを安全に実行するために別のプロセスを要求します。\n\n</p>\n<!--\nIn case of syntax error in `code`, `vm.runInNewContext` emits the syntax error to stderr\nand throws an exception.\n-->\n\n<p><code>code</code> が文法エラーとなるケースでは、\n<code>vm.runInNewContext</code> は標準エラーに文法エラーを出力し、例外をスローします。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "code"
                },
                {
                  "name": "sandbox",
                  "optional": true
                },
                {
                  "name": "filename",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "vm.runInContext(code, context, [filename])",
          "type": "method",
          "name": "runInContext",
          "desc": "<!--\n`vm.runInContext` compiles `code`, then runs it in `context` and returns the\nresult. A (V8) context comprises a global object, together with a set of\nbuilt-in objects and functions. Running code does not have access to local scope\nand the global object held within `context` will be used as the global object\nfor `code`.\n`filename` is optional, it's used only in stack traces.\n\nExample: compile and execute code in a existing context.\n-->\n\n<p><code>vm.runInContext</code> は <code>code</code> をコンパイルして、\n<code>context</code> をコンテキストとして実行し、その結果を返します。\n(V8 の) コンテキストは組み込みのオブジェクトと関数と共に、\nグローバルオブジェクトを含みます。\n実行されるコードはローカルスコープにアクセスせず、\n<code>context</code> が <code>code</code> にとってのグローバルオブジェクトとして使われます。\n<code>filename</code> はオプションで、スタックトレースでのみ使用されます。\n\n</p>\n<p>例: コードをコンパイルして既存のコンテキストで実行します。\n\n</p>\n<pre><code>var util = require('util'),\n    vm = require('vm'),\n    initSandbox = {\n      animal: 'cat',\n      count: 2\n    },\n    context = vm.createContext(initSandbox);\n\nvm.runInContext('count += 1; name = "CATT"', context, 'myfile.vm');\nconsole.log(util.inspect(context));\n\n// { animal: 'cat', count: 3, name: 'CATT' }</code></pre>\n<!--\nNote that `createContext` will perform a shallow clone of the supplied sandbox object in order to\ninitialize the global object of the freshly constructed context.\n\nNote that running untrusted code is a tricky business requiring great care.  To prevent accidental\nglobal variable leakage, `vm.runInContext` is quite useful, but safely running untrusted code\nrequires a separate process.\n\nIn case of syntax error in `code`, `vm.runInContext` emits the syntax error to stderr\nand throws an exception.\n-->\n\n<p><code>createContext</code> は、新たに構築されたコンテキストのグローバルオブジェクトを\n初期化するために、与えられた <code>context</code> オブジェクトの浅いクローンを\n作成することに注意してください。\n\n</p>\n<p>慎重を要するビジネスでは、信頼できないコードの実行は細心の注意が求められることに注意してください。\n偶然グローバル変数が漏れてしまうことを防ぐために、<code>vm.runInContext</code> はとても役立ちますが、\n信頼できないコードを安全に実行するために別のプロセスを要求します。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "code"
                },
                {
                  "name": "context"
                },
                {
                  "name": "filename",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "vm.createContext([initSandbox])",
          "type": "method",
          "name": "createContext",
          "desc": "<!--\n`vm.createContext` creates a new context which is suitable for use as the 2nd argument of a subsequent\ncall to `vm.runInContext`. A (V8) context comprises a global object together with a set of\nbuild-in objects and functions. The optional argument `initSandbox` will be shallow-copied\nto seed the initial contents of the global object used by the context.\n-->\n\n<p><code>vm.createContext</code> は、続けて呼び出される <code>vm.runInContext</code> の第 2 引数として\n使用するのに適した新しいコンテキストを作成します。\n(V8 の) コンテキストは組み込みのオブジェクトと関数と共に、\nグローバルオブジェクトを含みます。\nオプションの引数 <code>initSandbox</code> は、このコンテキストで使用される\nグローバルオブジェクトの初期値としてシャローコピーされます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "initSandbox",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "vm.createScript(code, [filename])",
          "type": "method",
          "name": "createScript",
          "desc": "<!--\n`createScript` compiles `code` but does not run it. Instead, it returns a\n`vm.Script` object representing this compiled code. This script can be run\nlater many times using methods below. The returned script is not bound to any\nglobal object. It is bound before each run, just for that run. `filename` is\noptional, it's only used in stack traces.\n-->\n\n<p><code>createScript</code> は <code>code</code> をコンパイルしますが、実行はしません。\n代わりに、コンパイルされたコードを表現する <code>vm.Script</code> オブジェクトを返します。\nこのスクリプトは後述のメソッドを使って後から何度でも実行することができます。\n返されるスクリプトはどのグローバルオブジェクトとも結びつけられていません。\nそれぞれの実行前に結びつけることで、そのとおりに実行されます。\n<code>filename</code> はオプションで、スタックトレースでのみ使用されます。\n\n</p>\n<!--\nIn case of syntax error in `code`, `createScript` prints the syntax error to stderr\nand throws an exception.\n-->\n\n<p><code>code</code> が文法エラーとなるケースでは、\n<code>createScript</code> は標準エラーに文法エラーを出力して例外をスローします。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "code"
                },
                {
                  "name": "filename",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Script",
          "type": "class",
          "name": "Script",
          "desc": "<!--\nA class for running scripts.  Returned by vm.createScript.\n-->\n\n<p>スクリプトを実行するクラスです。<code>vm.createScript()</code> によって返されます。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "script.runInThisContext()",
              "type": "method",
              "name": "runInThisContext",
              "desc": "<!--\nSimilar to `vm.runInThisContext` but a method of a precompiled `Script` object.\n`script.runInThisContext` runs the code of `script` and returns the result.\nRunning code does not have access to local scope, but does have access to the `global` object\n(v8: in actual context).\n-->\n\n<p><code>vm.runInThisContext</code> と同様ですが、\nこちらはプリコンパイル済みの <code>Script</code> オブジェクトのメソッドです。\n<code>script.runInThisContext</code> は <code>script</code> のコードを実行してその結果を返します。\n実行されるコードはローカルスコープにアクセスしませんが、\n<code>global</code> オブジェクト (v8: 実際のコンテキスト) にはアクセスします。\n\n</p>\n<!--\nExample of using `script.runInThisContext` to compile code once and run it multiple times:\n-->\n\n<p><code>script.runInThisContext</code> を使ってコードを一度だけコンパイルし、複数回実行する例:\n\n</p>\n<pre><code>var vm = require('vm');\n\nglobalVar = 0;\n\nvar script = vm.createScript('globalVar += 1', 'myfile.vm');\n\nfor (var i = 0; i < 1000 ; i += 1) {\n  script.runInThisContext();\n}\n\nconsole.log(globalVar);\n\n// 1000</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "script.runInNewContext([sandbox])",
              "type": "method",
              "name": "runInNewContext",
              "desc": "<!--\nSimilar to `vm.runInNewContext` a method of a precompiled `Script` object.\n`script.runInNewContext` runs the code of `script` with `sandbox` as the global object and returns the result.\nRunning code does not have access to local scope. `sandbox` is optional.\n-->\n\n<p><code>vm.runInNewContext</code> と同様ですが、\nこちらはプリコンパイル済みの <code>Script</code> オブジェクトのメソッドです。\n<code>script.runInNewContext</code> は <code>sandbox</code> がグローバルオブジェクトであるかのように\n<code>script</code> のコードを実行してその結果を返します。\n実行されるコードはローカルスコープにアクセスしません。\n<code>sandbox</code> はオプションです。\n\n</p>\n<!--\nExample: compile code that increments a global variable and sets one, then execute this code multiple times.\nThese globals are contained in the sandbox.\n-->\n\n<p>例: グローバル変数をインクリメントしてセットするコードをコンパイルして、このコードを複数回実行します。\nこれらのグローバル変数はサンドボックスに含まれます。\n\n</p>\n<pre><code>var util = require('util'),\n    vm = require('vm'),\n    sandbox = {\n      animal: 'cat',\n      count: 2\n    };\n\nvar script = vm.createScript('count += 1; name = "kitty"', 'myfile.vm');\n\nfor (var i = 0; i < 10 ; i += 1) {\n  script.runInNewContext(sandbox);\n}\n\nconsole.log(util.inspect(sandbox));\n\n// { animal: 'cat', count: 12, name: 'kitty' }</code></pre>\n<!--\nNote that running untrusted code is a tricky business requiring great care.  To prevent accidental\nglobal variable leakage, `script.runInNewContext` is quite useful, but safely running untrusted code\nrequires a separate process.\n-->\n\n<p>慎重を要するビジネスでは、信頼できないコードの実行は細心の注意が求められることに注意してください。\n偶然グローバル変数が漏れてしまうことを防ぐために、<code>script.runInNewContext</code> はとても役立ちますが、\n信頼できないコードを安全に実行するために別のプロセスを要求します。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "sandbox",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "vm"
    },
    {
      "textRaw": "Child Process",
      "name": "child_process",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<!--\nNode provides a tri-directional `popen(3)` facility through the\n`child_process` module.\n-->\n\n<p>Nodeは <code>child_process</code> モジュールを通じて、3 方向の <code>popen(3)</code>\n機能を提供します。\n\n</p>\n<!--\nIt is possible to stream data through a child's `stdin`, `stdout`, and\n`stderr` in a fully non-blocking way.  (Note that some programs use\nline-buffered I/O internally.  That doesn't affect node.js but it means\ndata you send to the child process is not immediately consumed.)\n-->\n\n<p>これは完全にノンブロッキングな方法で子プロセスの <code>stdin</code>、<code>stdout</code>、\nそして <code>stderr</code> を通じたデータストリームを実現します。\n(いくつかのプログラムは内部的にバッファリングされた I/O を使うことに\n注意してください。それは node.js には影響しませんが、\n子プロセスに送ったデータがすぐに消費されるとは限らないことを意味します)。\n\n</p>\n<!--\nTo create a child process use `require('child_process').spawn()`.\nTo create a child process use `require('child_process').spawn()` or\n`require('child_process').fork()`.  The semantics of each are slightly\ndifferent, and explained below.\n-->\n\n<p>子プロセスの生成は <code>require('child_process').spawn()</code> または\n<code>require('child_process').fork()</code> を使います。\nそれぞれの意味論は以下で説明するようにわずかに異なります。\n\n</p>\n",
      "classes": [
        {
          "textRaw": "Class: ChildProcess",
          "type": "class",
          "name": "ChildProcess",
          "desc": "<!--\n`ChildProcess` is an [EventEmitter][].\n-->\n\n<p><code>ChildProcess</code> は [EventEmitter][] です。\n\n</p>\n<!--\nChild processes always have three streams associated with them. `child.stdin`,\n`child.stdout`, and `child.stderr`.  These may be shared with the stdio\nstreams of the parent process, or they may be separate stream objects\nwhich can be piped to and from.\n\nThe ChildProcess class is not intended to be used directly.  Use the\n`spawn()` or `fork()` methods to create a Child Process instance.\n-->\n\n<p>子プロセスは常に 3 本のストリームと関連づけられています。\n<code>child.stdin</code>、<code>child.stdout</code>、そして <code>child.stderr</code> です。\nそれらは親プロセスの標準入出力ストリームを共有するかもしれませんし、\n独立したストリームオブジェクトにパイプでつながれているかもしれません。\n\n</p>\n",
          "events": [
            {
              "textRaw": "Event:  'error'",
              "type": "event",
              "name": "error",
              "desc": "<!--\n* `err` {Error Object} the error.\n-->\n\n<ul>\n<li><code>err</code> {Error Object} エラー。</li>\n</ul>\n<!--\nEmitted when:\n-->\n\n<p>次の場合に生成されます:\n\n</p>\n<!--\n1. The process could not be spawned, or\n2. The process could not be killed, or\n3. Sending a message to the child process failed for whatever reason.\n-->\n\n<ol>\n<li>プロセスを起動できなかった、または</li>\n<li>プロセスを殺すことができなかった、または</li>\n<li>何らかの理由で子プロセスにメッセージを送信することが失敗した。</li>\n</ol>\n<!--\nNote that the `exit`-event may or may not fire after an error has occured. If\nyou are listening on both events to fire a function, remember to guard against\ncalling your function twice.\n-->\n\n<p><code>exit</code> イベントはエラーが発生した後に生成されるかもしれないし、\nされないかもしれないことに注意してください。\nもし両方のイベントを同じ関数で監視した場合、その関数は2回の呼び出しに\n対処することを忘れないでください。\n\n</p>\n<!--\nSee also [`ChildProcess#kill()`](#child_process_child_kill_signal) and\n[`ChildProcess#send()`](#child_process_child_send_message_sendhandle).\n-->\n\n<p><a href="\"#child_process_child_kill_signal\""><code>ChildProcess#kill()</code></a> および\n<a href="\"#child_process_child_send_message_sendhandle\""><code>ChildProcess#send()</code></a>\nも参照してください。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event:  'exit'",
              "type": "event",
              "name": "exit",
              "desc": "<!--\n* `code` {Number} the exit code, if it exited normally.\n* `signal` {String} the signal passed to kill the child process, if it\n  was killed by the parent.\n-->\n\n<ul>\n<li><code>code</code> {Number} 通常に終了した場合は終了コード。</li>\n<li><code>signal</code> {String} 親プロセスによって終了させられた場合は、\n子プロセスを終了するために送られたシグナル。</li>\n</ul>\n<!--\nThis event is emitted after the child process ends. If the process terminated\nnormally, `code` is the final exit code of the process, otherwise `null`. If\nthe process terminated due to receipt of a signal, `signal` is the string name\nof the signal, otherwise `null`.\n-->\n\n<p>このイベントは子プロセスが終了した後で生成されます。\nプロセスが普通に終了した場合、<code>code</code> はプロセスの終了コードです。\nそれ以外の場合は <code>null</code> です。\nプロセスがシグナルを受け取って終了した場合、<code>signal</code> は文字列によるシグナルの名前です。\nそれ以外の場合は <code>null</code> です。\n\n</p>\n<!--\nNote that the child process stdio streams might still be open.\n-->\n\n<p>子プロセスの標準入出力ストリームはオープンしたままになっているかも\nしれないことに注意してください。\n\n</p>\n<!--\nAlso, note that node establishes signal handlers for `'SIGINT'` and `'SIGTERM`',\nso it will not terminate due to receipt of those signals, it will exit.\n-->\n\n<p>また、Node が 'SIGINT'<code> および </code>'SIGTERM<code>' に対するシグナルハンドラを\n確立するため、子プロセスがそれらのシグナルを受けとって終了しても、\n</code>signal` にはそれらのシグナルの名前が設定されないことに注意してください。\n\n</p>\n<!--\nSee `waitpid(2)`.\n-->\n\n<p><code>waitpid(2)</code> を参照してください。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<!--\n* `code` {Number} the exit code, if it exited normally.\n* `signal` {String} the signal passed to kill the child process, if it\n  was killed by the parent.\n-->\n\n<ul>\n<li><code>code</code> {Number} 普通に終了した場合は、その終了コード。</li>\n<li><code>signal</code> {String} 親プロセスによって殺された場合は、\n子プロセスを殺すために渡されたシグナル。</li>\n</ul>\n<!--\nThis event is emitted when the stdio streams of a child process have all\nterminated.  This is distinct from 'exit', since multiple processes\nmight share the same stdio streams.\n-->\n\n<p>このイベントは、子プロセスの標準入出力ストリームが全て終了した場合に\n生成されます。\n複数のプロセスが同じ標準入出力ストリームを共有するかもしれないので、\nこれは <code>'exit'</code> とは明確に異なります。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'disconnect'",
              "type": "event",
              "name": "disconnect",
              "desc": "<!--\nThis event is emitted after calling the `.disconnect()` method in the parent\nor in the child. After disconnecting it is no longer possible to send messages,\nand the `.connected` property is false.\n-->\n\n<p>このイベントは、親プロセスまたは子プロセスで <code>.disconnect()</code> メソッドが\n呼び出された場合に生成されます。\n切断の後では、プロセス間でメッセージを送信することはできず、\n<code>.connected</code> プロパティは <code>false</code> になります。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'message'",
              "type": "event",
              "name": "message",
              "desc": "<!--\n* `message` {Object} a parsed JSON object or primitive value\n* `sendHandle` {Handle object} a Socket or Server object\n-->\n\n<ul>\n<li><code>message</code> {Object} 解析済みの JSON オブジェクトまたはプリミティブ値</li>\n<li><code>sendHandle</code> {Handle object} ソケットまたはサーバオブジェクト</li>\n</ul>\n<!--\nMessages send by `.send(message, [sendHandle])` are obtained using the\n`message` event.\n-->\n\n<p><code>.send(message, [sendHandle])</code> によって送信されたメッセージは <code>'message'</code>\nイベントによって取得できます。\n\n</p>\n",
              "params": []
            }
          ],
          "properties": [
            {
              "textRaw": "`stdin` {Stream object} ",
              "name": "stdin",
              "desc": "<!--\nA `Writable Stream` that represents the child process's `stdin`.\nClosing this stream via `end()` often causes the child process to terminate.\n\nIf the child stdio streams are shared with the parent, then this will\nnot be set.\n-->\n\n<p>子プロセスの <code>stdin</code> を表現する <code>Writable Stream</code> です。\n多くの場合、<code>end()</code> を通じてこのストリームを閉じると子プロセスが終了する原因となります。\n\n</p>\n<p>子プロセスの標準入出力が親プロセスと共有されている場合は設定されません。\n\n</p>\n"
            },
            {
              "textRaw": "`stdout` {Stream object} ",
              "name": "stdout",
              "desc": "<!--\nA `Readable Stream` that represents the child process's `stdout`.\n\nIf the child stdio streams are shared with the parent, then this will\nnot be set.\n-->\n\n<p>子プロセスの <code>stdout</code> を表現する <code>Readable Stream</code> です。\n\n</p>\n<p>子プロセスの標準入出力が親プロセスと共有されている場合は設定されません。\n\n</p>\n"
            },
            {
              "textRaw": "`stderr` {Stream object} ",
              "name": "stderr",
              "desc": "<!--\nA `Readable Stream` that represents the child process's `stderr`.\n\nIf the child stdio streams are shared with the parent, then this will\nnot be set.\n-->\n\n<p>子プロセスの <code>stderr</code> を表現する <code>Readable Stream</code> です。\n\n</p>\n<p>子プロセスの標準入出力が親プロセスと共有されている場合は設定されません。\n\n</p>\n"
            },
            {
              "textRaw": "`pid` {Integer} ",
              "name": "pid",
              "desc": "<!--\nThe PID of the child process.\n-->\n\n<p>子プロセスの PID です。\n\n</p>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var spawn = require('child_process').spawn,\n    grep  = spawn('grep', ['ssh']);\n\nconsole.log('Spawned child pid: ' + grep.pid);\ngrep.stdin.end();</code></pre>\n"
            },
            {
              "textRaw": "child.connected",
              "name": "connected",
              "desc": "<!--\n* {Boolean} Set to false after `.disconnect' is called\n-->\n\n<ul>\n<li>{Boolean} <code>.disconnect' が呼び出されると </code>false` に設定される</li>\n</ul>\n<!--\nIf `.connected` is false, it is no longer possible to send messages.\n-->\n\n<p><code>.connected</code> が <code>false</code> の場合、メッセージを送信することはできません。\n\n</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "child.kill([signal])",
              "type": "method",
              "name": "kill",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`signal` {String} ",
                      "name": "signal",
                      "type": "String",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "signal",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nSend a signal to the child process. If no argument is given, the process will\nbe sent `'SIGTERM'`. See `signal(7)` for a list of available signals.\n-->\n\n<p>子プロセスにシグナルを送ります。\n引数が与えられない場合、子プロセスには <code>'SIGTERM'</code> が送られます。\n利用可能なシグナルの一覧は <code>signal(7)</code> を参照してください。\n\n\n</p>\n<pre><code>var spawn = require('child_process').spawn,\n    grep  = spawn('grep', ['ssh']);\n\ngrep.on('close', function (code, signal) {\n  console.log('child process terminated due to receipt of signal '+signal);\n});\n\n// send SIGHUP to process\ngrep.kill('SIGHUP');</code></pre>\n<!--\nMay emit an `'error'` event when the signal cannot be delivered. Sending a\nsignal to a child process that has already exited is not an error but may\nhave unforeseen consequences: if the PID (the process ID) has been reassigned\nto another process, the signal will be delivered to that process instead.\nWhat happens next is anyone's guess.\n-->\n\n<p>シグナルを送ることができなかった場合は <code>'error'</code> イベントが\n生成されるかもしれません。\n既に終了した子プロセスへシグナルを送信してもエラーにはならず、\n予想しない結果になるかもしれません:\nPID (プロセス ID) が他のプロセスに再割り当てされると、\nシグナルはそのプロセスに送信されてしまいます。\nそれで何が起こるかは誰にも予想できません。\n\n</p>\n<!--\nNote that while the function is called `kill`, the signal delivered to the\nchild process may not actually kill it.  `kill` really just sends a signal\nto a process.\n-->\n\n<p>この関数は <code>kill</code> と呼ばれるものの、\n子プロセスに届けられるシグナルが実際には子プロセスを殺さないかもしれないことに注意してください。\n<code>kill</code> はただプロセスにシグナルを送るだけです。\n\n</p>\n<!--\nSee `kill(2)`\n-->\n\n<p><code>kill(2)</code> を参照してください。\n\n</p>\n"
            },
            {
              "textRaw": "child.send(message, [sendHandle])",
              "type": "method",
              "name": "send",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`message` {Object} ",
                      "name": "message",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`sendHandle` {Handle object} ",
                      "name": "sendHandle",
                      "type": "Handle object",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "message"
                    },
                    {
                      "name": "sendHandle",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nWhen using `child_process.fork()` you can write to the child using\n`child.send(message, [sendHandle])` and messages are received by\na `'message'` event on the child.\n-->\n\n<p><code>child_process.fork()</code> を使うと、<code>child.send(message, [sendHandle])</code> を\n使って子プロセスにメッセージを送信し、子プロセスではそれを <code>'message'</code>\nイベントによって受け取ることができます。\n\n</p>\n<!--\nFor example:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var cp = require('child_process');\n\nvar n = cp.fork(__dirname + '/sub.js');\n\nn.on('message', function(m) {\n  console.log('PARENT got message:', m);\n});\n\nn.send({ hello: 'world' });</code></pre>\n<!--\nAnd then the child script, `'sub.js'` might look like this:\n-->\n\n<p>子プロセスの <code>'sub.js'</code> は次のようになります:\n\n</p>\n<pre><code>process.on('message', function(m) {\n  console.log('CHILD got message:', m);\n});\n\nprocess.send({ foo: 'bar' });</code></pre>\n<!--\nIn the child the `process` object will have a `send()` method, and `process`\nwill emit objects each time it receives a message on its channel.\n-->\n\n<p>子プロセスでは <code>process</code> オブジェクトは <code>send()</code> メソッドを持ち、\nそのチャネル上でメッセージを受信するたびにイベントを生成します。\n\n</p>\n<!--\nPlease note that the `send()` method on both the parent and child are\nsynchronous - sending large chunks of data is not advised (pipes can be used\ninstead, see\n[`child_process.spawn`](#child_process_child_process_spawn_command_args_options)).\n-->\n\n<p>親プロセスと子プロセスのいずれにおいても、<code>send()</code> メソッドは同期的です -\nデータの大きな塊を送信することは推奨されません\n(代わりにパイプを使うことが出来ます、\n<a href="\"#child_process_child_process_spawn_command_args_options\""><code>child_process.spawn</code></a>\nを参照してください)。\n\n</p>\n<!--\nThere is a special case when sending a `{cmd: 'NODE_foo'}` message. All messages\ncontaining a `NODE_` prefix in its `cmd` property will not be emitted in\nthe `message` event, since they are internal messages used by node core.\nMessages containing the prefix are emitted in the `internalMessage` event, you\nshould by all means avoid using this feature, it is subject to change without notice.\n-->\n\n<p>特別なケースとして、<code>{cmd: 'NODE_foo'}</code> のようなメッセージを\n送信する場合があります。\n<code>cmd</code> プロパティが接頭辞 <code>NODE_</code> を含む全てのメッセージは node のコアで\n使われる内部的なメッセージであるため、<code>'message'</code> イベントを生成しません。\nこの接頭辞を含むメッセージは <code>'internalMessage'</code> イベントを生成しますが、\nそれを使用すべきではありません。それは保証なしに変更される可能性があります。\n\n</p>\n<!--\nThe `sendHandle` option to `child.send()` is for sending a TCP server or\nsocket object to another process. The child will receive the object as its\nsecond argument to the `message` event.\n-->\n\n<p><code>child.send()</code> の <code>sendHandle</code> オプションは TCP サーバまたは\nソケットオブジェクトを他のプロセスに送信するためのものです。\n子プロセスはそれを <code>'message'</code> イベントの第 2 引数として受信します。\n\n</p>\n<!--\nEmits an `'error'` event if the message cannot be sent, for example because\nthe child process has already exited.\n-->\n\n<p>たとえば子プロセスが既に終了した場合など、メッセージを送信できなかった場合は\n<code>'error'</code> イベントが生成されます。\n\n</p>\n<h4>Example: sending server object</h4>\n<!--\nHere is an example of sending a server:\n-->\n\n<p>サーバを送信する例:\n\n</p>\n<pre><code>var child = require('child_process').fork('child.js');\n\n// Open up the server object and send the handle.\nvar server = require('net').createServer();\nserver.on('connection', function (socket) {\n  socket.end('handled by parent');\n});\nserver.listen(1337, function() {\n  child.send('server', server);\n});</code></pre>\n<!--\nAnd the child would the receive the server object as:\n-->\n\n<p>サーバオブジェクトを受信する子プロセス:\n\n</p>\n<pre><code>process.on('message', function(m, server) {\n  if (m === 'server') {\n    server.on('connection', function (socket) {\n      socket.end('handled by child');\n    });\n  }\n});</code></pre>\n<!--\nNote that the server is now shared between the parent and child, this means\nthat some connections will be handled by the parent and some by the child.\n-->\n\n<p>サーバは親プロセスと子プロセスで共有されることに注意してください。\nこれはコネクションが時には親あるいは子で処理されることを意味します。\n\n</p>\n<!--\nFor `dgram` servers the workflow is exactly the same.  Here you listen on\na `message` event instead of `connection` and use `server.bind` instead of\n`server.listen`.  (Currently only supported on UNIX platforms.)\n-->\n\n<p><code>dgram</code> サーバのワークフローも同じです。\n<code>connection</code> イベントの代わりに <code>message</code> イベントを監視し、\n<code>server.listen</code> の代わりに <code>server.bind</code> を使用してください\n(現時点では UNIX プラットフォームでのみサポートされています)。\n\n</p>\n<h4>Example: sending socket object</h4>\n<!--\nHere is an example of sending a socket. It will spawn two children and handle\nconnections with the remote address `74.125.127.100` as VIP by sending the\nsocket to a \"special\" child process. Other sockets will go to a \"normal\" process.\n-->\n\n<p>これはソケットを送信する例です。\nこれは二つの子プロセスを起動し、コネクションのリモートアドレスが VIP\n(<code>74.125.127.100</code>) ならソケットを "special" 子プロセスに送信します。\nその他のソケットは "normal" プロセスに送られます。\n\n</p>\n<pre><code>var normal = require('child_process').fork('child.js', ['normal']);\nvar special = require('child_process').fork('child.js', ['special']);\n\n// Open up the server and send sockets to child\nvar server = require('net').createServer();\nserver.on('connection', function (socket) {\n\n  // if this is a VIP\n  if (socket.remoteAddress === '74.125.127.100') {\n    special.send('socket', socket);\n    return;\n  }\n  // just the usual dudes\n  normal.send('socket', socket);\n});\nserver.listen(1337);</code></pre>\n<!--\nThe `child.js` could look like this:\n-->\n\n<p><code>chold.js</code> は次のようになります:\n\n</p>\n<pre><code>process.on('message', function(m, socket) {\n  if (m === 'socket') {\n    socket.end('You were handled as a ' + process.argv[2] + ' person');\n  }\n});</code></pre>\n<!--\nNote that once a single socket has been sent to a child the parent can no\nlonger keep track of when the socket is destroyed. To indicate this condition\nthe `.connections` property becomes `null`.\nIt is also recommended not to use `.maxConnections` in this condition.\n-->\n\n<p>一度ソケットが子プロセスに送信されると、親プロセスはもうソケットがいつ\n破棄されるか知ることができないことに注意してください。\nこの状態を示すために，<code>.connections</code> プロパティは <code>null</code> になります。\nこの状態では、<code>.maxConnections</code> も使わないことを推奨します。\n\n</p>\n"
            },
            {
              "textRaw": "child.disconnect()",
              "type": "method",
              "name": "disconnect",
              "desc": "<!--\nClose the IPC channel between parent and child, allowing the child to exit\ngracefully once there are no other connections keeping it alive. After calling\nthis method the `.connected` flag will be set to `false` in both the parent and\nchild, and it is no longer possible to send messages.\n-->\n\n<p>親プロセスと子プロセス間の IPC コネクションをクローズし、\n他の接続を持たない子プロセスが自然に終了することを可能にします。\nこのメソッドを呼び出すと、親プロセスと子プロセスの両方で <code>.connected</code> は\n<code>false</code> に設定され、メッセージを送信することはできなくなります。\n\n</p>\n<!--\nThe 'disconnect' event will be emitted when there are no messages in the process\nof being received, most likely immediately.\n-->\n\n<p>プロセスが受信するメッセージがなければ、おそらくはすぐに <code>'disconnect'</code>\nイベントが生成されます。\n\n</p>\n<!--\nNote that you can also call `process.disconnect()` in the child process.\n-->\n\n<p>子プロセスでも <code>process.disconnect()</code> を呼び出せることに注意してください。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        }
      ],
      "methods": [
        {
          "textRaw": "child_process.spawn(command, [args], [options])",
          "type": "method",
          "name": "spawn",
          "desc": "<!--\n* `command` {String} The command to run\n* `args` {Array} List of string arguments\n* `options` {Object}\n  * `cwd` {String} Current working directory of the child process\n  * `stdio` {Array|String} Child's stdio configuration. (See below)\n  * `customFds` {Array} **Deprecated** File descriptors for the child to use\n    for stdio.  (See below)\n  * `env` {Object} Environment key-value pairs\n  * `detached` {Boolean} The child will be a process group leader.  (See below)\n  * `uid` {Number} Sets the user identity of the process. (See setuid(2).)\n  * `gid` {Number} Sets the group identity of the process. (See setgid(2).)\n* return: {ChildProcess object}\n-->\n\n<ul>\n<li><code>command</code> {String} 実行するコマンド</li>\n<li><code>args</code> {Array} 文字列による引数の配列</li>\n<li><code>options</code> {Object}<ul>\n<li><code>cwd</code> {String} 子プロセスのカレントワーキングディレクトリ</li>\n<li><code>stdio</code> {Array|String} 子プロセスの標準入出力の設定 (後述)。</li>\n<li><code>customFds</code> {Array} <strong>Deprecated</strong> 子プロセスが標準入出力として使用する\nファイル記述子の配列 (後述)</li>\n<li><code>env</code> {Object} 環境変数として与えるキー・値のペア</li>\n<li><code>detached</code> {Boolean} 子プロセスがプロセスグループのリーダになるかどうか\n(後述)。</li>\n<li><code>uid</code> {Number} このプロセスのユーザ識別子を設定します\n (setuid(2) を参照)。</li>\n<li><code>gid</code> {Number} このプロセスのグループ識別子を設定します\n(setgid(2) を参照)。</li>\n</ul>\n</li>\n<li>return: {ChildProcess object}</li>\n</ul>\n<!--\nLaunches a new process with the given `command`, with  command line arguments in `args`.\nIf omitted, `args` defaults to an empty Array.\n-->\n\n<p><code>args</code> をコマンドライン引数として、与えられた <code>command</code> で新しいプロセスを起動します。\n<code>args</code> が省略された場合、空の配列がデフォルトとなります。\n\n</p>\n<!--\nThe third argument is used to specify additional options, which defaults to:\n-->\n\n<p>第 3 引数は追加のオプションを指定するために使われ、そのデフォルトは:\n\n</p>\n<pre><code>{ cwd: undefined,\n  env: process.env\n}</code></pre>\n<!--\n`cwd` allows you to specify the working directory from which the process is spawned.\nUse `env` to specify environment variables that will be visible to the new process.\n-->\n\n<p><code>cwd</code> で起動されたプロセスのワーキングディレクトリを指定することができます。\n<code>env</code> は新しいプロセスに見える環境変数を指定するために使います。\n\n</p>\n<!--\nExample of running `ls -lh /usr`, capturing `stdout`, `stderr`, and the exit code:\n-->\n\n<p>ls -lh /usr<code> を実行して </code>stdout<code>、</code>stderr`、および終了コードを取得する例:\n\n</p>\n<pre><code>var spawn = require('child_process').spawn,\n    ls    = spawn('ls', ['-lh', '/usr']);\n\nls.stdout.on('data', function (data) {\n  console.log('stdout: ' + data);\n});\n\nls.stderr.on('data', function (data) {\n  console.log('stderr: ' + data);\n});\n\nls.on('close', function (code) {\n  console.log('child process exited with code ' + code);\n});</code></pre>\n<!--\nExample: A very elaborate way to run 'ps ax | grep ssh'\n-->\n\n<p>とても手の込んだ方法で実行する 'ps ax | grep ssh' の例:\n\n</p>\n<pre><code>var spawn = require('child_process').spawn,\n    ps    = spawn('ps', ['ax']),\n    grep  = spawn('grep', ['ssh']);\n\nps.stdout.on('data', function (data) {\n  grep.stdin.write(data);\n});\n\nps.stderr.on('data', function (data) {\n  console.log('ps stderr: ' + data);\n});\n\nps.on('close', function (code) {\n  if (code !== 0) {\n    console.log('ps process exited with code ' + code);\n  }\n  grep.stdin.end();\n});\n\ngrep.stdout.on('data', function (data) {\n  console.log('' + data);\n});\n\ngrep.stderr.on('data', function (data) {\n  console.log('grep stderr: ' + data);\n});\n\ngrep.on('close', function (code) {\n  if (code !== 0) {\n    console.log('grep process exited with code ' + code);\n  }\n});</code></pre>\n<!--\nExample of checking for failed exec:\n-->\n\n<p>exec の失敗をチェックする例:\n\n</p>\n<pre><code>var spawn = require('child_process').spawn,\n    child = spawn('bad_command');\n\nchild.stderr.setEncoding('utf8');\nchild.stderr.on('data', function (data) {\n  if (/^execvp\\(\\)/.test(data)) {\n    console.log('Failed to start child process.');\n  }\n});</code></pre>\n<!--\nNote that if spawn receives an empty options object, it will result in\nspawning the process with an empty environment rather than using\n`process.env`. This due to backwards compatibility issues with a deprecated\nAPI.\n-->\n\n<p><code>spawn()</code> は空の <code>options</code> オブジェクトを受け取ると、\n<code>process.env</code> を使うのではなく，空の環境変数で子プロセスを起動します。\nこれは廃止された API との互換性のためです。\n\n</p>\n<!--\nThe 'stdio' option to `child_process.spawn()` is an array where each\nindex corresponds to a fd in the child.  The value is one of the following:\n-->\n\n<p><code>child_process.spawn()</code> の <code>stdio</code> オプションは配列で、\nそれぞれのインデックスは子プロセスの fd に対応します。\n要素の値は以下のいずれかです:\n\n</p>\n<!--\n1. `'pipe'` - Create a pipe between the child process and the parent process.\n   The parent end of the pipe is exposed to the parent as a property on the\n   `child_process` object as `ChildProcess.stdio[fd]`. Pipes created for\n   fds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout\n   and ChildProcess.stderr, respectively.\n2. `'ipc'` - Create an IPC channel for passing messages/file descriptors\n   between parent and child. A ChildProcess may have at most *one* IPC stdio\n   file descriptor. Setting this option enables the ChildProcess.send() method.\n   If the child writes JSON messages to this file descriptor, then this will\n   trigger ChildProcess.on('message').  If the child is a Node.js program, then\n   the presence of an IPC channel will enable process.send() and\n   process.on('message').\n3. `'ignore'` - Do not set this file descriptor in the child. Note that Node\n   will always open fd 0 - 2 for the processes it spawns. When any of these is\n   ignored node will open `/dev/null` and attach it to the child's fd.\n4. `Stream` object - Share a readable or writable stream that refers to a tty,\n   file, socket, or a pipe with the child process. The stream's underlying\n   file descriptor is duplicated in the child process to the fd that \n   corresponds to the index in the `stdio` array. Note that the stream must\n   have an underlying descriptor (file streams do not until the `'open'`\n   event has occurred).\n5. Positive integer - The integer value is interpreted as a file descriptor \n   that is is currently open in the parent process. It is shared with the child\n   process, similar to how `Stream` objects can be shared.\n6. `null`, `undefined` - Use default value. For stdio fds 0, 1 and 2 (in other\n   words, stdin, stdout, and stderr) a pipe is created. For fd 3 and up, the\n   default is `'ignore'`.\n-->\n\n<ol>\n<li><code>'pipe'</code> - 子プロセスと親プロセスの間でパイプを作成します。\nパイプの親側の端点は <code>child_process</code> オブジェクトのプロパティ\n<code>ChildProcess.stdio[fd]</code> として親プロセスに公開されます。\nfd 0～2 はそれぞれ、<code>ChildProcess.stdin</code>、<code>ChildProcess.stdout</code>、\n<code>ChildProcess.stderr</code> としても参照可能です。</li>\n<li><code>'ipc'</code> - 親プロセスと子プロセスの間でメッセージパッシングのための\nIPC チャネル／ファイル記述子を作成します。\n<code>ChildProcess</code> は標準入出力に高々一つの IPC ファイル記述子を持ちます。\nこのオプションを設定すると、<code>ChildProcess.send()</code> メソッドが有効になります。\n子プロセスがこのファイル記述子に JSON メッセージを書き込むと、\nそれは <code>ChildProcess.on('message')</code> を引き起こします。\n子プロセスが Node.js プログラムなら、IPC チャネルの存在は <code>process.send()</code>\nおよび <code>process.on('message')</code> を有効にします。</li>\n<li><code>'ignore'</code> - 子プロセスにファイル記述子を設定しません。\nNode は子プロセスを起動する際、常に fd 0～2 をオープンすることに\n注意してください。これらのうちのどれかが <code>'ignore'</code> の場合、node は\n<code>/dev/null</code> をオープンして、それを子プロセスの fd に割り当てます。</li>\n<li><code>Stream</code> オブジェクト - tty、ファイル、ソケット、またはパイプを参照する\n読み込みまたは書き込み可能なストリームを子プロセスと共有します。\nストリームの下層にあるファイル記述子は、子プロセスの <code>stdio</code> 配列の\n対応する位置にコピーされます。\nストリームは下層のファイル記述を持っていなければならないことに\n注意してください (ファイルストリームは <code>'open'</code> イベントが発生するまで\nそれを持ちません)。</li>\n<li>非負整数 - 整数の値を親プロセスが現在オープンしているファイル記述子として\n解釈されます。\nそれは <code>Stream</code> オブジェクトの場合と同様に子プロセスに共有されます。</li>\n<li><code>null</code>、<code>undefined</code> - デフォルト値を使用します。\n<code>stdio</code> の <code>fd</code> が 0、1、または 2 (言い換えると stdin、stdout、または\nstderr) の場合はパイプが作成されます。fd が 3 以上の場合、デフォルトは\n<code>'ignore'</code> です。</li>\n</ol>\n<!--\nAs a shorthand, the `stdio` argument may also be one of the following\nstrings, rather than an array:\n-->\n\n<p>簡易な記法として、<code>stdio</code> に配列ではなく以下の文字列の一つを指定することも\nできます。\n\n</p>\n<!--\n* `ignore` - `['ignore', 'ignore', 'ignore']`\n* `pipe` - `['pipe', 'pipe', 'pipe']`\n* `inherit` - `[process.stdin, process.stdout, process.stderr]` or `[0,1,2]`\n-->\n\n<ul>\n<li><code>ignore</code> - <code>['ignore', 'ignore', 'ignore']</code></li>\n<li><code>pipe</code> - <code>['pipe', 'pipe', 'pipe']</code></li>\n<li><code>inherit</code> - <code>[process.stdin, process.stdout, process.stderr]</code> または <code>[0,1,2]</code></li>\n</ul>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var spawn = require('child_process').spawn;\n\n// Child will use parent's stdios\nspawn('prg', [], { stdio: 'inherit' });\n\n// Spawn child sharing only stderr\nspawn('prg', [], { stdio: ['pipe', 'pipe', process.stderr] });\n\n// Open an extra fd=4, to interact with programs present a\n// startd-style interface.\nspawn('prg', [], { stdio: ['pipe', null, null, null, 'pipe'] });</code></pre>\n<!--\nIf the `detached` option is set, the child process will be made the leader of a\nnew process group.  This makes it possible for the child to continue running \nafter the parent exits.\n-->\n\n<p><code>detached</code> オプションが設定されると、子プロセスは新しいプロセスグループの\nリーダになります。\nこれは親プロセスが終了しても子プロセスの実行が継続することを可能にします。\n\n</p>\n<!--\nBy default, the parent will wait for the detached child to exit.  To prevent\nthe parent from waiting for a given `child`, use the `child.unref()` method,\nand the parent's event loop will not include the child in its reference count.\n-->\n\n<p>デフォルトでは、親プロセスは切り離された子プロセスの終了を待機します。\n親プロセスが <code>child</code> を待機することを防ぐには、<code>child.unref()</code> メソッドを\n使用し、親のイベントループに子のリファレンスカウントが含まれないようにします。\n\n</p>\n<!--\nExample of detaching a long-running process and redirecting its output to a\nfile:\n-->\n\n<p>長時間実行する子プロセスを切り離し、出力をファイルにリダイレクトする例:\n\n</p>\n<pre><code> var fs = require('fs'),\n     spawn = require('child_process').spawn,\n     out = fs.openSync('./out.log', 'a'),\n     err = fs.openSync('./out.log', 'a');\n\n var child = spawn('prg', [], {\n   detached: true,\n   stdio: [ 'ignore', out, err ]\n });\n\n child.unref();</code></pre>\n<!--\nWhen using the `detached` option to start a long-running process, the process\nwill not stay running in the background unless it is provided with a `stdio`\nconfiguration that is not connected to the parent.  If the parent's `stdio` is\ninherited, the child will remain attached to the controlling terminal.\n-->\n\n<p>長時間実行されるプロセスを開始するために <code>detached</code> オプションを使用する場合、\nその <code>stdio</code> が親と接続するような構成を与えられない限り、そのプロセスは\nバックグラウンドにとどまりません。\n親の <code>stdio</code> が継承されるなら、子プロセスは制御しているターミナルに\n接続されたままです。\n\n</p>\n<!--\nThere is a deprecated option called `customFds` which allows one to specify\nspecific file descriptors for the stdio of the child process. This API was\nnot portable to all platforms and therefore removed.\nWith `customFds` it was possible to hook up the new process' `[stdin, stdout,\nstderr]` to existing streams; `-1` meant that a new stream should be created.\nUse at your own risk.\n\nSee also: `child_process.exec()` and `child_process.fork()`\n-->\n\n<p>指定のファイル記述子を子プロセスの標準入出力に指定することを可能にする、\n<code>customFds</code> と呼ばれる廃止されたオプションがありました。\nこの API は全てのプラットフォームに移植可能ではないために削除されました。\n<code>customFds</code> は新しいプロセスの <code>[stdin, stdout, stderr]</code> を既存のストリームに接続することを可能にしました;\n<code>-1</code> は新しいストリームが作られなければならないことを意味していました。\n使用する場合は自己責任で。\n\n</p>\n<p>関連項目: <code>child_process.exec()</code> および <code>child_process.fork()</code>\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "command"
                },
                {
                  "name": "args",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "child_process.exec(command, [options], callback)",
          "type": "method",
          "name": "exec",
          "desc": "<!--\n* `command` {String} The command to run, with space-separated arguments\n* `options` {Object}\n  * `cwd` {String} Current working directory of the child process\n  * `env` {Object} Environment key-value pairs\n  * `encoding` {String} (Default: 'utf8')\n  * `timeout` {Number} (Default: 0)\n  * `maxBuffer` {Number} (Default: `200*1024`)\n  * `killSignal` {String} (Default: 'SIGTERM')\n* `callback` {Function} called with the output when process terminates\n  * `error` {Error}\n  * `stdout` {Buffer}\n  * `stderr` {Buffer}\n* Return: ChildProcess object\n-->\n\n<ul>\n<li><code>command</code> {String} 実行するコマンド、空白で区切られた引数を持ちます</li>\n<li><code>options</code> {Object}<ul>\n<li><code>cwd</code> {String} 子プロセスのカレントワーキングディレクトリ</li>\n<li><code>env</code> {Object} 環境変数として与えるキー・値のペア</li>\n<li><code>encoding</code> {String} (Default: 'utf8')</li>\n<li><code>timeout</code> {Number} (Default: 0)</li>\n<li><code>maxBuffer</code> {Number} (Default: 200*1024)</li>\n<li><code>killSignal</code> {String} (Default: 'SIGTERM')</li>\n</ul>\n</li>\n<li><code>callback</code> {Function} プロセスが終了するとその出力を伴って呼び出されます<ul>\n<li><code>error</code> {Error}</li>\n<li><code>stdout</code> {Buffer}</li>\n<li><code>stderr</code> {Buffer}</li>\n</ul>\n</li>\n<li>Return: <code>ChildProcess</code> オブジェクト</li>\n</ul>\n<!--\nRuns a command in a shell and buffers the output.\n-->\n\n<p>コマンドをシェルで実行し、その出力をバッファに格納します。\n\n</p>\n<pre><code>var exec = require('child_process').exec,\n    child;\n\nchild = exec('cat *.js bad_file | wc -l',\n  function (error, stdout, stderr) {\n    console.log('stdout: ' + stdout);\n    console.log('stderr: ' + stderr);\n    if (error !== null) {\n      console.log('exec error: ' + error);\n    }\n});</code></pre>\n<!--\nThe callback gets the arguments `(error, stdout, stderr)`. On success, `error`\nwill be `null`.  On error, `error` will be an instance of `Error` and `error.code`\nwill be the exit code of the child process, and `error.signal` will be set to the\nsignal that terminated the process.\n-->\n\n<p>コールバックは引数 <code>(error, stdout, stderr)</code> を得ます。\n成功すると、<code>error</code> は <code>null</code> になります。\nエラーだと、<code>error</code> は <code>Error</code> のインスタンスとなり、\n<code>error.code</code> は子プロセスの終了コード、\n<code>error.signal</code> はプロセスを終了させたシグナルとなります。\n\n</p>\n<!--\nThere is a second optional argument to specify several options. The\ndefault options are\n-->\n\n<p>任意の第 2 引数でいくつかのオプションを指定することができます。\nオプションのデフォルトは\n\n</p>\n<pre><code>{ encoding: 'utf8',\n  timeout: 0,\n  maxBuffer: 200*1024,\n  killSignal: 'SIGTERM',\n  cwd: null,\n  env: null }</code></pre>\n<!--\nIf `timeout` is greater than 0, then it will kill the child process\nif it runs longer than `timeout` milliseconds. The child process is killed with\n`killSignal` (default: `'SIGTERM'`). `maxBuffer` specifies the largest\namount of data allowed on stdout or stderr - if this value is exceeded then\nthe child process is killed.\n-->\n\n<p>もし <code>timeout</code> が 0 より大きいと、\n子プロセスは実行時間が <code>timeout</code> ミリ秒よりも長くなると kill されます。\n子プロセスは <code>killSignal</code> で kill されます (デフォルト: <code>'SIGTERM'</code>)。\n<code>maxBuffer</code> は標準出力と標準エラーの最大のデータ量を指定します － この値を超えると子プロセスは kill されます。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "command"
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "child_process.execFile(file, [args], [options], [callback])",
          "type": "method",
          "name": "execFile",
          "desc": "<!--\n* `file` {String} The filename of the program to run\n* `args` {Array} List of string arguments\n* `options` {Object}\n  * `cwd` {String} Current working directory of the child process\n  * `env` {Object} Environment key-value pairs\n  * `encoding` {String} (Default: 'utf8')\n  * `timeout` {Number} (Default: 0)\n  * `maxBuffer` {Number} (Default: 200\\*1024)\n  * `killSignal` {String} (Default: 'SIGTERM')\n* `callback` {Function} called with the output when process terminates\n  * `error` {Error}\n  * `stdout` {Buffer}\n  * `stderr` {Buffer}\n* Return: ChildProcess object\n-->\n\n<ul>\n<li><code>file</code> {String} 実行するプログラムのファイル名</li>\n<li><code>args</code> {Array} 文字列による引数の配列</li>\n<li><code>options</code> {Object}<ul>\n<li><code>cwd</code> {String} 子プロセスのカレントワーキングディレクトリ</li>\n<li><code>env</code> {Object} 環境変数として与えるキー・値のペア</li>\n<li><code>encoding</code> {String} (Default: 'utf8')</li>\n<li><code>timeout</code> {Number} (Default: 0)</li>\n<li><code>maxBuffer</code> {Number} (Default: 200*1024)</li>\n<li><code>killSignal</code> {String} (Default: 'SIGTERM')</li>\n</ul>\n</li>\n<li><code>callback</code> {Function} プロセスが終了するとその出力を伴って呼び出されます<ul>\n<li><code>error</code> {Error}</li>\n<li><code>stdout</code> {Buffer}</li>\n<li><code>stderr</code> {Buffer}</li>\n</ul>\n</li>\n<li>Return: <code>ChildProcess</code> オブジェクト</li>\n</ul>\n<!--\nThis is similar to `child_process.exec()` except it does not execute a\nsubshell but rather the specified file directly. This makes it slightly\nleaner than `child_process.exec`. It has the same options.\n-->\n\n<p>子シェルで実行する代わりに指定されたファイルを直接実行することを除いて\n<code>child_process.exec()</code> と同様です。\nこれは <code>child_process.exec</code> より若干効率的で、同じオプションを持ちます。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "file"
                },
                {
                  "name": "args",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "child_process.fork(modulePath, [args], [options])",
          "type": "method",
          "name": "fork",
          "desc": "<!--\n* `modulePath` {String} The module to run in the child\n* `args` {Array} List of string arguments\n* `options` {Object}\n  * `cwd` {String} Current working directory of the child process\n  * `env` {Object} Environment key-value pairs\n  * `encoding` {String} (Default: 'utf8')\n  * `execPath` {String} Executable used to create the child process\n  * `execArgv` {Array} List of string arguments passed to the executable\n    (Default: `process.execArgv`)\n  * `silent` {Boolean} If true, stdin, stdout, and stderr of the child will be\n    piped to the parent, otherwise they will be inherited from the parent, see\n    the \"pipe\" and \"inherit\" options for `spawn()`'s `stdio` for more details\n    (default is false)\n* Return: ChildProcess object\n-->\n\n<ul>\n<li><code>modulePath</code> {String} 子プロセスで実行するモジュール</li>\n<li><code>args</code> {Array} 文字列による引数の配列</li>\n<li><code>options</code> {Object}<ul>\n<li><code>cwd</code> {String} 子プロセスのカレントワーキングディレクトリ</li>\n<li><code>env</code> {Object} 環境変数として与えるキー・値のペア</li>\n<li><code>encoding</code> {String} (デフォルト: 'utf8')</li>\n<li><code>execPath</code> {String} 子プロセスの作成に使われる実行ファイル</li>\n<li><code>execArgv</code> {Array} node 実行可能ファイルに渡される文字列引数の配列。\n(デフォルトは <code>process.execArgv</code>)</li>\n<li><code>silent</code> {Boolean} <code>true</code> の場合、子プロセスの標準入力、標準出力、\n標準エラー出力は親プロセスにパイプされます。\nそうでない場合は親プロセスから継承します。\nより詳細は <code>spawn()</code> の <code>pipe</code> および <code>inherit</code> オプションを参照してください\n(デフォルトは <code>false</code>)。</li>\n</ul>\n</li>\n<li>Return: <code>ChildProcess</code> オブジェクト</li>\n</ul>\n<!--\nThis is a special case of the `spawn()` functionality for spawning Node\nprocesses. In addition to having all the methods in a normal ChildProcess\ninstance, the returned object has a communication channel built-in. See\n`child.send(message, [sendHandle])` for details.\n-->\n\n<p>これは <code>spawn()</code> の特別版で、Node プロセスを起動します。\n返されるオブジェクトは通常の ChildProcess の全てのメソッドに加えて、\n組み込みの通信チャネルを持ちます。\n詳細は <code>child.send(message, [sendHandle])</code> を参照してください。\n\n</p>\n<!--\nThese child Nodes are still whole new instances of V8. Assume at least 30ms\nstartup and 10mb memory for each new Node. That is, you cannot create many\nthousands of them.\n-->\n\n<p>これらの子 Node は、やはり V8 の新しいインスタンスです。\n新しい Node ごとに少なくとも 30 ミリ秒の起動時間と \n10MB のメモリを前提としてください。\nつまり、数千の子プロセスを作ることは出来ません。\n\n</p>\n<!--\nThe `execPath` property in the `options` object allows for a process to be\ncreated for the child rather than the current `node` executable. This should be\ndone with care and by default will talk over the fd represented an\nenvironmental variable `NODE_CHANNEL_FD` on the child process. The input and\noutput on this fd is expected to be line delimited JSON objects.\n-->\n\n<p><code>options</code> オブジェクト中の <code>execPath</code> プロパティは、\n現在の <code>node</code> 実行ファイルではない子プロセスの作成を可能にします。\nデフォルトでは、子プロセスの環境変数 <code>NODE_CHANNEL_FD</code> によって示される\nファイル記述子を通じて対話することに注意しなければなりません。\nこのファイル記述子における入力と出力は、改行で区切られた JSON オブジェクトです。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "modulePath"
                },
                {
                  "name": "args",
                  "optional": true
                },
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Child Process"
    },
    {
      "textRaw": "Assert",
      "name": "assert",
      "stability": 5,
      "stabilityText": "Locked",
      "desc": "<!--\nThis module is used for writing unit tests for your applications, you can\naccess it with `require('assert')`.\n-->\n\n<p>このモジュールはアプリケーションの単体テストを記述するために使用され、\n<code>require('assert')</code> でアクセスできます。\n\n</p>\n",
      "methods": [
        {
          "textRaw": "assert.fail(actual, expected, message, operator)",
          "type": "method",
          "name": "fail",
          "desc": "<!--\nThrows an exception that displays the values for `actual` and `expected` separated by the provided operator.\n-->\n\n<p><code>actual</code> と <code>expected</code> を <code>operator</code> で区切ったメッセージを持つ例外を\nスローします。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message"
                },
                {
                  "name": "operator"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert(value, message), assert.ok(value, [message])",
          "type": "method",
          "name": "ok",
          "desc": "<!--\nTests if value is truthy, it is equivalent to `assert.equal(true, !!value, message);`\n-->\n\n<p><code>value</code> が truthy かテストします、\nこれは <code>assert.equal(true, !!value, message);</code> と等価です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "value"
                },
                {
                  "name": "message)"
                },
                {
                  "name": "assert.ok(value"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.equal(actual, expected, [message])",
          "type": "method",
          "name": "equal",
          "Tests shallow, coercive equality with the equal comparison operator ( `": "=` ).",
          "desc": "<p><code>==</code> 演算子を強制して浅い同値性をテストします。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.notEqual(actual, expected, [message])",
          "type": "method",
          "name": "notEqual",
          "Tests shallow, coercive non-equality with the not equal comparison operator ( `!": "` ).",
          "desc": "<p><code>!=</code> 演算子を強制して浅い非同値性をテストします。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.deepEqual(actual, expected, [message])",
          "type": "method",
          "name": "deepEqual",
          "desc": "<!--\nTests for deep equality.\n-->\n\n<p>深い同値性をテストします。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.notDeepEqual(actual, expected, [message])",
          "type": "method",
          "name": "notDeepEqual",
          "desc": "<!--\nTests for any deep inequality.\n-->\n\n<p>深い非同値性をテストします。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.strictEqual(actual, expected, [message])",
          "type": "method",
          "name": "strictEqual",
          "Tests strict equality, as determined by the strict equality operator ( `": "==` )",
          "desc": "<p><code>===</code> 演算子で厳密な同値性をテストします。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.notStrictEqual(actual, expected, [message])",
          "type": "method",
          "name": "notStrictEqual",
          "Tests strict non-equality, as determined by the strict not equal operator ( `!": "=` )",
          "desc": "<p><code>!==</code> 演算子で厳密な非同値性をテストします。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "actual"
                },
                {
                  "name": "expected"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.throws(block, [error], [message])",
          "type": "method",
          "name": "throws",
          "desc": "<!--\nExpects `block` to throw an error. `error` can be constructor, regexp or \nvalidation function.\n-->\n\n<p><code>block</code> がエラーをスローすることを期待します。\n<code>error</code> はコンストラクタ、正規表現、または検証関数にすることができます。\n\n</p>\n<!--\nValidate instanceof using constructor:\n-->\n\n<p>コンストラクタを使って instanceof で検証:\n\n</p>\n<pre><code>assert.throws(\n  function() {\n    throw new Error("Wrong value");\n  },\n  Error\n);</code></pre>\n<!--\nValidate error message using RegExp:\n-->\n\n<p>正規表現を使ってエラーメッセージを検証:\n\n</p>\n<pre><code>assert.throws(\n  function() {\n    throw new Error("Wrong value");\n  },\n  /value/\n);</code></pre>\n<!--\nCustom error validation:\n-->\n\n<p>独自のエラー検証:\n\n</p>\n<pre><code>assert.throws(\n  function() {\n    throw new Error("Wrong value");\n  },\n  function(err) {\n    if ( (err instanceof Error) && /value/.test(err) ) {\n      return true;\n    }\n  },\n  "unexpected error"\n);</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "block"
                },
                {
                  "name": "error",
                  "optional": true
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.doesNotThrow(block, [message])",
          "type": "method",
          "name": "doesNotThrow",
          "desc": "<!--\nExpects `block` not to throw an error, see assert.throws for details.\n-->\n\n<p><code>block</code> がエラーをスローしないことを期待します。\n詳細は assert.throws を参照してください。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "block"
                },
                {
                  "name": "message",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "assert.ifError(value)",
          "type": "method",
          "name": "ifError",
          "desc": "<!--\nTests if value is not a false value, throws if it is a true value. Useful when\ntesting the first argument, `error` in callbacks.\n-->\n\n<p><code>value</code> が false でないことをテストし、true だったらそれをスローします。\nコールバックの第 1 引数である <code>error</code> をテストするのに便利です。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "value"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Assert"
    },
    {
      "textRaw": "TTY",
      "name": "tty",
      "stability": 2,
      "stabilityText": "Unstable",
      "desc": "<!--\nThe `tty` module houses the `tty.ReadStream` and `tty.WriteStream` classes. In\nmost cases, you will not need to use this module directly.\n-->\n\n<p><code>tty</code> モジュールは <code>tty.ReadStream</code> と <code>tty.WriteStream</code> クラスを持ちます。\n多くのケースでは、これらを直接使う必要はありません。\n\n</p>\n<!--\nWhen node detects that it is being run inside a TTY context, then `process.stdin`\nwill be a `tty.ReadStream` instance and `process.stdout` will be\na `tty.WriteStream` instance. The preferred way to check if node is being run in\na TTY context is to check `process.stdout.isTTY`:\n-->\n\n<p>node は TTY コンテキストの中にいるかどうかを検出し、\n<code>process.stdin</code> は <code>tty.ReadStream</code> のインスタンスに、\n<code>process.stdout</code> は <code>tty.WriteStream</code> のインスタンスになります。\nもし node が TTY のコンテキストで実行されているかどうかをチェックしたければ、\n<code>process.stdout.isTTY</code> を使うことができます:\n\n</p>\n<pre><code>$ node -p -e "Boolean(process.stdout.isTTY)"\ntrue\n$ node -p -e "Boolean(process.stdout.isTTY)" | cat\nfalse</code></pre>\n",
      "methods": [
        {
          "textRaw": "tty.isatty(fd)",
          "type": "method",
          "name": "isatty",
          "desc": "<!--\nReturns `true` or `false` depending on if the `fd` is associated with a\nterminal.\n-->\n\n<p><code>fd</code> が端末に関連づけられているかどうかを <code>true</code> または <code>false</code> で返します。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "fd"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "tty.setRawMode(mode)",
          "type": "method",
          "name": "setRawMode",
          "desc": "<!--\nDeprecated. Use `tty.ReadStream#setRawMode()`\n(i.e. `process.stdin.setRawMode()`) instead.\n-->\n\n<p>Deprecated.\n代わりに <code>tty.ReadStream#setRawMode()</code> (すなわち、<code>process.stdin.setRawMode()</code>)\nを使用してください。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "mode"
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: ReadStream",
          "type": "class",
          "name": "ReadStream",
          "desc": "<!--\nA `net.Socket` subclass that represents the readable portion of a tty. In normal\ncircumstances, `process.stdin` will be the only `tty.ReadStream` instance in any\nnode program (only when `isatty(0)` is true).\n-->\n\n<p><code>net.Socket</code> のサブクラスで、tty の入力側を表現します。\n一般的な状況では、どんなプログラムでも (<code>isatty(0)</code> が true の場合に限り)\n<code>process.stdin</code> が唯一の <code>tty.ReadStream</code> のインスタンスとなります。\n\n</p>\n",
          "properties": [
            {
              "textRaw": "rs.isRaw",
              "name": "isRaw",
              "desc": "<!--\nA `Boolean` that is initialized to `false`. It represents the current \"raw\" state\nof the `tty.ReadStream` instance.\n-->\n\n<p><code>Boolean</code> 値で <code>false</code> に初期化されます。\n<code>tty.ReadStream</code> インスタンスの現在の "raw" 状態を表現します。\n\n</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "rs.setRawMode(mode)",
              "type": "method",
              "name": "setRawMode",
              "desc": "<!--\n`mode` should be `true` or `false`. This sets the properties of the\n`tty.ReadStream` to act either as a raw device or default. `isRaw` will be set\nto the resulting mode.\n-->\n\n<p><code>mode</code> は <code>true</code> または <code>false</code> のどちらかです。\nこれは <code>tty.ReadStream</code> がローデバイスかデフォルトのどちらで振る舞うかを\n設定します。\n結果のモードは <code>isRaw</code> に設定されます。\n\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "mode"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: WriteStream",
          "type": "class",
          "name": "WriteStream",
          "desc": "<!--\nA `net.Socket` subclass that represents the writable portion of a tty. In normal\ncircumstances, `process.stdout` will be the only `tty.WriteStream` instance\never created (and only when `isatty(1)` is true).\n-->\n\n<p><code>net.Socket</code> のサブクラスで、tty の出力側を表現します。\n一般的な状況では、どんなプログラムでも (<code>isatty(1)</code> が true の場合に限り)\n<code>process.stdout</code> が唯一の <code>tty.WriteStream</code> のインスタンスとなります。\n\n</p>\n",
          "properties": [
            {
              "textRaw": "ws.columns",
              "name": "columns",
              "desc": "<!--\nA `Number` that gives the number of columns the TTY currently has. This property\ngets updated on \"resize\" events.\n-->\n\n<p>TTY の現在のカラム数を保持する <code>Number</code> 値です。\nこのプロパティは <code>'resize'</code> イベントで更新されます。\n\n</p>\n"
            },
            {
              "textRaw": "ws.rows",
              "name": "rows",
              "desc": "<!--\nA `Number` that gives the number of rows the TTY currently has. This property\ngets updated on \"resize\" events.\n-->\n\n<p>TTY の現在の行数を保持する <code>Number</code> 値です。\nこのプロパティは <code>'resize'</code> イベントで更新されます。\n\n</p>\n"
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'resize'",
              "type": "event",
              "name": "resize",
              "desc": "<p><code>function () {}</code>\n\n</p>\n<!--\nEmitted by `refreshSize()` when either of the `columns` or `rows` properties\nhas changed.\n-->\n\n<p><code>columns</code> または <code>rows</code> プロパティが変更された場合に\n<code>refreshSize()</code> によって生成されます。\n\n</p>\n<pre><code>process.stdout.on('resize', function() {\n  console.log('screen size has changed!');\n  console.log(process.stdout.columns + 'x' + process.stdout.rows);\n});</code></pre>\n",
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "TTY"
    },
    {
      "textRaw": "Zlib",
      "name": "zlib",
      "stability": 3,
      "stabilityText": "Stable",
      "desc": "<!--\nYou can access this module with:\n-->\n\n<p>このモジュールは次のようにアクセスできます。\n\n</p>\n<pre><code>var zlib = require('zlib');</code></pre>\n<!--\nThis provides bindings to Gzip/Gunzip, Deflate/Inflate, and\nDeflateRaw/InflateRaw classes.  Each class takes the same options, and\nis a readable/writable Stream.\n-->\n\n<p>これは Gzip/Gunzip、Deflate/Inflate、そして DeflateRaw/InflateRaw\nへバインディングするクラスを提供します。\nどのクラスも同じオプションを持つ、読み込みと書き込みが可能なストリームです。\n\n</p>\n<h2>Examples</h2>\n<!--\nCompressing or decompressing a file can be done by piping an\nfs.ReadStream into a zlib stream, then into an fs.WriteStream.\n-->\n\n<p>ファイルを圧縮および解凍するには、fs.ReadStream から zlib へ、\nそして fs.WriteStream へパイプをつなぐだけです。\n\n</p>\n<pre><code>var gzip = zlib.createGzip();\nvar fs = require('fs');\nvar inp = fs.createReadStream('input.txt');\nvar out = fs.createWriteStream('input.txt.gz');\n\ninp.pipe(gzip).pipe(out);</code></pre>\n<!--\nCompressing or decompressing data in one step can be done by using\nthe convenience methods.\n-->\n\n<p>データの圧縮または解凍は <a href="\"#convenience_Methods\"">簡易メソッド</a>\nを使うことにより、ワンステップで行うことができます。\n\n</p>\n<pre><code>var input = '.................................';\nzlib.deflate(input, function(err, buffer) {\n  if (!err) {\n    console.log(buffer.toString('base64'));\n  }\n});\n\nvar buffer = new Buffer('eJzT0yMAAGTvBe8=', 'base64');\nzlib.unzip(buffer, function(err, buffer) {\n  if (!err) {\n    console.log(buffer.toString());\n  }\n});</code></pre>\n<!--\nTo use this module in an HTTP client or server, use the\n[accept-encoding](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3)\non requests, and the\n[content-encoding](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11)\nheader on responses.\n\n**Note: these examples are drastically simplified to show\nthe basic concept.**  Zlib encoding can be expensive, and the results\nought to be cached.  See [Memory Usage Tuning](#zlib_memory_usage_tuning)\nbelow for more information on the speed/memory/compression\ntradeoffs involved in zlib usage.\n-->\n\n<p>このモジュールを HTTP クライアントとサーバで使うには、リクエストに\n<a href="\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\"">accept-encoding</a>\nヘッダを、レスポンスに\n<a href="\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11\"">content-encoding</a>\nヘッダを使用します。\n\n</p>\n<p><strong>注意:\nこれらのサンプルは基本コンセプトを見せるためにとても単純化されています。</strong>\nZlib エンコーディングは高価なので、結果はキャッシュされるべきです。\nzlibの使い方に関する速度／メモリ／圧縮率のトレードオフについてより詳しくは、\n後述の <a href="\"#zlib_memory_usage_tuning\"">Memory Usage Tuning</a> を参照してください。\n\n</p>\n<pre><code>// client request example\nvar zlib = require('zlib');\nvar http = require('http');\nvar fs = require('fs');\nvar request = http.get({ host: 'izs.me',\n                         path: '/',\n                         port: 80,\n                         headers: { 'accept-encoding': 'gzip,deflate' } });\nrequest.on('response', function(response) {\n  var output = fs.createWriteStream('izs.me_index.html');\n\n  switch (response.headers['content-encoding']) {\n    // or, just use zlib.createUnzip() to handle both cases\n    case 'gzip':\n      response.pipe(zlib.createGunzip()).pipe(output);\n      break;\n    case 'deflate':\n      response.pipe(zlib.createInflate()).pipe(output);\n      break;\n    default:\n      response.pipe(output);\n      break;\n  }\n});\n\n// server example\n// Running a gzip operation on every request is quite expensive.\n// It would be much more efficient to cache the compressed buffer.\nvar zlib = require('zlib');\nvar http = require('http');\nvar fs = require('fs');\nhttp.createServer(function(request, response) {\n  var raw = fs.createReadStream('index.html');\n  var acceptEncoding = request.headers['accept-encoding'];\n  if (!acceptEncoding) {\n    acceptEncoding = '';\n  }\n\n  // Note: this is not a conformant accept-encoding parser.\n  // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\n  if (acceptEncoding.match(/\\bdeflate\\b/)) {\n    response.writeHead(200, { 'content-encoding': 'deflate' });\n    raw.pipe(zlib.createDeflate()).pipe(response);\n  } else if (acceptEncoding.match(/\\bgzip\\b/)) {\n    response.writeHead(200, { 'content-encoding': 'gzip' });\n    raw.pipe(zlib.createGzip()).pipe(response);\n  } else {\n    response.writeHead(200, {});\n    raw.pipe(response);\n  }\n}).listen(1337);</code></pre>\n",
      "methods": [
        {
          "textRaw": "zlib.createGzip([options])",
          "type": "method",
          "name": "createGzip",
          "desc": "<!--\nReturns a new [Gzip](#zlib_class_zlib_gzip) object with an\n[options](#zlib_options).\n-->\n\n<p><a href="\"#zlib_options\"">options</a> によって作られた新しい\n<a href="\"#zlib_class_zlib_gzip\"">Gzip</a> オブジェクトを返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createGunzip([options])",
          "type": "method",
          "name": "createGunzip",
          "desc": "<!--\nReturns a new [Gunzip](#zlib_class_zlib_gunzip) object with an\n[options](#zlib_options).\n-->\n\n<p><a href="\"#zlib_options\"">options</a> によって作られた新しい\n<a href="\"#zlib_class_zlib_gunzip\"">Gunzip</a> オブジェクトを返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createDeflate([options])",
          "type": "method",
          "name": "createDeflate",
          "desc": "<!--\nReturns a new [Deflate](#zlib_class_zlib_deflate) object with an\n[options](#zlib_options).\n-->\n\n<p><a href="\"#zlib_options\"">options</a> によって作られた新しい\n<a href="\"#zlib_class_zlib_deflate\"">Deflate</a> オブジェクトを返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createInflate([options])",
          "type": "method",
          "name": "createInflate",
          "desc": "<!--\nReturns a new [Inflate](#zlib_class_zlib_inflate) object with an\n[options](#zlib_options).\n-->\n\n<p><a href="\"#zlib_options\"">options</a> によって作られた新しい\n<a href="\"#zlib_class_zlib_inflate\"">Inflate</a> オブジェクトを返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createDeflateRaw([options])",
          "type": "method",
          "name": "createDeflateRaw",
          "desc": "<!--\nReturns a new [DeflateRaw](#zlib_class_zlib_deflateraw) object with an\n[options](#zlib_options).\n\n-->\n\n<p><a href="\"#zlib_options\"">options</a> によって作られた新しい\n<a href="\"#zlib_class_zlib_deflateraw\"">DeflateRaw</a> オブジェクトを返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createInflateRaw([options])",
          "type": "method",
          "name": "createInflateRaw",
          "desc": "<!--\nReturns a new [InflateRaw](#zlib_class_zlib_inflateraw) object with an\n[options](#zlib_options).\n\n-->\n\n<p><a href="\"#zlib_options\"">options</a> によって作られた新しい\n<a href="\"#zlib_class_zlib_inflateraw\"">InflateRaw</a> オブジェクトを返します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.createUnzip([options])",
          "type": "method",
          "name": "createUnzip",
          "desc": "<!--\nReturns a new [Unzip](#zlib_class_zlib_unzip) object with an\n[options](#zlib_options).\n-->\n\n<p><a href="\"#zlib_options\"">options</a> によって作られた新しい\n<a href="\"#zlib_class_zlib_unzip\"">Unzip</a> オブジェクトを返します。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "options",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.deflate(buf, callback)",
          "type": "method",
          "name": "deflate",
          "desc": "<!--\nCompress a string with Deflate.\n-->\n\n<p>Deflate で文字列を圧縮します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "buf"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.deflateRaw(buf, callback)",
          "type": "method",
          "name": "deflateRaw",
          "desc": "<!--\nCompress a string with DeflateRaw.\n-->\n\n<p>DeflateRaw で文字列を圧縮します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "buf"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.gzip(buf, callback)",
          "type": "method",
          "name": "gzip",
          "desc": "<!--\nCompress a string with Gzip.\n-->\n\n<p>Gzip で文字列を圧縮します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "buf"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.gunzip(buf, callback)",
          "type": "method",
          "name": "gunzip",
          "desc": "<!--\nDecompress a raw Buffer with Gunzip.\n-->\n\n<p>Gunzip で生のバッファを解凍します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "buf"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.inflate(buf, callback)",
          "type": "method",
          "name": "inflate",
          "desc": "<!--\nDecompress a raw Buffer with Inflate.\n-->\n\n<p>Infrate で生のバッファを解凍します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "buf"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.inflateRaw(buf, callback)",
          "type": "method",
          "name": "inflateRaw",
          "desc": "<!--\nDecompress a raw Buffer with InflateRaw.\n-->\n\n<p>InflateRaw で生のバッファを解凍します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "buf"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "zlib.unzip(buf, callback)",
          "type": "method",
          "name": "unzip",
          "desc": "<!--\nDecompress a raw Buffer with Unzip.\n-->\n\n<p>Unzip で生のバッファを解凍します。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "buf"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: zlib.Zlib",
          "type": "class",
          "name": "zlib.Zlib",
          "desc": "<!--\nNot exported by the `zlib` module. It is documented here because it is the base\nclass of the compressor/decompressor classes.\n-->\n\n<p><code>zlib</code> モジュールによって公開されてはいません。\nここで文書化するのは圧縮／解凍クラスのベースクラスだからです。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "zlib.flush(callback)",
              "type": "method",
              "name": "flush",
              "desc": "<!--\nFlush pending data. Don't call this frivolously, premature flushes negatively\nimpact the effectiveness of the compression algorithm.\n-->\n\n<p>保留中のデータをフラッシュします。\nこれを気軽に呼び出さないでください、性急なフラッシュは圧縮アルゴリズムに\nネガティブな影響を与えます。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "callback"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "zlib.reset()",
              "type": "method",
              "name": "reset",
              "desc": "<!--\nReset the compressor/decompressor to factory defaults. Only applicable to\nthe inflate and deflate algorithms.\n-->\n\n<p>圧縮／解凍をファクトリのデフォルトにリセットします。\ninfrate および defrate アルゴリズムにのみ効果があります。\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: zlib.Gzip",
          "type": "class",
          "name": "zlib.Gzip",
          "desc": "<!--\nCompress data using gzip.\n-->\n\n<p>gzip を使ってデータを圧縮します。\n\n</p>\n"
        },
        {
          "textRaw": "Class: zlib.Gunzip",
          "type": "class",
          "name": "zlib.Gunzip",
          "desc": "<!--\nDecompress a gzip stream.\n-->\n\n<p>gzip ストリームを解凍します。\n\n</p>\n"
        },
        {
          "textRaw": "Class: zlib.Deflate",
          "type": "class",
          "name": "zlib.Deflate",
          "desc": "<!--\nCompress data using deflate.\n-->\n\n<p>deflate を使ってデータを圧縮します。\n\n</p>\n"
        },
        {
          "textRaw": "Class: zlib.Inflate",
          "type": "class",
          "name": "zlib.Inflate",
          "desc": "<!--\nDecompress a deflate stream.\n-->\n\n<p>deflate ストリームを解凍します。\n\n</p>\n"
        },
        {
          "textRaw": "Class: zlib.DeflateRaw",
          "type": "class",
          "name": "zlib.DeflateRaw",
          "desc": "<!--\nCompress data using deflate, and do not append a zlib header.\n-->\n\n<p>deflate を使ってデータを圧縮しますが、zlib ヘッダを付加しません。\n\n</p>\n"
        },
        {
          "textRaw": "Class: zlib.InflateRaw",
          "type": "class",
          "name": "zlib.InflateRaw",
          "desc": "<!--\nDecompress a raw deflate stream.\n-->\n\n<p>生の deflate ストリームを解凍します。\n\n</p>\n"
        },
        {
          "textRaw": "Class: zlib.Unzip",
          "type": "class",
          "name": "zlib.Unzip",
          "desc": "<!--\nDecompress either a Gzip- or Deflate-compressed stream by auto-detecting\nthe header.\n-->\n\n<p>Gzip または Deflate で圧縮されたストリームをヘッダで自動判別して解凍します。\n\n</p>\n"
        }
      ],
      "miscs": [
        {
          "textRaw": "Convenience Methods",
          "name": "Convenience Methods",
          "type": "misc",
          "desc": "<!--\nAll of these take a string or buffer as the first argument, and call the\nsupplied callback with `callback(error, result)`.  The\ncompression/decompression engine is created using the default settings\nin all convenience methods.  To supply different options, use the\nzlib classes directly.\n-->\n\n<p>これらは全て第 1 引数として文字列またはバッファを受け取り、\n与えられたコールバック <code>callback(error, result)</code> を呼び出します。\n全ての簡易メソッドで、圧縮・解凍エンジンはデフォルトの設定で作成されます。\n異なったオプションを与えるには、zlib のクラスを直接使用してください。\n\n</p>\n"
        },
        {
          "textRaw": "Options",
          "name": "Options",
          "type": "misc",
          "desc": "<!--\nEach class takes an options object.  All options are optional.  (The\nconvenience methods use the default settings for all options.)\n-->\n\n<p>どのクラスもオプションオブジェクトを受け取ります。\n全てのオプションは任意です\n(簡易メソッドは全てのオプションでデフォルト値を使用します)。\n\n</p>\n<!--\nNote that some options are only relevant when compressing, and are\nignored by the decompression classes.\n-->\n\n<p>いくつかのオプションは圧縮にだけ関連し、\n解凍するクラスでは無視されることに注意してください。\n\n</p>\n<!--\n* flush (default: `zlib.Z_NO_FLUSH`)\n* chunkSize (default: 16*1024)\n* windowBits\n* level (compression only)\n* memLevel (compression only)\n* strategy (compression only)\n* dictionary (deflate/inflate only, empty dictionary by default)\n-->\n\n<ul>\n<li>flush (デフォルト: <code>zlib.Z_NO_FLUSH</code>)</li>\n<li>chunkSize (デフォルト: 16*1024)</li>\n<li>windowBits</li>\n<li>level (圧縮のみ)</li>\n<li>memLevel (圧縮のみ)</li>\n<li>strategy (圧縮のみ)</li>\n<li>dictionary (deflate/inflate のみ、デフォルトは空の辞書です)</li>\n</ul>\n<!--\nSee the description of `deflateInit2` and `inflateInit2` at\n<http://zlib.net/manual.html#Advanced> for more information on these.\n-->\n\n<p>これらの詳細は <a href="\"http://zlib.net/manual.html#Advanced\"">http://zlib.net/manual.html#Advanced</a> の\n<code>deflateInit2</code> および <code>inflateInit2</code> の説明を参照してください。\n\n</p>\n"
        },
        {
          "textRaw": "Memory Usage Tuning",
          "name": "Memory Usage Tuning",
          "type": "misc",
          "desc": "<!--\nFrom `zlib/zconf.h`, modified to node's usage:\n\nThe memory requirements for deflate are (in bytes):\n-->\n\n<p>node は <code>zlib/zconf.h</code> を変更して使っています:\n\n</p>\n<pre><code>(1 << (windowBits+2)) +  (1 << (memLevel+9))</code></pre>\n<p>すなわち: windowBits = 15 の場合 128K + \nmemLevel = 8 の場合 128K (デフォルト値) に加えて数キロバイトが\n小さなオブジェクトのために使われます。\n\n</p>\n<p>たとえば、デフォルトで要求されるメモリを 256K から 128K へ縮小したければ、\n次のオプションを設定します:\n\n</p>\n<pre><code>{ windowBits: 14, memLevel: 7 }</code></pre>\n<!--\nOf course this will generally degrade compression (there's no free lunch).\n\nThe memory requirements for inflate are (in bytes)\n-->\n\n<p>もちろん、これは圧縮率を悪化します (ただ飯ははありません)。\n\n\n</p>\n<pre><code>1 << windowBits</code></pre>\n<p>この場合、windowBits=15 (デフォルト値) の場合 32K に加えて数キロバイトが\n小さなオブジェクトのために使われます。\n\n</p>\n<p>これは、デフォルト値 16K の <code>chunkSize</code> で指定されたサイズの内部バッファに加えられます。\n\n</p>\n<p>zlib の圧縮速度は <code>level</code> の設定で劇的に変化します\n高レベルにするとより圧縮できますが、完了までの時間が長くなります。\n低レベルにするとあまり圧縮されませんが、高速になります。\n\n</p>\n<p>一般的に、メモリをより多く使うオプションにすると node が zlib を呼び出す回数が\n少なくなることを意味し、\n一回の <code>write</code> 操作でより多くのデータを処理できることになります。\nこれはあスピードに影響するもう一つのファクタで、メモリ使用量を犠牲にします。\n\n</p>\n",
          "that is: 128K for windowBits": "15  +  128K for memLevel = 8\n(default values) plus a few kilobytes for small objects.\n\nFor example, if you want to reduce\nthe default memory requirements from 256K to 128K, set the options to:",
          "that is, 32K for windowBits": "15 (default value) plus a few kilobytes\nfor small objects.\n\nThis is in addition to a single internal output slab buffer of size\n`chunkSize`, which defaults to 16K.\n\nThe speed of zlib compression is affected most dramatically by the\n`level` setting.  A higher level will result in better compression, but\nwill take longer to complete.  A lower level will result in less\ncompression, but will be much faster.\n\nIn general, greater memory usage options will mean that node has to make\nfewer calls to zlib, since it'll be able to process more data in a\nsingle `write` operation.  So, this is another factor that affects the\nspeed, at the cost of memory usage."
        },
        {
          "textRaw": "Constants",
          "name": "Constants",
          "type": "misc",
          "desc": "<!--\nAll of the constants defined in zlib.h are also defined on\n`require('zlib')`.\nIn the normal course of operations, you will not need to ever set any of\nthese.  They are documented here so that their presence is not\nsurprising.  This section is taken almost directly from the [zlib\ndocumentation](http://zlib.net/manual.html#Constants).  See\n<http://zlib.net/manual.html#Constants> for more details.\n-->\n\n<p>zlib.h に定義された定数は <code>require('zlib')</code> でも定義されます。\n通常の使い方ではこれらを設定する必要はありません。\nそれが存在することで驚かれないように、これらはドキュメント化されます。\nこのセクションのほとんどは\n<a href="\"http://zlib.net/manual.html#Constants\"">zlib documentation</a>\nから直接得ることができます。\nより詳細は <a href="\"http://zlib.net/manual.html#Constants\"">http://zlib.net/manual.html#Constants</a> を参照してください。\n\n</p>\n<!--\nAllowed flush values.\n-->\n\n<p>利用可能なフラッシュ値。\n\n</p>\n<ul>\n<li><code>zlib.Z_NO_FLUSH</code></li>\n<li><code>zlib.Z_PARTIAL_FLUSH</code></li>\n<li><code>zlib.Z_SYNC_FLUSH</code></li>\n<li><code>zlib.Z_FULL_FLUSH</code></li>\n<li><code>zlib.Z_FINISH</code></li>\n<li><code>zlib.Z_BLOCK</code></li>\n<li><code>zlib.Z_TREES</code></li>\n</ul>\n<!--\nReturn codes for the compression/decompression functions. Negative\nvalues are errors, positive values are used for special but normal\nevents.\n-->\n\n<p>圧縮／解凍関数のリターンコード。\n負数はエラー、正数は正常なイベントの特別な場合に使われます。\n\n</p>\n<ul>\n<li><code>zlib.Z_OK</code></li>\n<li><code>zlib.Z_STREAM_END</code></li>\n<li><code>zlib.Z_NEED_DICT</code></li>\n<li><code>zlib.Z_ERRNO</code></li>\n<li><code>zlib.Z_STREAM_ERROR</code></li>\n<li><code>zlib.Z_DATA_ERROR</code></li>\n<li><code>zlib.Z_MEM_ERROR</code></li>\n<li><code>zlib.Z_BUF_ERROR</code></li>\n<li><code>zlib.Z_VERSION_ERROR</code></li>\n</ul>\n<!--\nCompression levels.\n-->\n\n<p>圧縮レベル。\n\n</p>\n<ul>\n<li><code>zlib.Z_NO_COMPRESSION</code></li>\n<li><code>zlib.Z_BEST_SPEED</code></li>\n<li><code>zlib.Z_BEST_COMPRESSION</code></li>\n<li><code>zlib.Z_DEFAULT_COMPRESSION</code></li>\n</ul>\n<!--\nCompression strategy.\n-->\n\n<p>圧縮ストラテジ。\n\n</p>\n<ul>\n<li><code>zlib.Z_FILTERED</code></li>\n<li><code>zlib.Z_HUFFMAN_ONLY</code></li>\n<li><code>zlib.Z_RLE</code></li>\n<li><code>zlib.Z_FIXED</code></li>\n<li><code>zlib.Z_DEFAULT_STRATEGY</code></li>\n</ul>\n<!--\nPossible values of the data_type field.\n-->\n\n<p>data_type フィールドで利用可能な値。\n\n</p>\n<ul>\n<li><code>zlib.Z_BINARY</code></li>\n<li><code>zlib.Z_TEXT</code></li>\n<li><code>zlib.Z_ASCII</code></li>\n<li><code>zlib.Z_UNKNOWN</code></li>\n</ul>\n<!--\nThe deflate compression method (the only one supported in this version).\n-->\n\n<p>deflate の圧縮方法 (このバージョンでは一つだけがサポートされます)。\n\n</p>\n<ul>\n<li><code>zlib.Z_DEFLATED</code></li>\n</ul>\n<!--\nFor initializing zalloc, zfree, opaque.\n-->\n\n<p>zalloc、zfree、opaque の初期化用。\n\n</p>\n<ul>\n<li><code>zlib.Z_NULL</code></li>\n</ul>\n"
        }
      ],
      "that is: 128K for windowBits": "15  +  128K for memLevel = 8\n(default values) plus a few kilobytes for small objects.\n\nFor example, if you want to reduce\nthe default memory requirements from 256K to 128K, set the options to:",
      "that is, 32K for windowBits": "15 (default value) plus a few kilobytes\nfor small objects.\n\nThis is in addition to a single internal output slab buffer of size\n`chunkSize`, which defaults to 16K.\n\nThe speed of zlib compression is affected most dramatically by the\n`level` setting.  A higher level will result in better compression, but\nwill take longer to complete.  A lower level will result in less\ncompression, but will be much faster.\n\nIn general, greater memory usage options will mean that node has to make\nfewer calls to zlib, since it'll be able to process more data in a\nsingle `write` operation.  So, this is another factor that affects the\nspeed, at the cost of memory usage.",
      "type": "module",
      "displayName": "Zlib"
    },
    {
      "textRaw": "os",
      "name": "os",
      "stability": 4,
      "stabilityText": "API Frozen",
      "desc": "<!--\nProvides a few basic operating-system related utility functions.\n-->\nオペレーティングシステムに関連する基本的なユーティリティ関数を提供します。\n\n<!--\nUse `require('os')` to access this module.\n-->\n\n<p><code>require('os')</code> によってこのモジュールにアクセスします。\n\n</p>\n",
      "methods": [
        {
          "textRaw": "os.tmpdir()",
          "type": "method",
          "name": "tmpdir",
          "desc": "<!--\nReturns the operating system's default directory for temp files.\n-->\n\n<p>一時ファイルのためのデフォルトディレクトリを返します。\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.endianness()",
          "type": "method",
          "name": "endianness",
          "desc": "<!--\nReturns the endianness of the CPU. Possible values are `\"BE\"` or `\"LE\"`.\n-->\n\n<p>CPU のエンディアン (バイトオーダー) を返します。\nあり得る値は <code>"BE"</code> または <code>"LE"</code> です。\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.hostname()",
          "type": "method",
          "name": "hostname",
          "desc": "<!--\nReturns the hostname of the operating system.\n-->\n\n<p>オペレーティングシステムのホスト名を返します。\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.type()",
          "type": "method",
          "name": "type",
          "desc": "<!--\nReturns the operating system name.\n-->\n\n<p>オペレーティングシステムの名前を返します。\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.platform()",
          "type": "method",
          "name": "platform",
          "desc": "<!--\nReturns the operating system platform.\n-->\n\n<p>プラットフォームのオペレーティングシステムを返します。\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.arch()",
          "type": "method",
          "name": "arch",
          "desc": "<!--\nReturns the operating system CPU architecture.\n-->\n\n<p>オペレーティングシステムの CPU アーキテクチャを返します。\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.release()",
          "type": "method",
          "name": "release",
          "desc": "<!--\nReturns the operating system release.\n-->\n\n<p>オペレーティングシステムのリリースを返します。\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.uptime()",
          "type": "method",
          "name": "uptime",
          "desc": "<!--\nReturns the system uptime in seconds.\n-->\n\n<p>システムが起動してからの秒数を返します。\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.loadavg()",
          "type": "method",
          "name": "loadavg",
          "desc": "<!--\nReturns an array containing the 1, 5, and 15 minute load averages.\n-->\n\n<p>1 分、5 分、15 分間のロードアベレージを含んだ配列を返します。\n\n</p>\n<!--\nThe load average is a measure of system activity, calculated by the operating\nsystem and expressed as a fractional number.  As a rule of thumb, the load\naverage should ideally be less than the number of logical CPUs in the system.\n-->\n\n<p>ロードアベレージはオペレーティングシステムによって測定されて小数で表される\nシステム活動の測定値です。経験則として、ロードアベレージは理想的には\nシステムの論理 CPU 数よりも小さくあるべきです。\n\n</p>\n<!--\nThe load average is a very UNIX-y concept; there is no real equivalent on\nWindows platforms.  That is why this function always returns `[0, 0, 0]` on\nWindows.\n-->\n\n<p>ロードアベレージはとても Unix 的な概念です; それと完全に対応するものは\nWindows にはありません。そのため、Windows ではこの関数は常に <code>[0, 0, 0]</code>\nを返します。\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.totalmem()",
          "type": "method",
          "name": "totalmem",
          "desc": "<!--\nReturns the total amount of system memory in bytes.\n-->\n\n<p>システム全体が使用しているメモリのバイト数を返します。\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.freemem()",
          "type": "method",
          "name": "freemem",
          "desc": "<!--\nReturns the amount of free system memory in bytes.\n-->\n\n<p>システム全体で空いているメモリのバイト数を返します。\n\n</p>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.cpus()",
          "type": "method",
          "name": "cpus",
          "desc": "<!--\nReturns an array of objects containing information about each CPU/core\ninstalled: model, speed (in MHz), and times (an object containing the number of\nmilliseconds the CPU/core spent in: user, nice, sys, idle, and irq).\n-->\n\n<p>インストールされている CPU/ コアごとの情報を含んだオブジェクトの配列を返します。\n情報はモデル、スピード (MHz)、そして時間 (CPU/コア が使用した user, nice, sys, idle, irq のミリ秒を含んだオブジェクト) です。\n\n</p>\n<!--\nExample inspection of os.cpus:\n-->\n\n<p>os.cpus の例:\n\n</p>\n<pre><code>[ { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',\n    speed: 2926,\n    times:\n     { user: 252020,\n       nice: 0,\n       sys: 30340,\n       idle: 1070356870,\n       irq: 0 } },\n  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',\n    speed: 2926,\n    times:\n     { user: 306960,\n       nice: 0,\n       sys: 26980,\n       idle: 1071569080,\n       irq: 0 } },\n  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',\n    speed: 2926,\n    times:\n     { user: 248450,\n       nice: 0,\n       sys: 21750,\n       idle: 1070919370,\n       irq: 0 } },\n  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',\n    speed: 2926,\n    times:\n     { user: 256880,\n       nice: 0,\n       sys: 19430,\n       idle: 1070905480,\n       irq: 20 } },\n  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',\n    speed: 2926,\n    times:\n     { user: 511580,\n       nice: 20,\n       sys: 40900,\n       idle: 1070842510,\n       irq: 0 } },\n  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',\n    speed: 2926,\n    times:\n     { user: 291660,\n       nice: 0,\n       sys: 34360,\n       idle: 1070888000,\n       irq: 10 } },\n  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',\n    speed: 2926,\n    times:\n     { user: 308260,\n       nice: 0,\n       sys: 55410,\n       idle: 1071129970,\n       irq: 880 } },\n  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',\n    speed: 2926,\n    times:\n     { user: 266450,\n       nice: 1480,\n       sys: 34920,\n       idle: 1072572010,\n       irq: 30 } } ]</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "os.networkInterfaces()",
          "type": "method",
          "name": "networkInterfaces",
          "desc": "<!--\nGet a list of network interfaces:\n-->\n\n<p>ネットワークインタフェースの一覧を取得します。\n\n</p>\n<pre><code>{ lo0: \n   [ { address: '::1', family: 'IPv6', internal: true },\n     { address: 'fe80::1', family: 'IPv6', internal: true },\n     { address: '127.0.0.1', family: 'IPv4', internal: true } ],\n  en1: \n   [ { address: 'fe80::cabc:c8ff:feef:f996', family: 'IPv6',\n       internal: false },\n     { address: '10.0.1.123', family: 'IPv4', internal: false } ],\n  vmnet1: [ { address: '10.99.99.254', family: 'IPv4', internal: false } ],\n  vmnet8: [ { address: '10.88.88.1', family: 'IPv4', internal: false } ],\n  ppp0: [ { address: '10.2.0.231', family: 'IPv4', internal: false } ] }</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "os.EOL",
          "name": "EOL",
          "desc": "<!--\nA constant defining the appropriate End-of-line marker for the operating system.\n-->\n\n<p>オペレーティングシステムに適した行区切り文字を定義した定数です。\n\n</p>\n"
        }
      ],
      "type": "module",
      "displayName": "os"
    },
    {
      "textRaw": "Cluster",
      "name": "cluster",
      "stability": 1,
      "stabilityText": "Experimental",
      "desc": "<!--\nA single instance of Node runs in a single thread. To take advantage of\nmulti-core systems the user will sometimes want to launch a cluster of Node\nprocesses to handle the load.\n-->\n\n<p>一つの Node インスタンスは一つのスレッドで実行されます。\nマルチコアシステムのメリットを生かすために、\nユーザは時々 Node プロセスのクラスを起動して負荷を分散したくなります。\n\n</p>\n<!--\nThe cluster module allows you to easily create child processes that\nall share server ports.\n-->\n\n<p>クラスタモジュールは、サーバポートを共有する複数の子プロセスを簡単に\n構築することを可能にします。\n\n</p>\n<pre><code>var cluster = require('cluster');\nvar http = require('http');\nvar numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n  // Fork workers.\n  for (var i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', function(worker, code, signal) {\n    console.log('worker ' + worker.process.pid + ' died');\n  });\n} else {\n  // Workers can share any TCP connection\n  // In this case its a HTTP server\n  http.createServer(function(req, res) {\n    res.writeHead(200);\n    res.end("hello world\\n");\n  }).listen(8000);\n}</code></pre>\n<!--\nRunning node will now share port 8000 between the workers:\n-->\n\n<p>node は 8000 番ポートをワーカ間で共有します。\n\n</p>\n<pre><code>% NODE_DEBUG=cluster node server.js\n23521,Master Worker 23524 online\n23521,Master Worker 23526 online\n23521,Master Worker 23523 online\n23521,Master Worker 23528 online</code></pre>\n<!--\nThis feature was introduced recently, and may change in future versions.\nPlease try it out and provide feedback.\n-->\n\n<p>この機能は最近導入されたばかりであり、\n将来のバージョンで変更される可能性があります。\nこれを試して、フィードバックを行ってください。\n\n</p>\n<!--\nAlso note that, on Windows, it is not yet possible to set up a named pipe\nserver in a worker.\n-->\n\n<p>Windows では、ワーカが名前付きパイプによるサーバをセットアップすることは\nまだできないことにも注意してください。\n\n</p>\n",
      "miscs": [
        {
          "textRaw": "How It Works",
          "name": "How It Works",
          "type": "misc",
          "desc": "<!--\nThe worker processes are spawned using the `child_process.fork` method,\nso that they can communicate with the parent via IPC and pass server\nhandles back and forth.\n-->\n\n<p>ワーカプロセスは <code>child_process.fork</code> メソッドを使って起動されるため、\n親プロセスと IPC で通信したり、サーバハンドルをやり取りしたりすることが\nできます。\n\n</p>\n<!--\nWhen you call `server.listen(...)` in a worker, it serializes the\narguments and passes the request to the master process.  If the master\nprocess already has a listening server matching the worker's\nrequirements, then it passes the handle to the worker.  If it does not\nalready have a listening server matching that requirement, then it will\ncreate one, and pass the handle to the worker.\n-->\n\n<p>ワーカが <code>server.listen(...)</code> を呼び出すと、引数がシリアライズされて\nマスタプロセスにリクエストが渡されます。\nマスタプロセスは、ワーカのリクエストにマッチするリスニングサーバが既に\n存在すればそのハンドルをワーカに渡します。\nリクエストにマッチするリスニングサーバが存在しなければ、それが作成されて\nワーカに渡されます。\n\n</p>\n<!--\nThis causes potentially surprising behavior in three edge cases:\n-->\n\n<p>これは三つの極端なケースで驚くような振る舞いを引き起こすかもしれません。\n\n</p>\n<!--\n1. `server.listen({fd: 7})` Because the message is passed to the master,\n   file descriptor 7 **in the parent** will be listened on, and the\n   handle passed to the worker, rather than listening to the worker's\n   idea of what the number 7 file descriptor references.\n2. `server.listen(handle)` Listening on handles explicitly will cause\n   the worker to use the supplied handle, rather than talk to the master\n   process.  If the worker already has the handle, then it's presumed\n   that you know what you are doing.\n3. `server.listen(0)` Normally, this will cause servers to listen on a\n   random port.  However, in a cluster, each worker will receive the\n   same \"random\" port each time they do `listen(0)`.  In essence, the\n   port is random the first time, but predictable thereafter.  If you\n   want to listen on a unique port, generate a port number based on the\n   cluster worker ID.\n-->\n\n<ol>\n<li><code>server.listen({fd: 7})</code> メッセージはマスタに渡されてるため、\nワーカのファイル記述子 7 が参照するものではなく、\n<strong>親プロセスの</strong> ファイル記述子 7 がリスニングされてそのハンドルがワーカに\n渡されます。</li>\n<li><code>server.listen(handle)</code> 明示的なハンドルをリスニングするとマスタプロセスは\n関与することなく、ワーカは与えられたハンドルを使うことになります。\nワーカがすでにハンドルを持っているなら、何をしようとしているか\nあなたは分かっているでしょう。</li>\n<li><code>'server.listen(0)</code> 通常、これはサーバがランダムなポートをリッスンすることを\n意味します。しかしながらクラスタでは、各ワーカは <code>listen(0)</code> によって\n同じ "ランダムな" ポートを受信します。\nすなわち、初回はポートはランダムになりますが、その後はそうではありません。\nもしユニークなポートをリッスンしたければ、クラスタのワーカ ID に基づいて\nポート番号を生成してください。</li>\n</ol>\n<!--\nWhen multiple processes are all `accept()`ing on the same underlying\nresource, the operating system load-balances across them very\nefficiently.  There is no routing logic in Node.js, or in your program,\nand no shared state between the workers.  Therefore, it is important to\ndesign your program such that it does not rely too heavily on in-memory\ndata objects for things like sessions and login.\n-->\n\n<p>複数のプロセスが同じリソースを <code>accept()</code> する時、オペレーティングシステムは\nとても効率的にそれら全体をロードバランスします。\nNode.js にもあなたのプログラムにも、ルーティングのためのロジックや\nワーカ間で共有される状態はありません。\nしたがって、あなたのプログラムがセッションやログインのためにメモリ内の\nデータオブジェクトに過度に頼らないように設計することが重要です。\n\n</p>\n<!--\nBecause workers are all separate processes, they can be killed or\nre-spawned depending on your program's needs, without affecting other\nworkers.  As long as there are some workers still alive, the server will\ncontinue to accept connections.  Node does not automatically manage the\nnumber of workers for you, however.  It is your responsibility to manage\nthe worker pool for your application's needs.\n-->\n\n<p>全てのワーカは独立したプロセスなので、他のワーカに影響を与えることなく\nプログラムのニーズに応じてそれらを殺したり再起動したりすることができます。\nいくつかのワーカが生きている限り、サーバは接続を受け付け続けます。\nしかしながら、Node はワーカの数を自動的に管理することはありません。\nアプリケーションのニーズに応じてワーカのプールを管理することは、\nあなたの責務です。\n\n</p>\n"
        }
      ],
      "properties": [
        {
          "textRaw": "`settings` {Object} ",
          "name": "settings",
          "* {Object}\n  * `execArgv` {Array} list of string arguments passed to the node executable. \n    (Default": "`process.execArgv`)\n  * `exec` {String} file path to worker file.  (Default=`process.argv[1]`)\n  * `args` {Array} string arguments passed to worker.\n    (Default=`process.argv.slice(2)`)\n  * `silent` {Boolean} whether or not to send output to parent's stdio.\n    (Default=`false`)",
          "options": [
            {
              "textRaw": "`execArgv` {Array} node 実行可能ファイルに渡される文字列引数の配列。 (デフォルトは `process.execArgv`) ",
              "name": "execArgv",
              "type": "Array",
              "desc": "node 実行可能ファイルに渡される文字列引数の配列。 (デフォルトは `process.execArgv`)"
            },
            {
              "textRaw": "`exec` {String} ワーカで実行するファイルへのパス。 (デフォルトは `process.argv[1]`) ",
              "name": "exec",
              "type": "String",
              "desc": "ワーカで実行するファイルへのパス。 (デフォルトは `process.argv[1]`)"
            },
            {
              "textRaw": "`args` {Array} ワーカに渡される引数となる文字列。 (デフォルトは `process.argv.slice(2)`) ",
              "name": "args",
              "type": "Array",
              "desc": "ワーカに渡される引数となる文字列。 (デフォルトは `process.argv.slice(2)`)"
            },
            {
              "textRaw": "`silent` {Boolean} 出力を親プロセスに送るかどうか。 (デフォルトは `false`) ",
              "name": "silent",
              "type": "Boolean",
              "desc": "出力を親プロセスに送るかどうか。 (デフォルトは `false`)"
            }
          ],
          "desc": "<!--\nAfter calling `.setupMaster()` (or `.fork()`) this settings object will contain\nthe settings, including the default values.\n-->\n\n<p><code>.setupMaster()</code> (または <code>.fork()</code>) が呼び出された後、この <code>settings</code>\nオブジェクトはデフォルト値を含む設定オブジェクトを持ちます。\n\n</p>\n<!--\nIt is effectively frozen after being set, because `.setupMaster()` can\nonly be called once.\n-->\n\n<p><code>.setupMaster()</code> は一度しか呼び出せないため、それは設定された後で事実上\n凍結されます。\n\n</p>\n<!--\nThis object is not supposed to be changed or set manually, by you.\n-->\n\n<p>このオブジェクトはあなたによって変更されることを想定していません。\n\n</p>\n"
        },
        {
          "textRaw": "`isMaster` {Boolean} ",
          "name": "isMaster",
          "desc": "<!--\nTrue if the process is a master. This is determined\nby the `process.env.NODE_UNIQUE_ID`. If `process.env.NODE_UNIQUE_ID` is\nundefined, then `isMaster` is `true`.\n-->\n\n<p>現在のプロセスがマスタの場合は <code>true</code> です。\nこれは <code>process.env.NODE_UNIQUE_ID</code> から決定されます。\n<code>process.env.NODE_UNIQUE_ID</code> が未定義だと <code>isMaster</code> は <code>true</code> になります。\n\n</p>\n"
        },
        {
          "textRaw": "`isWorker` {Boolean} ",
          "name": "isWorker",
          "desc": "<!--\nTrue if the process is not a master (it is the negation of `cluster.isMaster`).\n-->\n\n<p>このプロセスがマスタでなければ <code>true</code> (これは <code>cluster.isMaster</code> の否定です)。\n\n</p>\n"
        },
        {
          "textRaw": "`worker` {Object} ",
          "name": "worker",
          "desc": "<!--\nA reference to the current worker object. Not available in the master process.\n-->\n\n<p>現在のワーカオブジェクトへの参照です。\nマスタプロセスでは利用できません。\n\n</p>\n<pre><code>var cluster = require('cluster');\n\nif (cluster.isMaster) {\n  console.log('I am master');\n  cluster.fork();\n  cluster.fork();\n} else if (cluster.isWorker) {\n  console.log('I am worker #' + cluster.worker.id);\n}</code></pre>\n"
        },
        {
          "textRaw": "`workers` {Object} ",
          "name": "workers",
          "desc": "<!--\nA hash that stores the active worker objects, keyed by `id` field. Makes it\neasy to loop through all the workers. It is only available in the master\nprocess.\n-->\n\n<p><code>id</code> をキーとしてアクティブなワーカオブジェクトを保存しているハッシュです。\nこれは全てのワーカに対して繰り返しを行うことを容易にします。\nマスタプロセスでのみ利用可能です。\n\n</p>\n<!--\nA worker is removed from cluster.workers just before the `'disconnect'` or\n`'exit'` event is emitted.\n-->\n\n<p>ワーカは <code>'disconnect'</code> や <code>'exit'</code> が生成される前に <code>cluster.worker</code> から\n削除されます。\n\n</p>\n<pre><code>// Go through all workers\nfunction eachWorker(callback) {\n  for (var id in cluster.workers) {\n    callback(cluster.workers[id]);\n  }\n}\neachWorker(function(worker) {\n  worker.send('big announcement to all workers');\n});</code></pre>\n<!--\nShould you wish to reference a worker over a communication channel, using\nthe worker's unique id is the easiest way to find the worker.\n-->\n\n<p>通信チャネルを越えてワーカの参照を渡す場合は、\nワーカのユニークな ID を使ってワーカを探すのが簡単です。\n\n</p>\n<pre><code>socket.on('data', function(id) {\n  var worker = cluster.workers[id];\n});</code></pre>\n"
        }
      ],
      "events": [
        {
          "textRaw": "Event: 'fork'",
          "type": "event",
          "name": "fork",
          "params": [],
          "desc": "<!--\nWhen a new worker is forked the cluster module will emit a 'fork' event.\nThis can be used to log worker activity, and create your own timeout.\n-->\n\n<p>新しいワーカがフォークされると、クラスタモジュールは <code>'fork'</code> イベントを\n生成します。\nこれはワーカの活動をロギングしたり、タイムアウトのために使うことができます。\n\n</p>\n<pre><code>var timeouts = [];\nfunction errorMsg() {\n  console.error("Something must be wrong with the connection ...");\n}\n\ncluster.on('fork', function(worker) {\n  timeouts[worker.id] = setTimeout(errorMsg, 2000);\n});\ncluster.on('listening', function(worker, address) {\n  clearTimeout(timeouts[worker.id]);\n});\ncluster.on('exit', function(worker, code, signal) {\n  clearTimeout(timeouts[worker.id]);\n  errorMsg();\n});</code></pre>\n"
        },
        {
          "textRaw": "Event: 'online'",
          "type": "event",
          "name": "online",
          "params": [],
          "desc": "<!--\nAfter forking a new worker, the worker should respond with an online message.\nWhen the master receives an online message it will emit this event.\nThe difference between 'fork' and 'online' is that fork is emitted when the\nmaster forks a worker, and 'online' is emitted when the worker is running.\n-->\n\n<p>新しいワーカをフォークした後、ワーカはオンラインメッセージを応答します。\nマスタがオンラインメッセージを受信すると、このイベントが生成されます。\n<code>'fork'</code> と <code>'online'</code> の違いは、<code>'fork'</code> はマスタがワーカをフォークした時点で\n生成されるのに対し、<code>'online'</code> はワーカが実行されてから生成される点です。\n\n</p>\n<pre><code>cluster.on('online', function(worker) {\n  console.log("Yay, the worker responded after it was forked");\n});</code></pre>\n"
        },
        {
          "textRaw": "Event: 'listening'",
          "type": "event",
          "name": "listening",
          "params": [],
          "desc": "<!--\nAfter calling `listen()` from a worker, when the 'listening' event is emitted on\nthe server, a listening event will also be emitted on `cluster` in the master.\n-->\n\n<p>ワーカが <code>net.Server.listen()</code> を呼び出した後、(net や http などの) サーバでは\n<code>'listening'</code> イベントが生成され、マスタの <code>cluster</code> でも <code>'listening'</code>\nイベントが生成されます。\n\n</p>\n<!--\nThe event handler is executed with two arguments, the `worker` contains the worker\nobject and the `address` object contains the following connection properties:\n`address`, `port` and `addressType`. This is very useful if the worker is listening\non more than one address.\n-->\n\n<p>イベントハンドラは二つの引数を伴って実行されます。\n<code>worker</code> はワーカオブジェクトを、<code>address</code> オブジェクトは\n以下の接続プロパティを含みます:\n<code>address</code>、<code>prot</code>、そして <code>addressType</code> です。\nこれはワーカが複数のアドレスをリッスンしている場合にとても便利です。\n\n</p>\n<pre><code>cluster.on('listening', function(worker, address) {\n  console.log("A worker is now connected to " + address.address + ":" + address.port);\n});</code></pre>\n<!--\nThe `addressType` is one of:\n-->\n\n<p><code>addressType</code> は以下のいずれかです:\n\n</p>\n<!--\n* `4` (TCPv4)\n* `6` (TCPv6)\n* `-1` (unix domain socket)\n* `\"udp4\"` or `\"udp6\"` (UDP v4 or v6)\n-->\n\n<ul>\n<li><code>4</code> (TCPv4)</li>\n<li><code>6</code> (TCPv6)</li>\n<li><code>-1</code> (unix ドメインソケット)</li>\n<li><code>"udp4"</code> または <code>"udp6"</code> (UDP v4 または v6)</li>\n</ul>\n"
        },
        {
          "textRaw": "Event: 'disconnect'",
          "type": "event",
          "name": "disconnect",
          "params": [],
          "desc": "<!--\nEmitted after the worker IPC channel has disconnected. This can occur when a\nworker exits gracefully, is killed, or is disconnected manually (such as with\nworker.disconnect()).\n-->\n\n<p>ワーカとの IPC チャネルが切断された後で生成されます。\nそれはワーカが自然に終了したり、殺されたり、あるいは (<code>worker.disconnect()</code>\nにより) 手動で切断された場合に発生します。\n\n</p>\n<!--\nThere may be a delay between the `disconnect` and `exit` events.  These events\ncan be used to detect if the process is stuck in a cleanup or if there are\nlong-living connections.\n-->\n\n<p><code>'disconnect'</code> と <code>'exit'</code> の間には遅延があるかもしれません。\nこのイベントはプロセスがクリーンナップで行き詰まったり、長時間生きている接続が\nないかを検出することに使用できます。\n\n</p>\n<pre><code>cluster.on('disconnect', function(worker) {\n  console.log('The worker #' + worker.id + ' has disconnected');\n});</code></pre>\n"
        },
        {
          "textRaw": "Event: 'exit'",
          "type": "event",
          "name": "exit",
          "desc": "<!--\n* `worker` {Worker object}\n* `code` {Number} the exit code, if it exited normally.\n* `signal` {String} the name of the signal (eg. `'SIGHUP'`) that caused\n  the process to be killed.\n-->\n\n<ul>\n<li><code>worker</code> {Worker object}</li>\n<li><code>code</code> {Number} 正常に終了した場合は終了コード。</li>\n<li><code>signal</code> {String} プロセスが殺される原因となったシグナルの名前\n(例: <code>'SIGHUP'</code>)。</li>\n</ul>\n<!--\nWhen any of the workers die the cluster module will emit the 'exit' event.\n-->\n\n<p>どのワーカが死んだ場合でも、クラスタモジュールは <code>'exit'</code> イベントを\n生成します。\n\n</p>\n<!--\nThis can be used to restart the worker by calling `.fork()` again.\n-->\n\n<p>これは <code>.fork()</code> を呼び出してワーカを再開する場合に使用することができます。\n\n</p>\n<pre><code>cluster.on('exit', function(worker, code, signal) {\n  console.log('worker %d died (%s). restarting...',\n    worker.process.pid, signal || code);\n  cluster.fork();\n});</code></pre>\n<p>See <a href="\"child_process.html#child_process_event_exit\"">child_process event: 'exit'</a>.\n\n</p>\n",
          "params": []
        },
        {
          "textRaw": "Event: 'setup'",
          "type": "event",
          "name": "setup",
          "desc": "<!--\nEmitted the first time that `.setupMaster()` is called.\n-->\n\n<p><code>setupMaster()</code> が最初に呼ばれた時に生成されます。\n\n</p>\n",
          "params": []
        }
      ],
      "methods": [
        {
          "textRaw": "cluster.setupMaster([settings])",
          "type": "method",
          "name": "setupMaster",
          "* `settings` {Object}\n  * `exec` {String} file path to worker file.  (Default": "`process.argv[1]`)\n  * `args` {Array} string arguments passed to worker.\n    (Default=`process.argv.slice(2)`)\n  * `silent` {Boolean} whether or not to send output to parent's stdio.\n    (Default=`false`)",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`settings` {Object} ",
                  "options": [
                    {
                      "textRaw": "`exec` {String} ワーカで実行するファイルへのパス. (デフォルトは `process.argv[1]`) ",
                      "name": "exec",
                      "type": "String",
                      "desc": "ワーカで実行するファイルへのパス. (デフォルトは `process.argv[1]`)"
                    },
                    {
                      "textRaw": "`args` {Array} ワーカに渡される引数となる文字列。 (デフォルトは `process.argv.slice(2)`) ",
                      "name": "args",
                      "type": "Array",
                      "desc": "ワーカに渡される引数となる文字列。 (デフォルトは `process.argv.slice(2)`)"
                    },
                    {
                      "textRaw": "`silent` {Boolean} 出力を親プロセスに送るかどうか。 (デフォルトは `false`) ",
                      "name": "silent",
                      "type": "Boolean",
                      "desc": "出力を親プロセスに送るかどうか。 (デフォルトは `false`)"
                    }
                  ],
                  "name": "settings",
                  "type": "Object",
                  "optional": true
                }
              ]
            },
            {
              "params": [
                {
                  "name": "settings",
                  "optional": true
                }
              ]
            }
          ],
          "desc": "<!--\n`setupMaster` is used to change the default 'fork' behavior. Once called,\nthe settings will be present in `cluster.settings`.\n-->\n\n<p><code>setupMaster()</code> は 'fork' のデフォルト動作を変更するために使われます。\n一度呼び出されると、その設定は <code>cluster.settings</code> に反映されます。\n\n</p>\n<!--\nNote that:\n-->\n\n<p>注意事項:\n\n</p>\n<!--\n* Only the first call to `.setupMaster()` has any effect, subsequent calls are\n  ignored\n* That because of the above, the *only* attribute of a worker that may be\n  customized per-worker is the `env` passed to `.fork()`\n* `.fork()` calls `.setupMaster()` internally to establish the defaults, so to\n  have any effect, `.setupMaster()` must be called *before* any calls to\n  `.fork()`\n-->\n\n<ul>\n<li><code>.setupMaster()</code> の最初の呼び出しだけ効果があります。\nその後の呼び出しは無視されます。</li>\n<li>上記のため、ワーカごとにカスタマイズできる属性は <code>.fork()</code> に渡すことのできる\n<code>env</code> <em>だけ</em> です。</li>\n<li><code>.fork()</code> はデフォルト値を反映するために内部で <code>.setupMaster()</code>\nを呼び出すため、<code>.setupMaster()</code> が効果を持つには <code>.fork()</code> よりも前に\n呼び出す必要があります。</li>\n</ul>\n<!--\nExample:\n-->\n\n<p>例:\n\n</p>\n<pre><code>var cluster = require("cluster");\ncluster.setupMaster({\n  exec : "worker.js",\n  args : ["--use", "https"],\n  silent : true\n});\ncluster.fork();</code></pre>\n<!--\nThis can only be called from the master process.\n-->\n\n<p>これはマスタプロセスからのみ、呼び出すことができます。\n\n</p>\n"
        },
        {
          "textRaw": "cluster.fork([env])",
          "type": "method",
          "name": "fork",
          "desc": "<!--\n* `env` {Object} Key/value pairs to add to worker process environment.\n* return {Worker object}\n-->\n\n<ul>\n<li><code>env</code> {Object} ワーカプロセスの環境に加えられるキーと値のペア。</li>\n<li>return {Worker object}</li>\n</ul>\n<!--\nSpawn a new worker process.\n-->\n\n<p>新しいワーカプロセスを起動します。\n\n</p>\n<!--\nThis can only be called from the master process.\n-->\n\n<p>これはマスタプロセスからのみ呼び出すことができます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "env",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "cluster.disconnect([callback])",
          "type": "method",
          "name": "disconnect",
          "desc": "<!--\n* `callback` {Function} called when all workers are disconnected and handles are\n  closed\n-->\n\n<ul>\n<li><code>callback</code> {Function} 全てのワーカが切断し、ハンドルがクローズされると\n呼び出されます。</li>\n</ul>\n<!--\nCalls `.disconnect()` on each worker in `cluster.workers`.\n-->\n\n<p><code>cluster.workers</code> 内の各ワーカに対して <code>.disconnect()</code> を呼び出します。\n\n</p>\n<!--\nWhen they are disconnected all internal handles will be closed, allowing the\nmaster process to die gracefully if no other event is waiting.\n-->\n\n<p>ワーカとの接続が切断して内部的なハンドルが全てクローズされると、\n他に待機しているイベントがなければ、マスタプロセスは自然に終了します。\n\n</p>\n<!--\nThe method takes an optional callback argument which will be called when finished.\n-->\n\n<p>このメソッドはオプションの引数としてコールバックを受け取ります。\n\n</p>\n<!--\nThis can only be called from the master process.\n-->\n\n<p>これはマスタプロセスからのみ呼び出すことができます。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Worker",
          "type": "class",
          "name": "Worker",
          "desc": "<!--\nA Worker object contains all public information and method about a worker.\nIn the master it can be obtained using `cluster.workers`. In a worker\nit can be obtained using `cluster.worker`.\n-->\n\n<p>ワーカに関する全ての公開された情報やメソッドを持つオブジェクトです。\nマスタでは <code>cluster.wrokers</code> から取得することができます。\nワーカでは <code>cluster.worker</code> から取得することができます。\n\n</p>\n",
          "properties": [
            {
              "textRaw": "`id` {String} ",
              "name": "id",
              "desc": "<!--\nEach new worker is given its own unique id, this id is stored in the\n`id`.\n\nWhile a worker is alive, this is the key that indexes it in\ncluster.workers\n-->\n\n<p>新しいワーカはいずれもユニークな ID を与えられます。\nこの ID は <code>id</code> に保存されます。\n\n</p>\n<p>ワーカが生きている間、これは <code>cluseter.workers</code> のキーとなります。\n\n</p>\n"
            },
            {
              "textRaw": "`process` {ChildProcess object} ",
              "name": "process",
              "desc": "<!--\nAll workers are created using `child_process.fork()`, the returned object\nfrom this function is stored as `.process`. In a worker, the global `process`\nis stored.\n-->\n\n<p>全てのワーカは <code>child_process.fork()</code> によって作成されます。\nその戻り値は <code>.process</code> に設定されます。\nワーカでは、グローバルの <code>process</code> に設定されます。\n\n</p>\n<!--\nSee: [Child Process module](\nchild_process.html#child_process_child_process_fork_modulepath_args_options)\n-->\n\n<p>参照: <a href="\"child_process.html#child_process_child_process_fork_modulepath_args_options\"">Child Process module</a>\n\n</p>\n<!--\nNote that workers will call `process.exit(0)` if the `'disconnect'` event occurs\non `process` and `.suicide` is not `true`. This protects against accidental\ndisconnection.\n-->\n\n<p><code>process</code> で <code>'disconnect'</code> イベントが生成されるとワーカが <code>process.exit(0)</code>\nを呼び出し、<code>.suicide</code> が <code>true</code> にならないことに注意してください。\nこれは偶発的な切断を防ぎます。\n\n</p>\n"
            },
            {
              "textRaw": "`suicide` {Boolean} ",
              "name": "suicide",
              "desc": "<!--\nSet by calling `.kill()` or `.disconnect()`, until then it is `undefined`.\n-->\n\n<p><code>.kill()</code> または <code>.disconnect()</code> によって設定されます。\nそれまでは <code>undefined</code> です。\n\n</p>\n<!--\nThe boolean `worker.suicide` lets you distinguish between voluntary and accidental\nexit, the master may choose not to respawn a worker based on this value.\n-->\n\n<p>真偽値の <code>worker.suicide</code> は、ワーカが自発的に終了したのか偶発的に終了したのかを\n区別します。\nマスタはこの値に基づいて、ワーカを再起動しないことを選ぶことができます。\n\n</p>\n<pre><code>cluster.on('exit', function(worker, code, signal) {\n  if (worker.suicide === true) {\n    console.log('Oh, it was just suicide\\' – no need to worry').\n  }\n});\n\n// kill worker\nworker.kill();</code></pre>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "worker.send(message, [sendHandle])",
              "type": "method",
              "name": "send",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`message` {Object} ",
                      "name": "message",
                      "type": "Object"
                    },
                    {
                      "textRaw": "`sendHandle` {Handle object} ",
                      "name": "sendHandle",
                      "type": "Handle object",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "message"
                    },
                    {
                      "name": "sendHandle",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<!--\nThis function is equal to the send methods provided by\n`child_process.fork()`.  In the master you should use this function to\nsend a message to a specific worker.\n-->\n\n<p>この関数は <code>child_process.fork()</code> が返すオブジェクトの <code>send()</code>\nメソッドと同じです。\nマスタは特定のワーカにメッセージを送信するためにこの関数を\n使用することができます。\n\n</p>\n<!--\nIn a worker you can also use `process.send(message)`, it is the same function.\n-->\n\n<p>ワーカでは <code>process.send(message)</code> を使うこともできます。\nそれは同じ関数です。\n\n</p>\n<!--\nThis example will echo back all messages from the master:\n-->\n\n<p>この例はマスタからのメッセージをエコーバックします。\n\n</p>\n<pre><code>if (cluster.isMaster) {\n  var worker = cluster.fork();\n  worker.send('hi there');\n\n} else if (cluster.isWorker) {\n  process.on('message', function(msg) {\n    process.send(msg);\n  });\n}</code></pre>\n"
            },
            {
              "textRaw": "worker.kill([signal='SIGTERM'])",
              "type": "method",
              "name": "kill",
              "desc": "<!--\n* `signal` {String} Name of the kill signal to send to the worker\n  process.\n-->\n\n<ul>\n<li><code>signal</code> {String} ワーカプロセスに送られるシグナルの名前です。</li>\n</ul>\n<!--\nThis function will kill the worker. In the master, it does this by disconnecting\nthe `worker.process`, and once disconnected, killing with `signal`. In the\nworker, it does it by disconnecting the channel, and then exiting with code `0`.\n-->\n\n<p>この関数はワーカを終了します。\nマスタでは、これは <code>worker.process</code> と切断することによって行われます。\nそして切断されると、<code>signal</code> によってワーカを殺します。\nワーカでは、これはチャネルの切断によって行われ、コード <code>0</code> で終了します。\n\n</p>\n<!--\nCauses `.suicide` to be set.\n-->\n\n<p><code>.suicide</code> が設定される原因となります。\n\n</p>\n<!--\nThis method is aliased as `worker.destroy()` for backwards compatibility.\n-->\n\n<p>後方互換性のため、このメソッドには <code>worker.destroy()</code> という別名があります。\n\n</p>\n<!--\nNote that in a worker, `process.kill()` exists, but it is not this function,\nit is [kill](process.html#process_process_kill_pid_signal).\n-->\n\n<p>ワーカでは、<code>process.kill()</code> は存在するものの、それは関数ではないことに\n注意してください。\n<a href="\"process.html#process_process_kill_pid_signal\"">kill</a> を参照してください。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "signal",
                      "optional": true,
                      "default": "'SIGTERM'"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "worker.disconnect()",
              "type": "method",
              "name": "disconnect",
              "desc": "<!--\nIn a worker, this function will close all servers, wait for the 'close' event on\nthose servers, and then disconnect the IPC channel.\n-->\n\n<p>ワーカでは、この関数は全てのサーバをクローズし、それらのサーバの <code>'close'</code>\nイベントを待機し、そして IPC チャネルを切断します。\n\n</p>\n<!--\nIn the master, an internal message is sent to the worker causing it to call\n`.disconnect()` on itself.\n-->\n\n<p>マスタでは、ワーカが自分の <code>.disconnect()</code> を呼び出すことになる内部メッセージを\nワーカに送ります。\n\n</p>\n<!--\nCauses `.suicide` to be set.\n-->\n\n<p><code>.suicide</code> が設定される原因となります。\n\n</p>\n<!--\nNote that after a server is closed, it will no longer accept new connections,\nbut connections may be accepted by any other listening worker. Existing\nconnections will be allowed to close as usual. When no more connections exist,\nsee [server.close()](net.html#net_event_close), the IPC channel to the worker\nwill close allowing it to die gracefully.\n-->\n\n<p>サーバがクローズした後、それはもう新たな接続を受け付けなくなりますが、\n他のワーカによって接続は受け付けられることに注意してください。\n既存のコネクションは通常通りクローズすることができます。\nコネクションが無くなると (<a href="\"net.html#net_event_close\"">server.close()</a> 参照)、\nワーカが自然に終了できるように IPC チャネルはクローズされます。\n\n</p>\n<!--\nThe above applies *only* to server connections, client connections are not\nautomatically closed by workers, and disconnect does not wait for them to close\nbefore exiting.\n-->\n\n<p>上記はサーバ側のコネクションにのみ適用されます。\nクライアント側のコネクションはワーカによって自動的にクローズされることはなく、\n終了する前にそれらがクローズすることを待つこともありません。\n\n</p>\n<!--\nNote that in a worker, `process.disconnect` exists, but it is not this function,\nit is [disconnect](child_process.html#child_process_child_disconnect).\n-->\n\n<p>ワーカでは、<code>process.disconnect</code> は存在しますが、それはここで説明した関数では\nありません。それは\n<a href="\"child_process.html#child_process_child_disconnect\"">disconnect</a> です。\n\n</p>\n<!--\nBecause long living server connections may block workers from disconnecting, it\nmay be useful to send a message, so application specific actions may be taken to\nclose them. It also may be useful to implement a timeout, killing a worker if\nthe `disconnect` event has not been emitted after some time.\n-->\n\n<p>長時間生きているサーバ側のコネクションはワーカが切断することを妨げるため、\nそれらをクローズするためにアプリケーション固有のメッセージを送ることは有用です。\n加えて、一定の時間が経過しても <code>'disconnect'</code> イベントが発生しなかった場合に\nワーカを強制終了する実装も有用です。\n\n</p>\n<pre><code>if (cluster.isMaster) {\n  var worker = cluster.fork();\n  var timeout;\n\n  worker.on('listening', function(address) {\n    worker.send('shutdown');\n    worker.disconnect();\n    timeout = setTimeout(function() {\n      worker.kill();\n    }, 2000);\n  });\n\n  worker.on('disconnect', function() {\n    clearTimeout(timeout);\n  });\n\n} else if (cluster.isWorker) {\n  var net = require('net');\n  var server = net.createServer(function(socket) {\n    // connections never end\n  });\n\n  server.listen(8000);\n\n  process.on('message', function(msg) {\n    if(msg === 'shutdown') {\n      // initiate graceful close of any connections to server\n    }\n  });\n}</code></pre>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'message'",
              "type": "event",
              "name": "message",
              "params": [],
              "desc": "<!--\nThis event is the same as the one provided by `child_process.fork()`.\n-->\n\n<p>このイベントは <code>child_process.fork()</code> が提供するものと同じです。\n\n</p>\n<!--\nIn a worker you can also use `process.on('message')`.\n-->\n\n<p>ワーカでは、<code>process.on('message')</code> を使うこともできます。\n\n</p>\n<!--\nAs an example, here is a cluster that keeps count of the number of requests\nin the master process using the message system:\n-->\n\n<p>メッセージシステムを使用してクラスタ全体のリクエスト数を\nマスタプロセスで保持する例です:\n\n</p>\n<pre><code>var cluster = require('cluster');\nvar http = require('http');\n\nif (cluster.isMaster) {\n\n  // Keep track of http requests\n  var numReqs = 0;\n  setInterval(function() {\n    console.log("numReqs =", numReqs);\n  }, 1000);\n\n  // Count requestes\n  function messageHandler(msg) {\n    if (msg.cmd && msg.cmd == 'notifyRequest') {\n      numReqs += 1;\n    }\n  }\n\n  // Start workers and listen for messages containing notifyRequest\n  var numCPUs = require('os').cpus().length;\n  for (var i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  Object.keys(cluster.workers).forEach(function(id) {\n    cluster.workers[id].on('message', messageHandler);\n  });\n\n} else {\n\n  // Worker processes have a http server.\n  http.Server(function(req, res) {\n    res.writeHead(200);\n    res.end("hello world\\n");\n\n    // notify master about the request\n    process.send({ cmd: 'notifyRequest' });\n  }).listen(8000);\n}</code></pre>\n"
            },
            {
              "textRaw": "Event: 'online'",
              "type": "event",
              "name": "online",
              "desc": "<!--\nSimilar to the `cluster.on('online')` event, but specific to this worker.\n-->\n\n<p><code>cluster.on('online')</code> と同様ですが、このワーカに特化しています。\n\n</p>\n<pre><code>cluster.fork().on('online', function() {\n  // Worker is online\n});</code></pre>\n<!--\nIt is not emitted in the worker.\n-->\n\n<p>このイベントはワーカでは生成されません。\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'listening'",
              "type": "event",
              "name": "listening",
              "params": [],
              "desc": "<!--\nSimilar to the `cluster.on('listening')` event, but specific to this worker.\n-->\n\n<p><code>cluster.on('listening')</code> と同様ですが、このワーカに特化しています。\n\n</p>\n<pre><code>cluster.fork().on('listening', function(address) {\n  // Worker is listening\n});</code></pre>\n<!--\nIt is not emitted in the worker.\n-->\n\n<p>このイベントはワーカでは生成されません。\n\n</p>\n"
            },
            {
              "textRaw": "Event: 'disconnect'",
              "type": "event",
              "name": "disconnect",
              "desc": "<!--\nSimilar to the `cluster.on('disconnect')` event, but specfic to this worker.\n-->\n\n<p><code>cluster.on('disconnect')</code> と同様ですが、このワーカに特化しています。\n\n</p>\n<pre><code>cluster.fork().on('disconnect', function() {\n  // Worker has disconnected\n});</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'exit'",
              "type": "event",
              "name": "exit",
              "desc": "<!--\n* `code` {Number} the exit code, if it exited normally.\n* `signal` {String} the name of the signal (eg. `'SIGHUP'`) that caused\n  the process to be killed.\n-->\n\n<ul>\n<li><code>code</code> {Number} 正常に終了した場合は終了コード。</li>\n<li><code>signal</code> {String} プロセスが殺される原因となったシグナルの名前\n(例: <code>'SIGHUP'</code>)。</li>\n</ul>\n<!--\nSimilar to the `cluster.on('exit')` event, but specific to this worker.\n-->\n\n<p><code>cluster.on('exit')</code> と同様ですが、このワーカに特化しています。\n\n</p>\n<pre><code>var worker = cluster.fork();\nworker.on('exit', function(code, signal) {\n  if( signal ) {\n    console.log("worker was killed by signal: "+signal);\n  } else if( code !== 0 ) {\n    console.log("worker exited with error code: "+code);\n  } else {\n    console.log("worker success!");\n  }\n});</code></pre>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "desc": "<!--\nThis event is the same as the one provided by `child_process.fork()`.\n-->\n\n<p>このイベントは <code>child_process.fork()</code> が提供するものと同じです。\n\n</p>\n<!--\nIn a worker you can also use `process.on('error')`.\n-->\n\n<p>ワーカでは <code>process.on('error')</code> を使うこともできます。\n\n</p>\n",
              "params": []
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "Cluster"
    }
  ],
  "stability": 3,
  "stabilityText": "Stable"
}
