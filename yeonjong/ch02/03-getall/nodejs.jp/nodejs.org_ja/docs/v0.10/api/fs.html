<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>File System Node.js v0.10.26 Manual & Documentation</title>
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/api/fs.html">
</head>
<body class="alt apidoc" id="api-section-fs">
    <div id="intro" class="interior">
        <a href="/" title="Go back to the home page">
            <img id="logo" src="http://nodejs.org/images/logo-light.png" alt="node.js">
        </a>
    </div>
    <div id="content" class="clearfix">
        <div id="column2" class="interior">
            <ul>
                <!--
                <li><a href="/" class="home">Home</a></li>
                <li><a href="/download/" class="download">Download</a></li>
                <li><a href="/about/" class="about">About</a></li>
                <li><a href="http://npmjs.org/" class="npm">npm Registry</a></li>
                <li><a href="http://nodejs.org/api/" class="docs current">Docs</a></li>
                <li><a href="http://blog.nodejs.org" class="blog">Blog</a></li>
                <li><a href="/community/" class="community">Community</a></li>
                <li><a href="/logos/" class="logos">Logos</a></li>
                -->
               <li><a href="../" class="home">ホーム</a></li>
               <li><a href="../#download" class="download">ダウンロード</a></li>
               <li><a href="../about/" class="about">概要</a></li>
               <li><a href="http://npmjs.org/" class="npm">npm レジストリ</a></li>
               <li><a href="../api/" class="docs current">ドキュメント</a></li>
               <li><a href="http://blog.nodejs.org" class="blog">ブログ</a></li>
               <li><a href="../community/" class="community">コミュニティ</a></li>
               <li><a href="../logos/" class="logos">ロゴ</a></li>
                <li><a href="http://jobs.nodejs.org/" class="jobs">Jobs</a></li>
            </ul>
            <p class="twitter"><a href="http://twitter.com/nodejs">@nodejs</a></p>
        </div>

        <div id="column1" class="interior">
          <header>
            <h1>Node.js v0.10.26 マニュアル & ドキュメンテーション</h1>
            <div id="gtoc">
              <p>
                <a href="index.html" name="toc">Index</a> |
                <a href="all.html">View on single page</a> |
                <a href="fs.json">View as JSON</a>
              </p>
            </div>
            <hr>
          </header>

          <div id="toc">
            <h2>Table of Contents</h2>
            <ul>
<li><a href="#fs_file_system">File System</a><ul>
<li><a href="#fs_fs_rename_oldpath_newpath_callback">fs.rename(oldPath, newPath, callback)</a></li>
<li><a href="#fs_fs_renamesync_oldpath_newpath">fs.renameSync(oldPath, newPath)</a></li>
<li><a href="#fs_fs_ftruncate_fd_len_callback">fs.ftruncate(fd, len, callback)</a></li>
<li><a href="#fs_fs_ftruncatesync_fd_len">fs.ftruncateSync(fd, len)</a></li>
<li><a href="#fs_fs_truncate_path_len_callback">fs.truncate(path, len, callback)</a></li>
<li><a href="#fs_fs_truncatesync_path_len">fs.truncateSync(path, len)</a></li>
<li><a href="#fs_fs_chown_path_uid_gid_callback">fs.chown(path, uid, gid, callback)</a></li>
<li><a href="#fs_fs_chownsync_path_uid_gid">fs.chownSync(path, uid, gid)</a></li>
<li><a href="#fs_fs_fchown_fd_uid_gid_callback">fs.fchown(fd, uid, gid, callback)</a></li>
<li><a href="#fs_fs_fchownsync_fd_uid_gid">fs.fchownSync(fd, uid, gid)</a></li>
<li><a href="#fs_fs_lchown_path_uid_gid_callback">fs.lchown(path, uid, gid, callback)</a></li>
<li><a href="#fs_fs_lchownsync_path_uid_gid">fs.lchownSync(path, uid, gid)</a></li>
<li><a href="#fs_fs_chmod_path_mode_callback">fs.chmod(path, mode, callback)</a></li>
<li><a href="#fs_fs_chmodsync_path_mode">fs.chmodSync(path, mode)</a></li>
<li><a href="#fs_fs_fchmod_fd_mode_callback">fs.fchmod(fd, mode, callback)</a></li>
<li><a href="#fs_fs_fchmodsync_fd_mode">fs.fchmodSync(fd, mode)</a></li>
<li><a href="#fs_fs_lchmod_path_mode_callback">fs.lchmod(path, mode, callback)</a></li>
<li><a href="#fs_fs_lchmodsync_path_mode">fs.lchmodSync(path, mode)</a></li>
<li><a href="#fs_fs_stat_path_callback">fs.stat(path, callback)</a></li>
<li><a href="#fs_fs_lstat_path_callback">fs.lstat(path, callback)</a></li>
<li><a href="#fs_fs_fstat_fd_callback">fs.fstat(fd, callback)</a></li>
<li><a href="#fs_fs_statsync_path">fs.statSync(path)</a></li>
<li><a href="#fs_fs_lstatsync_path">fs.lstatSync(path)</a></li>
<li><a href="#fs_fs_fstatsync_fd">fs.fstatSync(fd)</a></li>
<li><a href="#fs_fs_link_srcpath_dstpath_callback">fs.link(srcpath, dstpath, callback)</a></li>
<li><a href="#fs_fs_linksync_srcpath_dstpath">fs.linkSync(srcpath, dstpath)</a></li>
<li><a href="#fs_fs_symlink_srcpath_dstpath_type_callback">fs.symlink(srcpath, dstpath, [type], callback)</a></li>
<li><a href="#fs_fs_symlinksync_srcpath_dstpath_type">fs.symlinkSync(srcpath, dstpath, [type])</a></li>
<li><a href="#fs_fs_readlink_path_callback">fs.readlink(path, callback)</a></li>
<li><a href="#fs_fs_readlinksync_path">fs.readlinkSync(path)</a></li>
<li><a href="#fs_fs_realpath_path_cache_callback">fs.realpath(path, [cache], callback)</a></li>
<li><a href="#fs_fs_realpathsync_path_cache">fs.realpathSync(path, [cache])</a></li>
<li><a href="#fs_fs_unlink_path_callback">fs.unlink(path, callback)</a></li>
<li><a href="#fs_fs_unlinksync_path">fs.unlinkSync(path)</a></li>
<li><a href="#fs_fs_rmdir_path_callback">fs.rmdir(path, callback)</a></li>
<li><a href="#fs_fs_rmdirsync_path">fs.rmdirSync(path)</a></li>
<li><a href="#fs_fs_mkdir_path_mode_callback">fs.mkdir(path, [mode], callback)</a></li>
<li><a href="#fs_fs_mkdirsync_path_mode">fs.mkdirSync(path, [mode])</a></li>
<li><a href="#fs_fs_readdir_path_callback">fs.readdir(path, callback)</a></li>
<li><a href="#fs_fs_readdirsync_path">fs.readdirSync(path)</a></li>
<li><a href="#fs_fs_close_fd_callback">fs.close(fd, callback)</a></li>
<li><a href="#fs_fs_closesync_fd">fs.closeSync(fd)</a></li>
<li><a href="#fs_fs_open_path_flags_mode_callback">fs.open(path, flags, [mode], callback)</a></li>
<li><a href="#fs_fs_opensync_path_flags_mode">fs.openSync(path, flags, [mode])</a></li>
<li><a href="#fs_fs_utimes_path_atime_mtime_callback">fs.utimes(path, atime, mtime, callback)</a></li>
<li><a href="#fs_fs_utimessync_path_atime_mtime">fs.utimesSync(path, atime, mtime)</a></li>
<li><a href="#fs_fs_futimes_fd_atime_mtime_callback">fs.futimes(fd, atime, mtime, callback)</a></li>
<li><a href="#fs_fs_futimessync_fd_atime_mtime">fs.futimesSync(fd, atime, mtime)</a></li>
<li><a href="#fs_fs_fsync_fd_callback">fs.fsync(fd, callback)</a></li>
<li><a href="#fs_fs_fsyncsync_fd">fs.fsyncSync(fd)</a></li>
<li><a href="#fs_fs_write_fd_buffer_offset_length_position_callback">fs.write(fd, buffer, offset, length, position, callback)</a></li>
<li><a href="#fs_fs_writesync_fd_buffer_offset_length_position">fs.writeSync(fd, buffer, offset, length, position)</a></li>
<li><a href="#fs_fs_read_fd_buffer_offset_length_position_callback">fs.read(fd, buffer, offset, length, position, callback)</a></li>
<li><a href="#fs_fs_readsync_fd_buffer_offset_length_position">fs.readSync(fd, buffer, offset, length, position)</a></li>
<li><a href="#fs_fs_readfile_filename_options_callback">fs.readFile(filename, [options], callback)</a></li>
<li><a href="#fs_fs_readfilesync_filename_options">fs.readFileSync(filename, [options])</a></li>
<li><a href="#fs_fs_writefile_filename_data_options_callback">fs.writeFile(filename, data, [options], callback)</a></li>
<li><a href="#fs_fs_writefilesync_filename_data_options">fs.writeFileSync(filename, data, [options])</a></li>
<li><a href="#fs_fs_appendfile_filename_data_options_callback">fs.appendFile(filename, data, [options], callback)</a></li>
<li><a href="#fs_fs_appendfilesync_filename_data_options">fs.appendFileSync(filename, data, [options])</a></li>
<li><a href="#fs_fs_watchfile_filename_options_listener">fs.watchFile(filename, [options], listener)</a></li>
<li><a href="#fs_fs_unwatchfile_filename_listener">fs.unwatchFile(filename, [listener])</a></li>
<li><a href="#fs_fs_watch_filename_options_listener">fs.watch(filename, [options], [listener])</a><ul>
<li><a href="#fs_caveats">Caveats</a><ul>
<li><a href="#fs_availability">Availability</a></li>
<li><a href="#fs_filename_argument">Filename Argument</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#fs_fs_exists_path_callback">fs.exists(path, callback)</a></li>
<li><a href="#fs_fs_existssync_path">fs.existsSync(path)</a></li>
<li><a href="#fs_class_fs_stats">Class: fs.Stats</a></li>
<li><a href="#fs_fs_createreadstream_path_options">fs.createReadStream(path, [options])</a></li>
<li><a href="#fs_class_fs_readstream">Class: fs.ReadStream</a><ul>
<li><a href="#fs_event_open">Event: 'open'</a></li>
</ul>
</li>
<li><a href="#fs_fs_createwritestream_path_options">fs.createWriteStream(path, [options])</a></li>
<li><a href="#fs_class_fs_writestream">Class: fs.WriteStream</a><ul>
<li><a href="#fs_event_open_1">Event: 'open'</a></li>
<li><a href="#fs_file_byteswritten">file.bytesWritten</a></li>
</ul>
</li>
<li><a href="#fs_class_fs_fswatcher">Class: fs.FSWatcher</a><ul>
<li><a href="#fs_watcher_close">watcher.close()</a></li>
<li><a href="#fs_event_change">Event: 'change'</a></li>
<li><a href="#fs_event_error">Event: 'error'</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>

          <div id="apicontent">
            <h1>File System<span><a class="mark" href="#fs_file_system" id="fs_file_system">#</a></span></h1>
<pre class="api_stability_3">Stability: 3 - Stable</pre><!--name=fs-->

<!--
File I/O is provided by simple wrappers around standard POSIX functions.  To
use this module do `require('fs')`. All the methods have asynchronous and
synchronous forms.
-->

<p>File I/O は POSIX 標準の関数に対する単純なラッパーとして提供されます。
このモジュールを使用するには <code>require('fs')</code> してください。
全てのメソッドは非同期と同期の形式があります。

</p>
<!--
The asynchronous form always take a completion callback as its last argument.
The arguments passed to the completion callback depend on the method, but the
first argument is always reserved for an exception. If the operation was
completed successfully, then the first argument will be `null` or `undefined`.

When using the synchronous form any exceptions are immediately thrown.
You can use try/catch to handle exceptions or allow them to bubble up.
-->

<p>非同期の形式は常に最後の引数として完了コールバックを受け取ります。
引数として渡される完了コールバックはメソッドに依存しますが、
最初の引数は常に例外のために予約されています。
操作が成功で完了すると最初の引数は <code>null</code> または <code>undefined</code> となります

</p>
<p>同期の形式では、全ての例外はすぐにスローされます。
例外は try/catch で捕まえることも、そのまま通過させることもできます。

</p>
<!--
Here is an example of the asynchronous version:
-->

<p>非同期バージョンの例です:

</p>
<pre><code>var fs = require('fs');

fs.unlink('/tmp/hello', function (err) {
  if (err) throw err;
  console.log('successfully deleted /tmp/hello');
});</code></pre>
<!--
Here is the synchronous version:
-->

<p>同期バージョンです:

</p>
<pre><code>var fs = require('fs');

fs.unlinkSync('/tmp/hello')
console.log('successfully deleted /tmp/hello');</code></pre>
<!--
With the asynchronous methods there is no guaranteed ordering. So the
following is prone to error:
-->

<p>非同期メソッドでは順序の保証はありません。
以下のような傾向のエラーがあります。

</p>
<pre><code>fs.rename('/tmp/hello', '/tmp/world', function (err) {
  if (err) throw err;
  console.log('renamed complete');
});
fs.stat('/tmp/world', function (err, stats) {
  if (err) throw err;
  console.log('stats: ' + JSON.stringify(stats));
});</code></pre>
<!--
It could be that `fs.stat` is executed before `fs.rename`.
The correct way to do this is to chain the callbacks.
-->

<p><code>fs.stat</code> は <code>fs.rename</code> より先に実行される可能性がありrます。
正しい方法はコールバックをチェーンすることです。

</p>
<pre><code>fs.rename('/tmp/hello', '/tmp/world', function (err) {
  if (err) throw err;
  fs.stat('/tmp/world', function (err, stats) {
    if (err) throw err;
    console.log('stats: ' + JSON.stringify(stats));
  });
});</code></pre>
<!--
In busy processes, the programmer is _strongly encouraged_ to use the
asynchronous versions of these calls. The synchronous versions will block
the entire process until they complete--halting all connections.

Relative path to filename can be used, remember however that this path will be
relative to `process.cwd()`.
-->

<p>忙しいプロセスでは、プログラマはこれらの非同期バージョンを使うことが<em>強く推奨</em>されます。
同期バージョンはそれが完了するまでプロセス全体をブロックします － 全ての接続を停止します。

</p>
<p>ファイル名には相対パスを使うことが出来ます。しかし、このパスは
<code>process.cwd()</code> からの相対パスであることを思い出してください。

</p>
<!--
Most fs functions let you omit the callback argument. If you do, a default
callback is used that ignores errors, but prints a deprecation
warning.
-->

<p>fs モジュールのほとんどの関数はコールバック引数を省略することができます。
そうすると、エラーを無視するコールバックがデフォルトとして使用され、
廃止予定の警告が出力されます。

</p>
<!--
**IMPORTANT**: Omitting the callback is deprecated.  v0.12 will throw the
errors as exceptions.
-->

<p><strong>重要</strong>: コールバックの省略は廃止予定です。v0.12 は例外をスローするでしょう。


</p>
<h2>fs.rename(oldPath, newPath, callback)<span><a class="mark" href="#fs_fs_rename_oldpath_newpath_callback" id="fs_fs_rename_oldpath_newpath_callback">#</a></span></h2>
<!--
Asynchronous rename(2). No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の rename(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.renameSync(oldPath, newPath)<span><a class="mark" href="#fs_fs_renamesync_oldpath_newpath" id="fs_fs_renamesync_oldpath_newpath">#</a></span></h2>
<!--
Synchronous rename(2).
-->

<p>同期の rename(2)。

</p>
<h2>fs.ftruncate(fd, len, callback)<span><a class="mark" href="#fs_fs_ftruncate_fd_len_callback" id="fs_fs_ftruncate_fd_len_callback">#</a></span></h2>
<!--
Asynchronous ftruncate(2). No arguments other than a possible exception are
given to the completion callback.
-->

<p>非同期の ftruncate(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.ftruncateSync(fd, len)<span><a class="mark" href="#fs_fs_ftruncatesync_fd_len" id="fs_fs_ftruncatesync_fd_len">#</a></span></h2>
<!--
Synchronous ftruncate(2).
-->

<p>同期の ftruncate(2)。

</p>
<h2>fs.truncate(path, len, callback)<span><a class="mark" href="#fs_fs_truncate_path_len_callback" id="fs_fs_truncate_path_len_callback">#</a></span></h2>
<!--
Asynchronous truncate(2). No arguments other than a possible exception are
given to the completion callback.
-->

<p>非同期の truncate(2)。
完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.truncateSync(path, len)<span><a class="mark" href="#fs_fs_truncatesync_path_len" id="fs_fs_truncatesync_path_len">#</a></span></h2>
<!--
Synchronous truncate(2).
-->

<p>同期の truncate(2)。

</p>
<h2>fs.chown(path, uid, gid, callback)<span><a class="mark" href="#fs_fs_chown_path_uid_gid_callback" id="fs_fs_chown_path_uid_gid_callback">#</a></span></h2>
<!--
Asynchronous chown(2). No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の chown(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.chownSync(path, uid, gid)<span><a class="mark" href="#fs_fs_chownsync_path_uid_gid" id="fs_fs_chownsync_path_uid_gid">#</a></span></h2>
<!--
Synchronous chown(2).
-->

<p>同期の chown(2)。

</p>
<h2>fs.fchown(fd, uid, gid, callback)<span><a class="mark" href="#fs_fs_fchown_fd_uid_gid_callback" id="fs_fs_fchown_fd_uid_gid_callback">#</a></span></h2>
<!--
Asynchronous fchown(2). No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の fchown(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.fchownSync(fd, uid, gid)<span><a class="mark" href="#fs_fs_fchownsync_fd_uid_gid" id="fs_fs_fchownsync_fd_uid_gid">#</a></span></h2>
<!--
Synchronous fchown(2).
-->

<p>同期の fchown(2)。

</p>
<h2>fs.lchown(path, uid, gid, callback)<span><a class="mark" href="#fs_fs_lchown_path_uid_gid_callback" id="fs_fs_lchown_path_uid_gid_callback">#</a></span></h2>
<!--
Asynchronous lchown(2). No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の lchown(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.lchownSync(path, uid, gid)<span><a class="mark" href="#fs_fs_lchownsync_path_uid_gid" id="fs_fs_lchownsync_path_uid_gid">#</a></span></h2>
<!--
Synchronous lchown(2).
-->

<p>同期の lchown(2)。

</p>
<h2>fs.chmod(path, mode, callback)<span><a class="mark" href="#fs_fs_chmod_path_mode_callback" id="fs_fs_chmod_path_mode_callback">#</a></span></h2>
<!--
Asynchronous chmod(2). No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の chmod(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.chmodSync(path, mode)<span><a class="mark" href="#fs_fs_chmodsync_path_mode" id="fs_fs_chmodsync_path_mode">#</a></span></h2>
<!--
Synchronous chmod(2).
-->

<p>同期の chmod(2)。

</p>
<h2>fs.fchmod(fd, mode, callback)<span><a class="mark" href="#fs_fs_fchmod_fd_mode_callback" id="fs_fs_fchmod_fd_mode_callback">#</a></span></h2>
<!--
Asynchronous fchmod(2). No arguments other than a possible exception
are given to the completion callback.
-->

<p>非同期の fchmod(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.fchmodSync(fd, mode)<span><a class="mark" href="#fs_fs_fchmodsync_fd_mode" id="fs_fs_fchmodsync_fd_mode">#</a></span></h2>
<!--
Synchronous fchmod(2).
-->

<p>同期の fchmod(2)。

</p>
<h2>fs.lchmod(path, mode, callback)<span><a class="mark" href="#fs_fs_lchmod_path_mode_callback" id="fs_fs_lchmod_path_mode_callback">#</a></span></h2>
<!--
Asynchronous lchmod(2). No arguments other than a possible exception
are given to the completion callback.
-->

<p>非同期の lchmod(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<!--
Only available on Mac OS X.
-->

<p>Mac OS X でのみ利用可能です。

</p>
<h2>fs.lchmodSync(path, mode)<span><a class="mark" href="#fs_fs_lchmodsync_path_mode" id="fs_fs_lchmodsync_path_mode">#</a></span></h2>
<!--
Synchronous lchmod(2).
-->

<p>同期の lchmod(2)。

</p>
<h2>fs.stat(path, callback)<span><a class="mark" href="#fs_fs_stat_path_callback" id="fs_fs_stat_path_callback">#</a></span></h2>
<!--
Asynchronous stat(2). The callback gets two arguments `(err, stats)` where
`stats` is a [fs.Stats](#fs_class_fs_stats) object.  See the [fs.Stats](#fs_class_fs_stats)
section below for more information.
-->

<p>非同期の stat(2)。コールバックは 2 つの引数を受け取る <code>(err, stats)</code>で、
<code>stats</code> は <a href="#fs_class_fs_stats">fs.Stats</a> オブジェクトです。
詳細は <a href="#fs_class_fs_stats">fs.Stats</a> の節を参照してください。

</p>
<!--
See the [fs.Stats](#fs.Stats) section below for more information.
-->

<p>より詳しくは後述の <a href="#fs.Stats">fs.Stats</a> の節を参照してください。

</p>
<h2>fs.lstat(path, callback)<span><a class="mark" href="#fs_fs_lstat_path_callback" id="fs_fs_lstat_path_callback">#</a></span></h2>
<!--
Asynchronous lstat(2). The callback gets two arguments `(err, stats)` where
`stats` is a `fs.Stats` object. `lstat()` is identical to `stat()`, except that if
`path` is a symbolic link, then the link itself is stat-ed, not the file that it
refers to.
-->

<p>非同期の lstat(2)。コールバックは 2 つの引数を受け取る <code>(err, stats)</code>で、
<code>stats</code> は <code>fs.Stats</code> オブジェクトです。
<code>lstat()</code> はパスがシンボリックリンクだった場合に、
参照先のファイルではなくそのリンク自身が調べられる点を除いて <code>stat()</code> と同じす。

</p>
<h2>fs.fstat(fd, callback)<span><a class="mark" href="#fs_fs_fstat_fd_callback" id="fs_fs_fstat_fd_callback">#</a></span></h2>
<!--
Asynchronous fstat(2). The callback gets two arguments `(err, stats)` where
`stats` is a `fs.Stats` object. `fstat()` is identical to `stat()`, except that
the file to be stat-ed is specified by the file descriptor `fd`.
-->

<p>非同期の fstat(2)。コールバックは 2 つの引数を受け取る <code>(err, stats)</code> で、
<code>stats</code> は <code>fs.Stats</code> オブジェクトです。
状態を取得するファイルをファイル記述子 <code>fd</code> で指定することを除いて、
<code>fstat()</code> は <code>stat()</code> と同じです。

</p>
<h2>fs.statSync(path)<span><a class="mark" href="#fs_fs_statsync_path" id="fs_fs_statsync_path">#</a></span></h2>
<!--
Synchronous stat(2). Returns an instance of `fs.Stats`.
-->

<p>同期の stat(2)。<code>fs.Stats</code> のインスタンスを返します。

</p>
<h2>fs.lstatSync(path)<span><a class="mark" href="#fs_fs_lstatsync_path" id="fs_fs_lstatsync_path">#</a></span></h2>
<!--
Synchronous lstat(2). Returns an instance of `fs.Stats`.
-->

<p>同期の lstat(2)。<code>fs.Stats</code> のインスタンスを返します。

</p>
<h2>fs.fstatSync(fd)<span><a class="mark" href="#fs_fs_fstatsync_fd" id="fs_fs_fstatsync_fd">#</a></span></h2>
<!--
Synchronous fstat(2). Returns an instance of `fs.Stats`.
-->

<p>同期の fstat(2)。<code>fs.Stats</code> のインスタンスを返します。

</p>
<h2>fs.link(srcpath, dstpath, callback)<span><a class="mark" href="#fs_fs_link_srcpath_dstpath_callback" id="fs_fs_link_srcpath_dstpath_callback">#</a></span></h2>
<!--
Asynchronous link(2). No arguments other than a possible exception are given to
the completion callback.
-->

<p>非同期の link(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.linkSync(srcpath, dstpath)<span><a class="mark" href="#fs_fs_linksync_srcpath_dstpath" id="fs_fs_linksync_srcpath_dstpath">#</a></span></h2>
<!--
Synchronous link(2).
-->

<p>同期の link(2)。

</p>
<h2>fs.symlink(srcpath, dstpath, [type], callback)<span><a class="mark" href="#fs_fs_symlink_srcpath_dstpath_type_callback" id="fs_fs_symlink_srcpath_dstpath_type_callback">#</a></span></h2>
<!--
Asynchronous symlink(2). No arguments other than a possible exception are given
to the completion callback.
The `type` argument can be set to `'dir'`, `'file'`, or `'junction'` (default
is `'file'`) and is only available on Windows (ignored on other platforms).
Note that Windows junction points require the destination path to be absolute.  When using
`'junction'`, the `destination` argument will automatically be normalized to absolute path.
-->

<p>非同期の symlink(2)。
完了コールバックには発生し得る例外以外に引数が渡されることはありません。
<code>type</code> 引数は <code>'dir'</code>、<code>'file'</code>、または <code>'junction</code>' (デフォルトは <code>'file'</code>)
に設定することができ、Windows でのみ利用可能です
(他のプラットフォームでは無視されます)。
Windows のジャンクションポイントは対象に絶対パスを要求することに
注意してください。
<code>'junction'</code> を使うと、<code>destination</code> 引数は自動的に絶対パスに正規化されます。

</p>
<h2>fs.symlinkSync(srcpath, dstpath, [type])<span><a class="mark" href="#fs_fs_symlinksync_srcpath_dstpath_type" id="fs_fs_symlinksync_srcpath_dstpath_type">#</a></span></h2>
<!--
Synchronous symlink(2).
-->

<p>同期の symlink(2)。

</p>
<h2>fs.readlink(path, callback)<span><a class="mark" href="#fs_fs_readlink_path_callback" id="fs_fs_readlink_path_callback">#</a></span></h2>
<!--
Asynchronous readlink(2). The callback gets two arguments `(err,
linkString)`.
-->

<p>非同期の readlink(2)。コールバックは 2 つの引数を受け取る <code>(err, linkString)</code>です。

</p>
<h2>fs.readlinkSync(path)<span><a class="mark" href="#fs_fs_readlinksync_path" id="fs_fs_readlinksync_path">#</a></span></h2>
<!--
Synchronous readlink(2). Returns the symbolic link's string value.
-->

<p>同期の readlink(2)。シンボリックリンクの持つ文字列値を返します。

</p>
<h2>fs.realpath(path, [cache], callback)<span><a class="mark" href="#fs_fs_realpath_path_cache_callback" id="fs_fs_realpath_path_cache_callback">#</a></span></h2>
<!--
Asynchronous realpath(2). The `callback` gets two arguments `(err,
resolvedPath)`. May use `process.cwd` to resolve relative paths. `cache` is an
object literal of mapped paths that can be used to force a specific path
resolution or avoid additional `fs.stat` calls for known real paths.
-->

<p>非同期の realpath(2)。コールバックは 2 つの引数を受け取る <code>(err, resolvedPath)</code>です。
相対パスを解決するために <code>process.cwd</code> を使用することができます。
<code>cache</code> はオブジェクトで、パスがキーとして含まれていればその値が
強制的に解決されたパスとして扱われ、<code>fs.stat</code> によってパスが実在するかどうかの
確認が省かれます。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>var cache = {'/etc':'/private/etc'};
fs.realpath('/etc/passwd', cache, function (err, resolvedPath) {
  if (err) throw err;
  console.log(resolvedPath);
});</code></pre>
<h2>fs.realpathSync(path, [cache])<span><a class="mark" href="#fs_fs_realpathsync_path_cache" id="fs_fs_realpathsync_path_cache">#</a></span></h2>
<!--
Synchronous realpath(2). Returns the resolved path.
-->

<p>同期の realpath(2)。解決されたパスを返します。

</p>
<h2>fs.unlink(path, callback)<span><a class="mark" href="#fs_fs_unlink_path_callback" id="fs_fs_unlink_path_callback">#</a></span></h2>
<!--
Asynchronous unlink(2). No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の unlink(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.unlinkSync(path)<span><a class="mark" href="#fs_fs_unlinksync_path" id="fs_fs_unlinksync_path">#</a></span></h2>
<!--
Synchronous unlink(2).
-->

<p>同期の unlink(2)。

</p>
<h2>fs.rmdir(path, callback)<span><a class="mark" href="#fs_fs_rmdir_path_callback" id="fs_fs_rmdir_path_callback">#</a></span></h2>
<!--
Asynchronous rmdir(2). No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の rmdir(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.rmdirSync(path)<span><a class="mark" href="#fs_fs_rmdirsync_path" id="fs_fs_rmdirsync_path">#</a></span></h2>
<!--
Synchronous rmdir(2).
-->

<p>同期の rmdir(2)。

</p>
<h2>fs.mkdir(path, [mode], callback)<span><a class="mark" href="#fs_fs_mkdir_path_mode_callback" id="fs_fs_mkdir_path_mode_callback">#</a></span></h2>
<!--
Asynchronous mkdir(2). No arguments other than a possible exception are given
to the completion callback. `mode` defaults to `0777`.
-->

<p>非同期の mkdir(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。
<code>mode</code> のデフォルトは <code>0777</code> です。

</p>
<h2>fs.mkdirSync(path, [mode])<span><a class="mark" href="#fs_fs_mkdirsync_path_mode" id="fs_fs_mkdirsync_path_mode">#</a></span></h2>
<!--
Synchronous mkdir(2).
-->

<p>同期の mkdir(2)。

</p>
<h2>fs.readdir(path, callback)<span><a class="mark" href="#fs_fs_readdir_path_callback" id="fs_fs_readdir_path_callback">#</a></span></h2>
<!--
Asynchronous readdir(3).  Reads the contents of a directory.
The callback gets two arguments `(err, files)` where `files` is an array of
the names of the files in the directory excluding `'.'` and `'..'`.
-->

<p>非同期の readdir(3)。ディレクトリの内容を読み込みます。
コールバックは 2 つの引数を受け取る <code>(err, files)</code>で、
<code>files</code> は <code>'.'</code> と <code>'..'</code> を除くディレクトリ内のファイル名の配列です。

</p>
<h2>fs.readdirSync(path)<span><a class="mark" href="#fs_fs_readdirsync_path" id="fs_fs_readdirsync_path">#</a></span></h2>
<!--
Synchronous readdir(3). Returns an array of filenames excluding `'.'` and
`'..'`.
-->

<p>同期の readdir(3)。<code>'.'</code> と <code>'..'</code> を除くディレクトリ内のファイル名の配列を返します。

</p>
<h2>fs.close(fd, callback)<span><a class="mark" href="#fs_fs_close_fd_callback" id="fs_fs_close_fd_callback">#</a></span></h2>
<!--
Asynchronous close(2).  No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の close(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.closeSync(fd)<span><a class="mark" href="#fs_fs_closesync_fd" id="fs_fs_closesync_fd">#</a></span></h2>
<!--
Synchronous close(2).
-->

<p>同期の close(2)。

</p>
<h2>fs.open(path, flags, [mode], callback)<span><a class="mark" href="#fs_fs_open_path_flags_mode_callback" id="fs_fs_open_path_flags_mode_callback">#</a></span></h2>
<!--
Asynchronous file open. See open(2). `flags` can be:
-->

<p>非同期のファイルオープン。open(2) を参照してください。
フラグは以下になります:

</p>
<!--
* `'r'` - Open file for reading.
An exception occurs if the file does not exist.
-->

<ul>
<li><code>'r'</code> - ファイルを読み込み専用でオープンします。
ファイルが存在しない場合は例外が発生します。</li>
</ul>
<!--
* `'r+'` - Open file for reading and writing.
An exception occurs if the file does not exist.
-->

<ul>
<li><code>'r+'</code> - ファイルを読み書き両用でオープンします。
ファイルが存在しない場合は例外が発生します。</li>
</ul>
<!--
* `'rs'` - Open file for reading in synchronous mode. Instructs the operating
  system to bypass the local file system cache.

  This is primarily useful for opening files on NFS mounts as it allows you to
  skip the potentially stale local cache. It has a very real impact on I/O
  performance so don't use this flag unless you need it.

  Note that this doesn't turn `fs.open()` into a synchronous blocking call.
  If that's what you want then you should be using `fs.openSync()`
-->

<ul>
<li><p><code>'rs'</code> - ファイルを同期モードで読み込むためにオープンします。
オペレーティングシステムにローカルファイルシステムのキャッシュを
バイパスするように指示します。</p>
<p>これは主に NFS にマウントされたファイルをオープンして、潜在的に古い
ローカルキャッシュをスキップするのに役立ちます。
これはI/O パフォーマンスにとても深刻な影響を与えるため、必要でない限りは
このフラグを使用しないでください。</p>
<p>これは <code>fs.open()</code> を同期的なブロッキング呼び出しにするわけではないことに
注意してください。
それが必要な場合は <code>fs.openSync()</code> を使用すべきです。</p>
</li>
</ul>
<!--
* `'rs+'` - Open file for reading and writing, telling the OS to open it
  synchronously. See notes for `'rs'` about using this with caution.
-->

<ul>
<li><code>'rs+'</code> - ファイルを読み書き両方でオープンし、OS に同期的にオープンするように
伝えます。これを使用する際の警告は <code>'rs'</code> の注意を参照してください。</li>
</ul>
<!--
* `'w'` - Open file for writing.
The file is created (if it does not exist) or truncated (if it exists).
-->

<ul>
<li><code>'w'</code> - ファイルを書き込み専用でオープンします。
ファイルは作成されるか (存在しない場合)、または長さ 0 に切り詰められます
(存在する場合)。</li>
</ul>
<!--
* `'wx'` - Like `'w'` but fails if `path` exists.
-->

<ul>
<li><code>'wx'</code> - <code>'w'</code> と似ていますが、<code>path</code> が存在すると失敗します。</li>
</ul>
<!--
* `'w+'` - Open file for reading and writing.
The file is created (if it does not exist) or truncated (if it exists).
-->

<ul>
<li><code>'w+'</code> - ファイルを読み書き両用でオープンします。
ファイルは作成されるか (存在しない場合)、または長さ 0 に切り詰められます
(存在する場合)。</li>
</ul>
<!--
* `'wx+'` - Like `'w+'` but fails if `path` exists.
-->

<ul>
<li><code>'wx+'</code> - <code>'w+'</code> と似ていますが、<code>path</code> が存在すると失敗します。</li>
</ul>
<!--
* `'a'` - Open file for appending.
The file is created if it does not exist.
-->

<ul>
<li><code>'a'</code> - ファイルを追記用でオープンします。
ファイルが存在しない場合は作成されます。</li>
</ul>
<!--
* `'ax'` - Like `'a'` but fails if `path` exists.
-->

<ul>
<li><code>'ax'</code> - <code>'a'</code> と似ていますが、<code>path</code> が存在すると失敗します。</li>
</ul>
<!--
* `'a+'` - Open file for reading and appending.
The file is created if it does not exist.
-->

<ul>
<li><code>'a+'</code> - ファイルを読み込みおよび追記用でオープンします。
ファイルが存在しない場合は作成されます。</li>
</ul>
<!--
* `'ax+'` - Like `'a+'` but fails if `path` exists.
-->

<ul>
<li><code>'ax+'</code> - <code>'a+'</code> と似ていますが、<code>path</code> が存在すると失敗します。</li>
</ul>
<!--
`mode` sets the file mode (permission and sticky bits), but only if the file was
created. It defaults to `0666`, readable and writeable.
-->

<p><code>mode</code> はファイルモード (許可とスティッキービット) を設定しますが、
それはファイルが作成される場合に限られます。
デフォルトは 0666 です。

</p>
<!--
The callback gets two arguments `(err, fd)`.
-->

<p>コールバックは 2 つの引数を受け取る <code>(err, fd)</code>です。

</p>
<!--
The exclusive flag `'x'` (`O_EXCL` flag in open(2)) ensures that `path` is newly
created. On POSIX systems, `path` is considered to exist even if it is a symlink
to a non-existent file. The exclusive flag may or may not work with network file
systems.
-->

<p>排他フラグ <code>'x'</code> (open(2) の <code>O_EXCL</code> フラグ) は、
<code>path</code> が新しいファイルとして作成されることを保証します。
POSIX システムでは、<code>path</code> がたとえ存在しないファイルへのシンボリックだとしても
存在すると見なされます。
排他モードはネットワークファイルシステムでは動くかもしれませんし、
動かないかもしれません。

</p>
<!--
On Linux, positional writes don't work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.
-->

<p>Linux では、ファイルを追記モードでオープンした場合、
ポジションを指定した書き込みは動作しません。
カーネルはポジション引数を無視し、データを常にファイルの最後に追記します。

</p>
<h2>fs.openSync(path, flags, [mode])<span><a class="mark" href="#fs_fs_opensync_path_flags_mode" id="fs_fs_opensync_path_flags_mode">#</a></span></h2>
<!--
Synchronous version of `fs.open()`.
-->

<p>同期版の open(2)。

</p>
<h2>fs.utimes(path, atime, mtime, callback)<span><a class="mark" href="#fs_fs_utimes_path_atime_mtime_callback" id="fs_fs_utimes_path_atime_mtime_callback">#</a></span></h2>
<h2>fs.utimesSync(path, atime, mtime)<span><a class="mark" href="#fs_fs_utimessync_path_atime_mtime" id="fs_fs_utimessync_path_atime_mtime">#</a></span></h2>
<!--
Change file timestamps.
Change file timestamps of the file referenced by the supplied path.
-->

<p>渡されたパスが参照するファイルのタイムスタンプを変更します。

</p>
<h2>fs.futimes(fd, atime, mtime, callback)<span><a class="mark" href="#fs_fs_futimes_fd_atime_mtime_callback" id="fs_fs_futimes_fd_atime_mtime_callback">#</a></span></h2>
<h2>fs.futimesSync(fd, atime, mtime)<span><a class="mark" href="#fs_fs_futimessync_fd_atime_mtime" id="fs_fs_futimessync_fd_atime_mtime">#</a></span></h2>
<!--
Change the file timestamps of a file referenced by the supplied file
descriptor.
-->

<p>渡されたファイル記述子が参照するファイルのタイムスタンプを変更します。

</p>
<h2>fs.fsync(fd, callback)<span><a class="mark" href="#fs_fs_fsync_fd_callback" id="fs_fs_fsync_fd_callback">#</a></span></h2>
<!--
Asynchronous fsync(2). No arguments other than a possible exception are given
to the completion callback.
-->

<p>非同期の fsync(2)。完了コールバックには発生し得る例外以外に引数が渡されることはありません。

</p>
<h2>fs.fsyncSync(fd)<span><a class="mark" href="#fs_fs_fsyncsync_fd" id="fs_fs_fsyncsync_fd">#</a></span></h2>
<!--
Synchronous fsync(2).
-->

<p>同期の fsync(2)。

</p>
<h2>fs.write(fd, buffer, offset, length, position, callback)<span><a class="mark" href="#fs_fs_write_fd_buffer_offset_length_position_callback" id="fs_fs_write_fd_buffer_offset_length_position_callback">#</a></span></h2>
<!--
Write `buffer` to the file specified by `fd`.
-->

<p><code>fd</code> で指定されたファイルに <code>buffer</code> を書き込みます。

</p>
<!--
`offset` and `length` determine the part of the buffer to be written.
-->

<p><code>offset</code> と <code>length</code> は書き込まれるバッファの部分を決定します。

</p>
<!--
`position` refers to the offset from the beginning of the file where this data
should be written. If `position` is `null`, the data will be written at the
current position.
See pwrite(2).
-->

<p><code>position</code> はデータが書き込まれる位置をファイルの先頭からのオフセットで示します。
<code>position</code> が <code>null</code> の場合、データは現在の位置から書き込まれます。
pwrite(2) を参照してください。

</p>
<!--
The callback will be given two arguments `(err, written)` where `written`
specifies how many _bytes_ were written.
The callback will be given three arguments `(err, written, buffer)` where `written`
specifies how many _bytes_ were written from `buffer`.
-->

<p>コールバックは 3 つの引数が与えられる <code>(err, written, buffer)</code> で、
<code>written</code> は <code>buffer</code> から書き込まれた<em>バイト数</em>を示します。

</p>
<!--
Note that it is unsafe to use `fs.write` multiple times on the same file
without waiting for the callback. For this scenario,
`fs.createWriteStream` is strongly recommended.
-->

<p>同じファイルに対してコールバックされるのを待つことなく <code>fs.write()</code> を何度も呼び出すことは、安全ではないことに注意してください。
このシナリオでは、 <code>fs.createWriteStream()</code> を強く推奨します。

</p>
<p>On Linux, positional writes don't work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.

</p>
<h2>fs.writeSync(fd, buffer, offset, length, position)<span><a class="mark" href="#fs_fs_writesync_fd_buffer_offset_length_position" id="fs_fs_writesync_fd_buffer_offset_length_position">#</a></span></h2>
<!--
Synchronous version of `fs.write()`. Returns the number of bytes written.
-->

<p>同期版の <code>fs.write()</code>。書き込まれたバイト数を返します。

</p>
<h2>fs.read(fd, buffer, offset, length, position, callback)<span><a class="mark" href="#fs_fs_read_fd_buffer_offset_length_position_callback" id="fs_fs_read_fd_buffer_offset_length_position_callback">#</a></span></h2>
<!--
Read data from the file specified by `fd`.
-->

<p><code>fd</code> で指定されたファイルからデータを読み込みます。

</p>
<!--
`buffer` is the buffer that the data will be written to.
-->

<p><code>buffer</code> はデータが書き込まれるバッファです。

</p>
<!--
`offset` is the offset in the buffer to start writing at.
-->

<p><code>offset</code> は書き込みを開始するバッファ内のオフセットです。

</p>
<!--
`length` is an integer specifying the number of bytes to read.
-->

<p><code>length</code> は読み込むバイト数を指定する整数です。

</p>
<!--
`position` is an integer specifying where to begin reading from in the file.
If `position` is `null`, data will be read from the current file position.
-->

<p><code>position</code> はファイルの読み込みを開始する位置を指定する整数です。
<code>position</code> が <code>null</code> の場合、データは現在の位置から読み込まれます。

</p>
<!--
The callback is given the three arguments, `(err, bytesRead, buffer)`.
-->

<p>コールバックは3つの引数が与えられる <code>(err, bytesRead, buffer)</code> です。

</p>
<h2>fs.readSync(fd, buffer, offset, length, position)<span><a class="mark" href="#fs_fs_readsync_fd_buffer_offset_length_position" id="fs_fs_readsync_fd_buffer_offset_length_position">#</a></span></h2>
<!--
Synchronous version of `fs.read`. Returns the number of `bytesRead`.
-->

<p>同期版の <code>fs.read</code>。<code>bytesRead</code> の数を返します。

</p>
<h2>fs.readFile(filename, [options], callback)<span><a class="mark" href="#fs_fs_readfile_filename_options_callback" id="fs_fs_readfile_filename_options_callback">#</a></span></h2>
<!--
* `filename` {String}
* `options` {Object}
  * `encoding` {String | Null} default = `null`
  * `flag` {String} default = `'r'`
* `callback` {Function}
-->

<ul>
<li><code>filename</code> {String}</li>
<li><code>options</code> {Object}<ul>
<li><code>encoding</code> {String | Null} デフォルトは <code>null</code></li>
<li><code>flag</code> {String} デフォルトは <code>'r'</code></li>
</ul>
</li>
<li><code>callback</code> {Function}</li>
</ul>
<!--
Asynchronously reads the entire contents of a file. Example:
-->

<p>ファイル全体の内容を非同期に読み込みます。例:

</p>
<pre><code>fs.readFile('/etc/passwd', function (err, data) {
  if (err) throw err;
  console.log(data);
});</code></pre>
<!--
The callback is passed two arguments `(err, data)`, where `data` is the
contents of the file.
-->

<p>コールバックは 2 つの引数が渡される <code>(err, data)</code> で、<code>data</code> はファイルの内容です。

</p>
<!--
If no encoding is specified, then the raw buffer is returned.
-->

<p>エンコーディングが指定されなければ、生のバッファが渡されます。

</p>
<h2>fs.readFileSync(filename, [options])<span><a class="mark" href="#fs_fs_readfilesync_filename_options" id="fs_fs_readfilesync_filename_options">#</a></span></h2>
<!--
Synchronous version of `fs.readFile`. Returns the contents of the `filename`.
-->

<p>同期版の <code>fs.readFile</code>。<code>filename</code> の内容を返します。

</p>
<!--
If the `encoding` option is specified then this function returns a
string. Otherwise it returns a buffer.
-->

<p><code>encoding</code> オプションが指定されるとこの関数は文字列を返します。
そうでなければバッファを返します。


</p>
<h2>fs.writeFile(filename, data, [options], callback)<span><a class="mark" href="#fs_fs_writefile_filename_data_options_callback" id="fs_fs_writefile_filename_data_options_callback">#</a></span></h2>
<!--
* `filename` {String}
* `data` {String | Buffer}
* `options` {Object}
  * `encoding` {String | Null} default = `'utf8'`
  * `mode` {Number} default = `438` (aka `0666` in Octal)
  * `flag` {String} default = `'w'`
* `callback` {Function}
-->

<ul>
<li><code>filename</code> {String}</li>
<li><code>data</code> {String | Buffer}</li>
<li><code>options</code> {Object}<ul>
<li><code>encoding</code> {String | Null} デフォルトは <code>'utf8'</code></li>
<li><code>mode</code> {Number} デフォルトは <code>438</code> (8進数の <code>0666</code>)</li>
<li><code>flag</code> {String} デフォルトは <code>'w'</code></li>
</ul>
</li>
<li><code>callback</code> {Function}</li>
</ul>
<!--
Asynchronously writes data to a file, replacing the file if it already exists.
`data` can be a string or a buffer.
-->

<p>非同期にデータをファイルに書き込みます。
ファイルが既に存在する場合は置き換えられます。
<code>data</code> は文字列またはバッファです。

</p>
<!--
The `encoding` option is ignored if `data` is a buffer. It defaults
to `'utf8'`.
-->

<p><code>data</code> がバッファの場合、<code>encoding</code> オプションは無視されます。
デフォルトは <code>'utf8'</code> です。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>fs.writeFile('message.txt', 'Hello Node', function (err) {
  if (err) throw err;
  console.log('It\'s saved!');
});</code></pre>
<h2>fs.writeFileSync(filename, data, [options])<span><a class="mark" href="#fs_fs_writefilesync_filename_data_options" id="fs_fs_writefilesync_filename_data_options">#</a></span></h2>
<!--
The synchronous version of `fs.writeFile`.
-->

<p>同期版の <code>fs.writeFile</code>。

</p>
<h2>fs.appendFile(filename, data, [options], callback)<span><a class="mark" href="#fs_fs_appendfile_filename_data_options_callback" id="fs_fs_appendfile_filename_data_options_callback">#</a></span></h2>
<!--
* `filename` {String}
* `data` {String | Buffer}
* `options` {Object}
  * `encoding` {String | Null} default = `'utf8'`
  * `mode` {Number} default = `438` (aka `0666` in Octal)
  * `flag` {String} default = `'a'`
* `callback` {Function}
-->

<ul>
<li><code>filename</code> {String}</li>
<li><code>data</code> {String | Buffer}</li>
<li><code>options</code> {Object}<ul>
<li><code>encoding</code> {String | Null} デフォルトは <code>'utf8'</code></li>
<li><code>mode</code> {Number} デフォルトは <code>438</code> (8進数の <code>0666</code>)</li>
<li><code>flag</code> {String} デフォルトは <code>'a'</code></li>
</ul>
</li>
<li><code>callback</code> {Function}</li>
</ul>
<!--
Asynchronously append data to a file, creating the file if it not yet exists.
`data` can be a string or a buffer.
-->

<p>非同期にデータをファイルに追加します。
ファイルが存在しなければ作成されます。
<code>data</code> は文字列またはバッファです。

</p>
<!--
Example:
-->

<p>例:

</p>
<pre><code>fs.appendFile('message.txt', 'data to append', function (err) {
  if (err) throw err;
  console.log('The "data to append" was appended to file!');
});</code></pre>
<h2>fs.appendFileSync(filename, data, [options])<span><a class="mark" href="#fs_fs_appendfilesync_filename_data_options" id="fs_fs_appendfilesync_filename_data_options">#</a></span></h2>
<!--
The synchronous version of `fs.appendFile`.
-->

<p>同期版の <code>fs.appendFile</code>。

</p>
<h2>fs.watchFile(filename, [options], listener)<span><a class="mark" href="#fs_fs_watchfile_filename_options_listener" id="fs_fs_watchfile_filename_options_listener">#</a></span></h2>
<pre class="api_stability_2">Stability: 2 - Unstable.  Use fs.watch instead, if possible.</pre><!--
Watch for changes on `filename`. The callback `listener` will be called each
time the file is accessed.
-->

<p><code>filename</code> の変更を監視します。コールバックの <code>listener</code> はファイルがアクセスされる度に呼び出されます。

</p>
<!--
The second argument is optional. The `options` if provided should be an object
containing two members a boolean, `persistent`, and `interval`. `persistent`
indicates whether the process should continue to run as long as files are
being watched. `interval` indicates how often the target should be polled,
in milliseconds. The default is `{ persistent: true, interval: 5007 }`.
-->

<p>第 2 引数はオプションです．
<code>options</code> が与えられる場合、それは boolean の <code>persistent</code> と <code>interval</code>
の二つのメンバを含むオブジェクトです。
<code>persistent</code> はファイルが監視されている間、
プロセスが実行し続けることを示します。
<code>interval</code> は対象をポーリングする間隔をミリ秒で示します
デフォルトは <code>{ persistent: true, interval: 5007 }</code> です。

</p>
<!--
The `listener` gets two arguments the current stat object and the previous
stat object:
-->

<p><code>listener</code> は現在の状態オブジェクトと前の状態オブジェクトの 2 つの引数を受け取ります:

</p>
<pre><code>fs.watchFile('message.text', function (curr, prev) {
  console.log('the current mtime is: ' + curr.mtime);
  console.log('the previous mtime was: ' + prev.mtime);
});</code></pre>
<!--
These stat objects are instances of `fs.Stat`.

If you want to be notified when the file was modified, not just accessed
you need to compare `curr.mtime` and `prev.mtime`.
-->

<p>これらの状態オブジェクトは <code>fs.Stat</code> のインスタンスです。

</p>
<p>もしファイルがアクセスされただけでなく、変更された時の通知が必要であれば、<code>curr.mtime</code> と <code>prev.mtime</code> を比較する必要があります。

</p>
<h2>fs.unwatchFile(filename, [listener])<span><a class="mark" href="#fs_fs_unwatchfile_filename_listener" id="fs_fs_unwatchfile_filename_listener">#</a></span></h2>
<pre class="api_stability_2">Stability: 2 - Unstable.  Use fs.watch instead, if possible.</pre><!--
Stop watching for changes on `filename`. If `listener` is specified, only that
particular listener is removed. Otherwise, *all* listeners are removed and you
have effectively stopped watching `filename`.

Calling `fs.unwatchFile()` with a filename that is not being watched is a
no-op, not an error.
-->

<p><code>filename</code> の変更に対する監視を終了します。
<code>listener</code> が指定された場合は該当の <code>listener</code> だけが取り除かれます。
そうでなければ、<em>全ての</em> リスナが取り除かれ、
<code>filenam</code> の監視は事実上終了します。

</p>
<p>監視されていないファイル名を指定した <code>fs.unwatchFile()</code> の呼び出しは
エラーになるのではなく、何もしません。

</p>
<h2>fs.watch(filename, [options], [listener])<span><a class="mark" href="#fs_fs_watch_filename_options_listener" id="fs_fs_watch_filename_options_listener">#</a></span></h2>
<pre class="api_stability_2">Stability: 2 - Unstable.</pre><!--
Watch for changes on `filename`, where `filename` is either a file or a
directory.  The returned object is a [fs.FSWatcher](#fs_class_fs_fswatcher).

The second argument is optional. The `options` if provided should be an object
containing a boolean member `persistent`, which indicates whether the process
should continue to run as long as files are being watched. The default is
`{ persistent: true }`.

The listener callback gets two arguments `(event, filename)`.  `event` is either
'rename' or 'change', and `filename` is the name of the file which triggered
the event.
-->

<p><code>filename</code> の変更を監視します。
<code>filename</code> はファイルまたはディレクトリのどちらかです。
戻り値のオブジェクトは <a href="#fs.FSWatcher">fs.FSWatcher</a> です。

</p>
<p>第 2 引数はオプションです。
もし指定されるなら、<code>options</code> は boolean の <code>persistent</code> プロパティを
持つオブジェクトであるべきです。
<code>persistent</code> はファイルが監視されている間、
プロセスが実行し続けることを示します。
デフォルトは <code>{ persistent: true }</code> です。

</p>
<p>リスナーコールバックは二つの引数 <code>(event, filename)</code> を与えられます。
<code>event</code> は <code>'rename'</code> または <code>'change'</code>、そして <code>filename</code> はイベントを
引き起こしたファイルの名前です。

</p>
<h3>Caveats<span><a class="mark" href="#fs_caveats" id="fs_caveats">#</a></span></h3>
<!--type=misc-->

<!--
The `fs.watch` API is not 100% consistent across platforms, and is
unavailable in some situations.
-->

<p><code>fs.watch</code> API はプラットフォーム間で 100% 完全ではありmせんし、
いくつかのシチュエーションで利用不可能です。

</p>
<h4>Availability<span><a class="mark" href="#fs_availability" id="fs_availability">#</a></span></h4>
<!--type=misc-->

<!--
This feature depends on the underlying operating system providing a way
to be notified of filesystem changes.
-->

<p>この機能は下層のオペレーティングシステムが提供するファイルシステム変更の
通知に依存します。

</p>
<!--
* On Linux systems, this uses `inotify`.
* On BSD systems (including OS X), this uses `kqueue`.
* On SunOS systems (including Solaris and SmartOS), this uses `event ports`.
* On Windows systems, this feature depends on `ReadDirectoryChangesW`.
-->

<ul>
<li>Linux システムでは <code>inotify</code> が使われます。</li>
<li>BSD システム (OS X を含みます) では <code>kqueue</code> が使われます。</li>
<li>SunOS システム (Solaris および SmartOS を含みます) では <code>event ports</code>
が使われます。</li>
<li>Windows システムでは、この機能は <code>ReadDirectoryChangesW</code> に依存します。</li>
</ul>
<!--
If the underlying functionality is not available for some reason, then
`fs.watch` will not be able to function.  For example, watching files or
directories on network file systems (NFS, SMB, etc.) often doesn't work
reliably or at all.
-->

<p>何らかの理由で下層の機能が使えない場合、<code>fs.watch()</code> は使えません。
たとえば、ネットワークファイルシステム (NFS、SMB、その他) はしばしば
信頼できないか全く動作しません。

</p>
<!--
You can still use `fs.watchFile`, which uses stat polling, but it is slower and
less reliable.
-->

<p>stat をポーリングする <code>fs.watchFile()</code> を使うことはできますが、
それは遅くて信頼性はより低くなります。

</p>
<h4>Filename Argument<span><a class="mark" href="#fs_filename_argument" id="fs_filename_argument">#</a></span></h4>
<!--type=misc-->

<!--
Providing `filename` argument in the callback is not supported
on every platform (currently it's only supported on Linux and Windows).  Even
on supported platforms `filename` is not always guaranteed to be provided.
Therefore, don't assume that `filename` argument is always provided in the
callback, and have some fallback logic if it is null.
-->

<p>コールバックに提供される <code>filename</code> 引数は、
全てのプラットフォームでサポートされるわけではありません
(現時点では Linux と Windows でのみサポートされます)。
サポートされるプラットフォームであっても、<code>filename</code> が常に提供されることが
保証されているわけではありません。
そのため、コールバックは <code>filename</code> 引数が常に提供されると仮定せず、
それが <code>null</code> だったときの代替手段を持つべきです。

</p>
<pre><code>fs.watch('somedir', function (event, filename) {
  console.log('event is: ' + event);
  if (filename) {
    console.log('filename provided: ' + filename);
  } else {
    console.log('filename not provided');
  }
});</code></pre>
<h2>fs.exists(path, callback)<span><a class="mark" href="#fs_fs_exists_path_callback" id="fs_fs_exists_path_callback">#</a></span></h2>
<!--
Test whether or not the given path exists by checking with the file system.
Then call the `callback` argument with either true or false.  Example:
-->

<p>与えられたパスがファイルシステム上に存在するかどうか検査します。
そして引数の <code>callback</code> を真か偽か検査の結果とともに呼び出します。
例:

</p>
<pre><code>fs.exists('/etc/passwd', function (exists) {
  util.debug(exists ? "it's there" : "no passwd!");
});</code></pre>
<!--
`fs.exists()` is an anachronism and exists only for historical reasons.
There should almost never be a reason to use it in your own code.
-->

<p><code>fs.exists()</code> は時代錯誤で、存在する理由は歴史的経緯だけです。
あなたのコードでこれを使うべき理由があってはいけません。

</p>
<!--
In particular, checking if a file exists before opening it is an anti-pattern
that leaves you vulnerable to race conditions: another process may remove the
file between the calls to `fs.exists()` and `fs.open()`.  Just open the file
and handle the error when it's not there.
-->

<p>とりわけ、ファイルをオープンする前に存在をチェックするのは、
あなたのコードを競合条件に対して脆弱にするアンチパターンです:
<code>fs.exists()</code> と <code>fs.open()</code> の間に別のプロセスがファイルを
削除するかもしれません。
単純にファイルをオープンして、それが存在しない時はエラーを処理してください。

</p>
<h2>fs.existsSync(path)<span><a class="mark" href="#fs_fs_existssync_path" id="fs_fs_existssync_path">#</a></span></h2>
<!--
Synchronous version of `fs.exists`.
-->

<p>同期版の <code>fs.exists</code> です。

</p>
<h2>Class: fs.Stats<span><a class="mark" href="#fs_class_fs_stats" id="fs_class_fs_stats">#</a></span></h2>
<!--
Objects returned from `fs.stat()`, `fs.lstat()` and `fs.fstat()` and their
synchronous counterparts are of this type.
-->

<p><code>fs.stat()</code>、<code>fs.lstat()</code>、<code>fs.fstat()</code>、そしてそれらの同期版 から返される
オブジェクトはこの型です。

</p>
<!--
 - `stats.isFile()`
 - `stats.isDirectory()`
 - `stats.isBlockDevice()`
 - `stats.isCharacterDevice()`
 - `stats.isSymbolicLink()` (only valid with  `fs.lstat()`)
 - `stats.isFIFO()`
 - `stats.isSocket()`
-->

<ul>
<li><code>stats.isFile()</code></li>
<li><code>stats.isDirectory()</code></li>
<li><code>stats.isBlockDevice()</code></li>
<li><code>stats.isCharacterDevice()</code></li>
<li><code>stats.isSymbolicLink()</code> (<code>fs.lstat()</code> でのみ有効)</li>
<li><code>stats.isFIFO()</code></li>
<li><code>stats.isSocket()</code></li>
</ul>
<!--
For a regular file `util.inspect(stats)` would return a string very
similar to this:
-->

<p><code>util.inspect(stats)</code> は通常のファイルに対して次のような文字列を返します。

</p>
<pre><code>{ dev: 2114,
  ino: 48064969,
  mode: 33188,
  nlink: 1,
  uid: 85,
  gid: 100,
  rdev: 0,
  size: 527,
  blksize: 4096,
  blocks: 8,
  atime: Mon, 10 Oct 2011 23:24:11 GMT,
  mtime: Mon, 10 Oct 2011 23:24:11 GMT,
  ctime: Mon, 10 Oct 2011 23:24:11 GMT }</code></pre>
<!--
Please note that `atime`, `mtime` and `ctime` are instances
of [Date][MDN-Date] object and to compare the values of
these objects you should use appropriate methods. For most
general uses [getTime()][MDN-Date-getTime] will return
the number of milliseconds elapsed since _1 January 1970
00:00:00 UTC_ and this integer should be sufficient for
any comparison, however there additional methods which can
be used for displaying fuzzy information. More details can
be found in the [MDN JavaScript Reference][MDN-Date] page.
-->

<p><code>atime</code>、<code>mtime</code>、そして <code>ctime</code> は <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">Date</a> オブジェクトであり、
その値を比較するには適切な方法があるということに注意してください。
もっとも一般的に使われる <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getTime">getTime()</a> は <em>1970 年 1 月
1 日</em>からの経過時間をミリ秒単位で返します。
それは比較には十分ですが、曖昧な情報を表示するには別の方法を使ってください。
より詳しい情報は <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">MDN JavaScript Reference</a> で探すことができます。

</p>
<h2>fs.createReadStream(path, [options])<span><a class="mark" href="#fs_fs_createreadstream_path_options" id="fs_fs_createreadstream_path_options">#</a></span></h2>
<!--
Returns a new ReadStream object (See `Readable Stream`).
-->

<p>新しい ReadStream オブジェクトを返します (<code>Readable Stream</code> を参照してください)。

</p>
<!--
`options` is an object with the following defaults:
-->

<p><code>options</code> は以下のデフォルト値を持つオブジェクトです:

</p>
<pre><code>{ flags: 'r',
  encoding: null,
  fd: null,
  mode: 0666,
  autoClose: true
}</code></pre>
<!--
`options` can include `start` and `end` values to read a range of bytes from
the file instead of the entire file.  Both `start` and `end` are inclusive and
start at 0. The `encoding` can be `'utf8'`, `'ascii'`, or `'base64'`.
-->

<p>ファイル全体を読み込む代わりに一部の範囲を読み込むため、
<code>options</code> に <code>start</code> および <code>end</code> を含めることができます。
<code>start</code> と <code>end</code> はどちらも包含的で0から始まります。
<code>encoding</code> は <code>'utf8'</code>、<code>'ascii'</code>、または <code>'base64'</code> です。

</p>
<!--
If `autoClose` is false, then the file descriptor won't be closed, even if
there's an error.  It is your responsiblity to close it and make sure
there's no file descriptor leak.  If `autoClose` is set to true (default
behavior), on `error` or `end` the file descriptor will be closed
automatically.
-->

<p><code>autoClose</code> が <code>false</code> の場合、エラーが発生しない限りファイル記述子は
クローズされません。ファイルをクローズし、ファイル記述子が
リークしないようにするのはあなたの責務です。
<code>autoClose</code> が <code>true</code> に設定されると (デフォルトの振る舞いです)、
<code>error</code> または <code>end</code> によってファイル記述子は自動的にクローズされます。

</p>
<!--
An example to read the last 10 bytes of a file which is 100 bytes long:
-->

<p>100 バイトの長さを持つファイルの最後の 10 バイトを読み込む例:

</p>
<pre><code>fs.createReadStream('sample.txt', {start: 90, end: 99});</code></pre>
<h2>Class: fs.ReadStream<span><a class="mark" href="#fs_class_fs_readstream" id="fs_class_fs_readstream">#</a></span></h2>
<!--
`ReadStream` is a [Readable Stream](stream.html#stream_class_stream_readable).
-->

<p><code>ReadStream</code> は <a href="stream.html#stream_class_stream_readable">Readable Stream</a>
です。

</p>
<h3>Event: 'open'<span><a class="mark" href="#fs_event_open" id="fs_event_open">#</a></span></h3>
<!--
* `fd` {Integer} file descriptor used by the ReadStream.

Emitted when the ReadStream's file is opened.
-->

<ul>
<li><code>fd</code> {Integer} ReadStream で使われる ファイル記述子。</li>
</ul>
<p>ReadStream のファイルがオープンされた場合に生成されます。


</p>
<h2>fs.createWriteStream(path, [options])<span><a class="mark" href="#fs_fs_createwritestream_path_options" id="fs_fs_createwritestream_path_options">#</a></span></h2>
<!--
Returns a new WriteStream object (See `Writable Stream`).
-->

<p>新しい WriteStream オブジェクトを返します (<code>Writable Stream</code> を参照してください)。

</p>
<!--
`options` is an object with the following defaults:
-->

<p><code>options</code> は以下のデフォルト値を持つオブジェクトです:

</p>
<pre><code>{ flags: 'w',
  encoding: null,
  mode: 0666 }</code></pre>
<!--
`options` may also include a `start` option to allow writing data at
some position past the beginning of the file.  Modifying a file rather
than replacing it may require a `flags` mode of `r+` rather than the
default mode `w`.
-->

<p><code>options</code> にはデータをファイルのどの位置に書き込むかを指定する
<code>start</code> を含めることができます。
ファイルを置換するのではなく変更する場合は、 <code>flags</code> にデフォルトの
<code>w</code> ではなく <code>r+</code> が必要となります。

</p>
<h2>Class: fs.WriteStream<span><a class="mark" href="#fs_class_fs_writestream" id="fs_class_fs_writestream">#</a></span></h2>
<!--
`WriteStream` is a [Writable Stream](stream.html#stream_class_stream_writable).
-->

<p><code>WriteStream</code> は <a href="stream.html#stream_class_stream_writable">Writable Stream</a>
です。

</p>
<h3>Event: 'open'<span><a class="mark" href="#fs_event_open_1" id="fs_event_open_1">#</a></span></h3>
<!--
* `fd` {Integer} file descriptor used by the WriteStream.

Emitted when the WriteStream's file is opened.
-->

<ul>
<li><code>fd</code> {Integer} WriteStream で使われる ファイル記述子。</li>
</ul>
<p>WriteStream のファイルがオープンされた場合に生成されます。

</p>
<h3>file.bytesWritten<span><a class="mark" href="#fs_file_byteswritten" id="fs_file_byteswritten">#</a></span></h3>
<!--
The number of bytes written so far. Does not include data that is still queued
for writing.
-->

<p>これまでに書き込まれたバイト数。
書き込みがキューイングされたままのデータは含まれません。

</p>
<h2>Class: fs.FSWatcher<span><a class="mark" href="#fs_class_fs_fswatcher" id="fs_class_fs_fswatcher">#</a></span></h2>
<!--
Objects returned from `fs.watch()` are of this type.
-->

<p><code>fs.watch()</code> が返すオブジェクトはこの型です。

</p>
<h3>watcher.close()<span><a class="mark" href="#fs_watcher_close" id="fs_watcher_close">#</a></span></h3>
<!--
Stop watching for changes on the given `fs.FSWatcher`.
-->

<p><code>fs.FSWatcher</code> に与えられたファイルの監視を終了します。

</p>
<h3>Event: 'change'<span><a class="mark" href="#fs_event_change" id="fs_event_change">#</a></span></h3>
<!--
* `event` {String} The type of fs change
* `filename` {String} The filename that changed (if relevant/available)
-->

<ul>
<li><code>event</code> {String} ファイルシステム変更の種類です。</li>
<li><code>filename</code> {String} 変更されたファイル名です (もし利用可能であれば)。</li>
</ul>
<!--
Emitted when something changes in a watched directory or file.
See more details in [fs.watch](#fs_fs_watch_filename_options_listener).
-->

<p>監視しているファイルまたはディレクトリに変更があると生成されます。
詳しくは <a href="#fs_fs_watch_filename_options_listener">fs.watch</a>
を参照してください。

</p>
<h3>Event: 'error'<span><a class="mark" href="#fs_event_error" id="fs_event_error">#</a></span></h3>
<div class="signature"><ul>
<li><code>error</code> <span class="type">Error object</span></li>
</ul></div>
<!--
Emitted when an error occurs.
-->

<p>エラーが発生すると生成されます。
</p>

          </div>
        </div>
    </div>
    <div id="footer">
        <a href="http://joyent.com" class="joyent-logo">Joyent</a>
        <ul class="clearfix">
            <!--
            <li><a href="/">Node.js</a></li>
            <li><a href="/download/">Download</a></li>
            <li><a href="/about/">About</a></li>
            <li><a href="http://npmjs.org/">npm Registry</a></li>
            <li><a href="http://nodejs.org/api/">Docs</a></li>
            <li><a href="http://blog.nodejs.org">Blog</a></li>
            <li><a href="/community/">Community</a></li>
            <li><a href="/logos/">Logos</a></li>
            -->
            <li><a href="../">Node.js</a></li>
            <li><a href="../#download">ダウンロード</a></li>
            <li><a href="../about/">概要</a></li>
            <li><a href="http://npmjs.org/">npm レジストリ</a></li>
            <li><a href="../api/">ドキュメント</a></li>
            <li><a href="http://blog.nodejs.org">ブログ</a></li>
            <li><a href="../community/">コミュニティ</a></li>
            <li><a href="../logos/">ロゴ</a></li>
            <li><a href="http://jobs.nodejs.org/">Jobs</a></li>
            <li><a href="http://twitter.com/nodejs" class="twitter">@nodejs</a></li>
        </ul>

        <p>Copyright <a href="http://joyent.com/">Joyent, Inc</a>, Node.js is a <a href="/trademark-policy.pdf">trademark</a> of Joyent, Inc. View <a href="https://raw.github.com/joyent/node/v0.10.26/LICENSE">license</a>.</p>
    </div>

  <script src="../sh_main.js"></script>
  <script src="../sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
  <script>
    window._gaq = [['_setAccount', 'UA-10874194-2'], ['_trackPageview']];
    (function(d, t) {
      var g = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      g.src = '//www.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g, s);
    }(document, 'script'));
  </script>
</body>
</html>

